<?xml version="1.0"?>
<configuration platform="Renoir">
<!--
XML configuration for Renoir based platforms

Reference: PPR for AMD Family 17h Model 18h B1. 55570-B1 Rev 3.16 - Apr 14, 2021.

The following registers are defined in the reference PPR but have not been included:
- ACP: the location of the BAR for APC access is not defined in the reference.
- SMM: unreachable from the kernel.
- SBTSI: unclear how to access this address space.
- PMC events: no support in chipsec for performance monitor counters.
-->

  <!-- #################################### -->
  <!--                                      -->
  <!-- Information                          -->
  <!--                                      -->
  <!-- #################################### -->
  <info family="core">
    <sku did="0x1630" name="Renoir" code="Renoir" longname="Renoir Root Complex" />
  </info>

  <!-- #################################### -->
  <!--                                      -->
  <!-- Integrated devices                   -->
  <!--                                      -->
  <!-- #################################### -->
  <pci>
    <!-- Table 13: PCI Device ID Assignments. -->
    <!-- Bus A and B are programmable. Here, we assume A = 5 and B = 1. -->
    <device name="ROOT"           bus="0" dev="0x00" fun="0" vid="0x1022" did="0x15D0" />
    <device name="IOMMU"          bus="0" dev="0x00" fun="2" vid="0x1022" did="0x15D1" />
    <device name="HOSTDUMMY0"     bus="0" dev="0x01" fun="0" vid="0x1022" did="0x1452" />
    <!-- PCIe GPP Bridge -->
    <device name="GPP0"           bus="0" dev="0x01" fun="1" vid="0x1022" did="0x15D3" />
    <device name="GPP1"           bus="0" dev="0x01" fun="2" vid="0x1022" did="0x15D3" />
    <device name="GPP2"           bus="0" dev="0x01" fun="3" vid="0x1022" did="0x15D3" />
    <device name="GPP3"           bus="0" dev="0x01" fun="4" vid="0x1022" did="0x15D3" />
    <device name="GPP4"           bus="0" dev="0x01" fun="5" vid="0x1022" did="0x15D3" />
    <device name="GPP5"           bus="0" dev="0x01" fun="6" vid="0x1022" did="0x15D3" />
    <device name="GPP6"           bus="0" dev="0x01" fun="7" vid="0x1022" did="0x15D3" />
    <device name="HOSTDUMMY1"     bus="0" dev="0x08" fun="0" vid="0x1022" did="0x1452" />
    <device name="GPP0TOBUSA"     bus="0" dev="0x08" fun="1" vid="0x1022" did="0x15DB" />
    <device name="GPP0TOBUSB"     bus="0" dev="0x08" fun="2" vid="0x1022" did="0x15DC" />
    <!-- Note: Vendor ID 1002h is used for Internal GPU and Display HD Audio Controller. -->
    <!-- Model 18h: did=0x15D8. Models 10h, 11h: did=0x15DD -->
    <device name="GPU"            bus="5" dev="0x00" fun="0" vid="0x1002" did="0x15D8,0x15DD" />
    <device name="DISPLAYHDAUDIO" bus="5" dev="0x00" fun="1" vid="0x1002" did="0x15DE" />
    <device name="USB0"           bus="5" dev="0x00" fun="3" vid="0x1022" did="0x15E0" />
    <device name="USB1"           bus="5" dev="0x00" fun="4" vid="0x1022" did="0x15E1" />
    <device name="AUDIO"          bus="5" dev="0x00" fun="5" vid="0x1022" did="0x15E2" />
    <device name="HDAUDIO"        bus="5" dev="0x00" fun="6" vid="0x1022" did="0x15E3" />
    <!-- Data Fabric devices -->
    <device name="DF0"            bus="0" dev="0x18" fun="0" vid="0x1022" did="0x15E8" />
    <device name="DF1"            bus="0" dev="0x18" fun="1" vid="0x1022" did="0x15E9" />
    <device name="DF2"            bus="0" dev="0x18" fun="2" vid="0x1022" did="0x15EA" />
    <device name="DF3"            bus="0" dev="0x18" fun="3" vid="0x1022" did="0x15EB" />
    <device name="DF4"            bus="0" dev="0x18" fun="4" vid="0x1022" did="0x15EC" />
    <device name="DF5"            bus="0" dev="0x18" fun="5" vid="0x1022" did="0x15ED" />
    <device name="DF6"            bus="0" dev="0x18" fun="6" vid="0x1022" did="0x15EE" />
    <!-- Not documented, but exists according to illumos developpers -->
    <device name="DF7"            bus="0" dev="0x18" fun="7" vid="0x1022" did="0x15EF" />
    <device name="SATAMS"         bus="1" dev="0x00" fun="0" vid="0x1022" did="0x7901" />
    <device name="SATAAMD"        bus="1" dev="0x00" fun="0" vid="0x1022" did="0x7904" />
    <device name="SD"             bus="0" dev="0x14" fun="6" vid="0x1022" did="0x7906" />
    <device name="SMBUS"          bus="0" dev="0x14" fun="0" vid="0x1022" did="0x790B" />
    <device name="LPC"            bus="0" dev="0x14" fun="3" vid="0x1022" did="0x790E" />
    <device name="SATARAID0"      bus="1" dev="0x00" fun="0" vid="0x1022" did="0x7916" />
    <device name="SATARAID1"      bus="1" dev="0x00" fun="0" vid="0x1022" did="0x7917" />
    <device name="GBE0"           bus="1" dev="0x00" fun="1" vid="0x1022" did="0x1458" />
    <device name="GBE1"           bus="1" dev="0x00" fun="2" vid="0x1022" did="0x1458" />
    <device name="FUNCTIONDUMMY"  bus="1" dev="0x00" fun="0" vid="0x1022" did="0x145A" />
  </pci>

  <!-- #################################### -->
  <!--                                      -->
  <!-- Memory Mapped I/O spaces (MMIO BARs) -->
  <!--                                      -->
  <!-- #################################### -->
  <mmio>
    <!-- page 53 -->
    <bar name="APIC" register="APIC_BAR" base_field="ApicBar[47:12]" size="0x1000" enable_field="ApicEn" desc="APIC Base Address"/>
    <!-- page 290 -->
    <bar name="IOMMUBAR" register="IOMMU_CAP_BASE_LO" base_field="IOMMU_BASE_ADDR_LO" register_high="IOMMU_CAP_BASE_HI"  base_field_high="IOMMU_BASE_ADDR_HI" enable_field="IOMMU_ENABLE" size="0x100000" />
    <!-- page 453 -->
    <bar name="ESPI" register="SPIBaseAddr" base_field="Spi_eSpi_BaseAddr" size="0x100" fixed_address="0xFEC10000" offset="0x10000" desc="eSPI Controller Register Range" />
    <!-- page 567 -->
    <!-- TODO: support field TP[1] to switch between 32 and 64 bits -->
    <bar name="SDHC" register="SD_PCI_BAR" base_field="BAR" register_high="SD_PCI_UPPER_BAR" base_field_high="UBAR" size="0x100" />
    <!-- page 446 -->
    <bar name="SPI" register="SPIBaseAddr" base_field="Spi_eSpi_BaseAddr" enable_field="SpiRomEnable" size="0x100" desc="SPI Controller Register Range" fixed_address="0xFEC10000" />

    <!-- The name MMCFG is not defined in the AMD spec, but must be kept consistent with the corresponding BAR on Intel, since the Python code relies on it. -->
    <!-- The size of the MMIO configuration space is at least 1MB and depends on field BusRange. It is computed in mmio.py. -->
    <bar name="MMCFG" register="MmioCfgBaseAddr" base_field="MmioCfgBaseAddr[47:20]" enable_field="Enable" desc="MMIO Configuration Base Address"/>

    <!-- IOMMU section 8.1.2.3 defines a number of BARs which are not used
    to access registers but MMIO data structures. Defining them here is
    useful to simplify dumping the relevant parts of memory, even if they are
    referenced in the <register> section. -->
    <bar name="IOMMU_MMIO_DEVTBL_BASE" bus="0" register="IOMMU_MMIO_DEVTBL_BASE_0" base_field="DEV_TBL_BASE_LO" register_high="IOMMU_MMIO_DEVTBL_BASE_1" base_field_high="DEV_TBL_BASE_HI" desc="" />
  </mmio>

  <!-- #################################### -->
  <!--                                      -->
  <!-- Memory ranges                        -->
  <!--                                      -->
  <!-- #################################### -->
  <memory>
    <!-- page 360 -->
    <range name="LPC/SPI ROM_1"       access="mmio" address="0x0" size="0xFFFFF" />
    <range name="LPC/SPI ROM_2"       access="mmio" address="0x00FF000000" size="0xFFFFFF" />
    <range name="LPC/SPI ROM_3"       access="mmio" address="0xFD00000000" size="0x3FFFFFF" />

    <!-- page 393 -->
    <!-- enabled through PmDecodeEn[IoApicEn] -->
    <range name="IOAPIC" address="0xFEC00000" access="mmio" sie="0x7F" />
    <!-- page 446 -->
    <!-- Can be accessed as a mmiobar but the address should be fixed, see above. -->
    <range name="SPI" address="0xFEC10000" access="mmio" size="0xFF" />
    <!-- page 453 -->
    <!-- Can be accessed as a mmiobar but the address should be fixed, see above. -->
    <range name="ESPI" address="0xFEC20000" access="mmio" size="0xFF" />
    <!-- page 426 -->
    <!-- enable-bit: PMx00[HpetEn] -->
    <!-- alternatively mapped to address 0xFED80C00 (enable-bit: Mmio[En]) -->
    <range name="HPET" address="0xFED00000" access="mmio" size="0x1FF" />

    <!-- page 360 -->
    <!-- See page 491, and below, for a more detailed breakdown of ACPI MMIO Space -->
    <range name="ACPI"                access="mmio" address="0xFED80000" size="0x1FFF" />
    <range name="AL2AHB"              access="mmio" address="0xFEDC0000" size="0x0FFF" />
    <range name="I2C_2 Master"        access="mmio" address="0xFEDC4000" size="0x0FFF" />
    <range name="I2C_3 Master"        access="mmio" address="0xFEDC5000" size="0x0FFF" />
    <range name="I2C_4 Slave for USB" access="mmio" address="0xFEDC6000" size="0x0FFF" />
    <range name="Power Delivery"      access="mmio" address="0xFEDC7000" size="0x0FFF" />
    <range name="DMAC0"               access="mmio" address="0xFEDC8000" size="0x0FFF" />
    <range name="DMAC1"               access="mmio" address="0xFEDC9000" size="0x0FFF" />
    <range name="UART0"               access="mmio" address="0xFEDCA000" size="0x0FFF" />
    <range name="UART1"               access="mmio" address="0xFEDCC000" size="0x0FFF" />
    <range name="DMA_2"               access="mmio" address="0xFEDCD000" size="0x0FFF" />
    <range name="DMA_3"               access="mmio" address="0xFEDCE000" size="0x0FFF" />
    <range name="UART_2"              access="mmio" address="0xFEDCF000" size="0x0FFF" />
    <range name="UART_3"              access="mmio" address="00FEDD0000" size="0x4FFF" />
    <!-- See below for a more detailed breakdown of EMMC Control Space -->
    <range name="EMMC Control"        access="mmio" address="0xFEDD5000" size="0x0FFF" />

    <!-- ACPI MMIO Space -->
    <!-- For this whole section, enable-bit: Mmio[En]-->
    <!-- page 491 -->
    <range name="SMBus PCI" address="0xFED80000" access="mmio" size="0xFF" />
    <!-- page 578 -->
    <!-- Legacy range inside SMBus PCI. Should really start on FED80040 and have
    a size of 0x14 but we keep it consistent with the official doc. -->
    <range name="HCE" address="0xFED80000" access="mmio" size="0x54" />
    <!-- page 395 -->
    <range name="SMI" address="0xFED80200" access="mmio" size="0xFF" />
    <!-- page 491 -->
    <!-- also called PMIO -->
    <range name="PM" address="0xFED80300" access="mmio" size="0xFF" />
    <!-- page 508 -->
    <!-- also called PMIO2 -->
    <range name="PM2" address="0xFED80400" access="mmio" size="0xFF" />
    <!-- page 357 -->
    <range name="BIOS_RAM" address="0xFED80500" access="mmio" size="0xFF" />
    <range name="CMOS_RAM" address="0xFED80600" access="mmio" size="0xFF"  />
    <!-- page 358 -->
    <range name="CMOS" address="0xFED80700" access="mmio" size="0xFF" />
    <!-- This range is confusingly defined in several places in the reference.
    Note that there is another BAR named PM above, and also another BAR named ACPI.
    In this translation, we use the name ACPI, instead of PM as is done in page 517 to avoid a clash.
    It should really have a more specific name and use the proper offsets
    but we try and keep it consistent with the official doc. -->
    <!-- <range name="PM/APIC" address="0xFED80800" access="mmio" size="0x1FF" /> -->
    <!-- page 491 -->
    <range name="ASF" address="0xFED80900" access="mmio" size="0xFF" />
    <range name="SMBus" address="0xFED80A00" access="mmio" size="0xFF" />
    <!-- page 429 -->
    <!-- alternatively mapped to address 0xFEB00000 (enable-bit: PmDecodeEn[WatchdogTmrEn]) -->
    <range name="WDT" address="0xFED80B00" access="mmio" size="0xF" />
    <!-- page 426 -->
    <!-- alternative HPET mapping, we prefer the range above per the doc -->
    <!-- <range name="HPET" address="0xFED80C00" access="mmio" size="0x1FF" /> -->
    <!-- page 526 -->
    <range name="IOMUX" address="0xFED80D00" access="mmio" size="0xFF" />
    <!-- page 473 -->
    <range name="MISC" address="0xFED80E00" access="mmio" size="0xFF" />
    <!-- page 491 -->
    <range name="Shadow System Counter" address="0xFED81100" access="mmio" size="0xFF" />
    <range name="DP-VGA" address="0xFED81400" access="mmio" size="0xFF" />
    <!-- page 555 -->
    <!-- divided in 4 banks, each of size 0xFF -->
    <range name="GPIO" address="0xFED81500" access="mmio" size="0x3FF" />
    <!-- page 430 -->
    <range name="ACDC" address="0xFED81D00" access="mmio" size="0xFF" />
    <!-- page 432 -->
    <range name="AOAC" address="0xFED81E00" access="mmio" size="0xFF" />

    <!-- EMMC Control -->
    <!-- page 382 -->
    <range name="EMMCHC" address="0xFEDD5000" access="mmio" size="0xFF" />
    <!-- page 377 -->
    <range name="EMMCCFG" address="0xFEDD5800" access="mmio" size="0x1FF" />

  </memory>

  <!-- #################################### -->
  <!--                                      -->
  <!-- Indirect memory accesses             -->
  <!--                                      -->
  <!-- #################################### -->
  <ima>
    <!-- page 274 -->
    <indirect name="IOMMUL1INT0" index="SmnIndex" data="SmnData" base="0x14700000" />
    <!-- page 284 -->
    <indirect name="IOMMUL2A" index="SmnIndex" data="SmnData" base="0x15700000" />
    <!-- page 287 -->
    <indirect name="IOMMUL2B" index="SmnIndex" data="SmnData" base="0x13F01000" />
    <!-- page 258 -->
    <indirect name="SMUTHM" index="SmnIndex" data="SmnData" base="0x00059800" />

    <!-- The devices below are defined in the reference but are not used in the
    definition of registers, mostly because indirect access is there as a legacy
    fallback and mmio or memory ranges are prefered. We add them for completeness. -->
    <indirect name="IoPort" index="IoCfgAddr" data="IoCfgData" />
    <!-- page 357 -->
    <indirect name="BIOS_RAM" index="BiosRAMIndex" data="BiosRAMData" />
    <indirect name="CMOS_RAM" index="AltRtcAddrPort" data="AltRtcDataPort" />
    <!-- page 358 -->
    <indirect name="CMOS" index="RtcAddrPort" data="RtcDataPort" />
    <!-- page 491 -->
    <!-- Prefer access through memory-mapping, this does not seem to work in practice.  -->
    <indirect name="PM" index="PmIndex" data="PmData" />
    <!-- page 507 -->
    <!-- Prefer access through memory-mapping, this does not seem to work in practice.  -->
    <indirect name="PM2" index="PM2Index" data="PM2Data" />
  </ima>

  <!-- #################################### -->
  <!--                                      -->
  <!-- I/O spaces (I/O BARs)                -->
  <!--                                      -->
  <!-- #################################### -->
  <io>
    <!-- The BARs below are not necessary because can also be accessed via memory mapping.
    We include them for completeness since they are in the reference. As an example: -->
    <!-- page 517 -->
    <bar name="AcpiPm1EvtBlk" register="AcpiPm1EvtBlk" base_field="AcpiPm1EvtBlk" />
    <bar name="AcpiPm1CntBlk" register="AcpiPm1CntBlk" base_field="AcpiPm1CntBlk" />
    <!-- CLKVALUE, PLvl2 and PLvl3 can be accessed via CpuControl, or MMIO, but are not defined: -->
    <bar name="CpuControl" register="PCntBlk" base_field="CpuControl" />
  </io>

  <!-- #################################### -->
  <!--                                      -->
  <!-- Configuration registers              -->
  <!--                                      -->
  <!-- #################################### -->
  <registers>
    <!-- 2.1.7 PCI Configuration Legacy Access -->

    <!-- page 41 -->

    <register name="IoCfgAddr" type="io" port="0x0CF8" size="4" desc="IO-Space Configuration Address. Read-write. Reset: 0000_0000h. IO::IoCfgAddr, and IO::IoCfgData are used to access system configuration space, as defined by the PCI specification. IO::IoCfgAddr provides the address register and IO::IoCfgData provides the data port. Software sets up the configuration address by writing to IO::IoCfgAddr. Then, when an access is made to IO::IoCfgData, the processor generates the corresponding configuration access to the address specified in IO::IoCfgAddr. See 2.1.6 [Configuration Space]. IO::IoCfgAddr may only be accessed through aligned, DW IO Reads and Writes; otherwise, the accesses are passed to the appropriate IO link. Accesses to IO::IoCfgAddr and IO::IoCfgData received from an IO link are treated as all other IO transactions received from an IO link. IO::IoCfgAddr and IO::IoCfgData in the processor are not accessible from an IO link.">
      <field name="ConfigEn" bit="31" size="1" desc="configuration space enable. Read-write. Reset: 0. 0=IO Read and Write accesses are passed to the appropriate IO link and no configuration access is generated. 1=IO Read and Write accesses to IO::IoCfgData are translated into configuration cycles at the configuration address specified by this register." />
      <!-- Bits 30:28 reserved. -->
      <field name="ExtRegNo" bit="24" size="4" desc="extended register number. Read-write. Reset: 0h. ExtRegNo provides bits[11:8] and RegNo provides bits[7:2] of the byte address of the configuration register." />
      <field name="BusNo" bit="16" size="8" desc="bus number. Read-write. Reset: 00h. Specifies the bus number of the configuration cycle." />
      <field name="Device" bit="11" size="5" desc="device number. Read-write. Reset: 00h. Specifies the device number of the configuration cycle." />
      <field name="Function" bit="8" size="3" desc="Read-write. Reset: 0h. Specifies the function number of the configuration cycle." />
      <field name="RegNo" bit="2" size="6" desc="register address. Read-write. Reset: 00h. See IO::IoCfgAddr[ExtRegNo]." />
      <!-- Bits 1:0 reserved. -->
    </register>
    <register name="IoCfgData" type="io" port="0x0CFC" size="4" desc="IO-Space Configuration Data Port. Read-write. Reset: 0000_0000h.">
      <field name="Data" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. See IO::IoCfgAddr." />
    </register>

    <!-- 2.1.11.2.2 Local APIC Registers -->

    <!-- page 53 -->

    <register name="ApicId" type="mmio" bar="APIC" offset="0x020" size="4" desc="APIC ID. Read-only.">
      <field name="ApicId" bit="24" size="8" desc="APIC ID. Read-only. Reset: XXh. The reset value varies based on core number. See 2.1.11.2.1.3 [ApicId Enumeration Requirements]." />
      <!-- Bits 23:0 reserved. -->
    </register>
    <register name="ApicVersion" type="mmio" bar="APIC" offset="0x030" size="4" desc="APIC Version. Read-only.">
      <field name="ExtApicSpace" bit="31" size="1" desc="extended APIC register space present. Read-only. Reset: 1. 1=Indicates the presence of extended APIC register space starting at Core::X86::Apic::ExtendedApicFeature." />
      <!-- Bits 30:25 reserved. -->
      <field name="DirectedEoiSupport" bit="24" size="1" desc="directed EOI support. Read-only. Reset: Fixed,0. 0=Directed EOI capability not supported." />
      <field name="MaxLvtEntry" bit="16" size="8" desc="Read-only. Reset: XXh. Specifies the number of entries in the local vector table minus one." />
      <!-- Bits 15:8 reserved. -->
      <field name="Version" bit="0" size="8" desc="Read-only. Reset: 10h. Indicates the version number of this APIC implementation." />
    </register>

    <!-- page 54 -->

    <register name="TaskPriority" type="mmio" bar="APIC" offset="0x080" size="4" desc="Task Priority. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:8 reserved. -->
      <field name="Priority" bit="0" size="8" desc="Read-write. Reset: 00h. This field is assigned by software to set a threshold priority at which the core is interrupted." />
    </register>
    <register name="ArbitrationPriority" type="mmio" bar="APIC" offset="0x090" size="4" desc="Arbitration Priority. Read-only,Volatile. Reset: 0000_0000h.">
      <!-- Bits 31:8 reserved. -->
      <field name="Priority" bit="0" size="8" desc="Read-only,Volatile. Reset: 00h. Indicates the current priority for a pending interrupt, or a task or interrupt being serviced by the core. The priority is used to arbitrate between cores to determine which accepts a lowest-priority interrupt request." />
    </register>
    <register name="ProcessorPriority" type="mmio" bar="APIC" offset="0x0A0" size="4" desc="Processor Priority. Read-only,Volatile. Reset: 0000_0000h.">
      <!-- Bits 31:8 reserved. -->
      <field name="Priority" bit="0" size="8" desc="Read-only,Volatile. Reset: 00h. Indicates the core's current priority servicing a task or interrupt, and is used to determine if any pending interrupts should be serviced. It is the higher value of the task priority value and the current highest in-service interrupt." />
    </register>
    <register name="EndOfInterrupt" type="mmio" bar="APIC" offset="0x0B0" size="4" desc="End of Interrupt. Write-only. This register is written by the software interrupt handler to indicate the servicing of the current interrupt is complete.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="RemoteRead" type="mmio" bar="APIC" offset="0x0C0" size="4" desc="Reserved. Read-only. Reset: 0000_0000h. Remote Read is deprecated.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="LocalDestination" type="mmio" bar="APIC" offset="0x0D0" size="4" desc="Logical Destination. Read-write,Volatile. Reset: 0000_0000h.">
      <field name="Destination" bit="24" size="8" desc="Read-write,Volatile. Reset: 00h. This APIC's destination identification. Used to determine which interrupts should be accepted." />
      <!-- Bits 23:0 reserved. -->
    </register>

    <!-- page 55 -->

    <register name="DestinationFormat" type="mmio" bar="APIC" offset="0x0E0" size="4" desc="Destination Format. Read-write. Reset: F000_0000h. Only supported in xAPIC mode.">
      <field name="Format" bit="28" size="4" desc="Read-write. Reset: Fh. Controls which format to use when accepting interrupts with a logical destination mode." />
      <!-- Bits 27:0 reserved. -->
    </register>
    <register name="SpuriousInterruptVector" type="mmio" bar="APIC" offset="0x0F0" size="4" desc="Spurious-Interrupt Vector. Reset: 0000_00FFh.">
      <!-- Bits 31:10 reserved. -->
      <field name="FocusDisable" bit="9" size="1" desc="Read-write. Reset: 0. 1=Disable focus core checking during lowest-priority arbitrated interrupts." />
      <field name="APICSWEn" bit="8" size="1" desc="APIC software enable. Read-write,Volatile. Reset: 0. 0=SMI, NMI, INIT, LINT[1:0], and Startup interrupts may be accepted; pending interrupts in Core::X86::Apic::InService and Core::X86::Apic::InterruptRequest are held, but further fixed, lowest-priority, and ExtInt interrupts are not accepted. All LVT entry mask bits are set and cannot be cleared." />
      <field name="Vector" bit="0" size="8" desc="Read-write,Volatile. Reset: FFh. The vector that is sent to the core in the event of a spurious interrupt." />
    </register>

    <!-- TODO Multiple BAR instances, keeping only first one: APICx1[0...7]0 [In-Service] (Core::X86::Apic::InService) -->
    <register name="InService" type="mmio" bar="APIC" offset="0x100" size="4" desc="In-Service. Read-only,Volatile. Reset: 0000_0000h. The in-service registers provide a bit per interrupt to indicate that the corresponding interrupt is being serviced by the core. The first 16 InServiceBits of the first Core::X86::Apic::InService register are Reserved.">
      <field name="InServiceBits" bit="0" size="32" desc="Read-only,Volatile. Reset: 0000_0000h. These bits are set when the corresponding interrupt is being serviced by the core." />
    </register>

    <!-- page 56 -->

    <!-- TODO Multiple BAR instances, keeping only first one: APICx1[8...F]0 [Trigger Mode] (Core::X86::Apic::TriggerMode) -->
    <register name="TriggerMode" type="mmio" bar="APIC" offset="0x180" size="4" desc="Trigger Mode. Read-only,Volatile. Reset: 0000_0000h. The trigger mode registers provide a bit per interrupt to indicate the assertion mode of each interrupt. The first 16 TriggerModeBits of the each thread's APIC[1F0:180] registers are Reserved.">
      <field name="TriggerModeBits" bit="0" size="32" desc="Read-only,Volatile. Reset: 0000_0000h. The corresponding trigger mode bit is updated when an interrupt is accepted. 1=Level-triggered interrupt. 0=Edge-triggered interrupt." />
    </register>

    <!-- page 57 -->

    <!-- TODO Multiple BAR instances, keeping only first one: APICx2[0...7]0 [Interrupt Request] (Core::X86::Apic::InterruptRequest) -->
    <register name="InterruptRequest" type="mmio" bar="APIC" offset="0x200" size="4" desc="Interrupt Request. Read-only. Reset: 0000_0000h. The interrupt request registers provide a bit per interrupt to indicate that the corresponding interrupt has been accepted by the APIC. The first 16 RequestBits of the first Core::X86::Apic::InterruptRequest register are Reserved.">
      <field name="RequestBits" bit="0" size="32" desc="Read-only. Reset: 0000_0000h. The corresponding request bit is set when the an interrupt is accepted by the APIC." />
    </register>
    <register name="ErrorStatus" type="mmio" bar="APIC" offset="0x280" size="4" desc="Error Status. Writes to this register trigger an update of the register state. The value written by software is arbitrary. Each write causes the internal error state to be loaded into this register, clearing the internal error state. Consequently, a second write prior to the occurrence of another error causes the register to be overwritten with cleared data.">
      <!-- Bits 31:8 reserved. -->
      <field name="IllegalRegAddr" bit="7" size="1" desc="illegal register address. Read-write. Reset: 0. This bit indicates that an access to a nonexistent register location within this APIC was attempted. Can only be set in xAPIC mode." />
      <field name="RcvdIllegalVector" bit="6" size="1" desc="received illegal vector. Read-write. Reset: 0. This bit indicates that this APIC has received a message with an illegal vector (00h to 0Fh for fixed and lowest priority interrupts)." />
      <field name="SentIllegalVector" bit="5" size="1" desc="Read-write. Reset: 0. This bit indicates that this APIC attempted to send a message with an illegal vector (00h to 0Fh for fixed and lowest priority interrupts)." />
      <!-- Bit 4 reserved. -->
      <field name="RcvAcceptError" bit="3" size="1" desc="receive accept error. Read-write. Reset: 0. This bit indicates that a message received by this APIC was not accepted by this or any other APIC." />
      <field name="SendAcceptError" bit="2" size="1" desc="Read-write. Reset: 0. This bit indicates that a message sent by this APIC was not accepted by any APIC." />
      <!-- Bits 1:0 reserved. -->
    </register>

    <!-- page 58 -->

    <register name="InterruptCommandLow" type="mmio" bar="APIC" offset="0x300" size="4" desc="Interrupt Command Low. Reset: 0000_0000h.">
      <!-- Bits 31:20 reserved. -->
      <field name="DestShrthnd" bit="18" size="2" desc="destination shorthand. Read-write. Reset: 0h. Description: Provides a quick way to specify a destination for a message. If all including self or all excluding self is used, then destination mode is ignored and physical is automatically used." />
      <field name="RemoteRdStat" bit="16" size="2" desc="Read-only. Reset: 0h." />
      <field name="TM" bit="15" size="1" desc="trigger mode. Read-write. Reset: 0. 0=Edge triggered. 1=Level triggered. Indicates how this interrupt is triggered." />
      <field name="Level" bit="14" size="1" desc="Read-write. Reset: 0. 0=De-asserted. 1=Asserted." />
      <!-- Bit 13 reserved. -->
      <field name="DS" bit="12" size="1" desc="interrupt delivery status. Read-only. Reset: 0. 0=Idle. 1=Send pending. In xAPIC mode this bit is set to indicate that the interrupt has not yet been accepted by the destination core(s). Software may repeatedly write Core::X86::Apic::InterruptCommandLow without polling the DS bit; all requested IPIs are delivered." />
      <field name="DM" bit="11" size="1" desc="destination mode. Read-write. Reset: 0. 0=Physical. 1=Logical." />
      <field name="MsgType" bit="8" size="3" desc="Read-write. Reset: 0h. The message types are encoded as follows:" />
      <field name="Vector" bit="0" size="8" desc="Read-write. Reset: 00h. The vector that is sent for this interrupt source." />
    </register>

    <!-- page 59 -->

    <register name="InterruptCommandHigh" type="mmio" bar="APIC" offset="0x310" size="4" desc="Interrupt Command High. Read-write. Reset: 0000_0000h.">
      <field name="DestinationField" bit="24" size="8" desc="Read-write. Reset: 00h. The destination encoding used when Core::X86::Apic::InterruptCommandLow[DestShrthnd] is 00b." />
      <!-- Bits 23:0 reserved. -->
    </register>
    <register name="TimerLvtEntry" type="mmio" bar="APIC" offset="0x320" size="4" desc="LVT Timer. Reset: 0001_0000h.">
      <!-- Bits 31:18 reserved. -->
      <field name="Mode" bit="17" size="1" desc="Read-write. Reset: 0. 0=One-shot. 1=Periodic." />
      <field name="Mask" bit="16" size="1" desc="Read-write. Reset: 1. 0=Not masked. 1=Masked." />
      <!-- Bits 15:13 reserved. -->
      <field name="DS" bit="12" size="1" desc="interrupt delivery status. Read-only,Volatile. Reset: 0. 0=Idle. 1=Send pending. (Indicates that the interrupt has not yet been accepted by the core.)" />
      <!-- Bit 11 reserved. -->
      <field name="MsgType" bit="8" size="3" desc="message type. Read-write. Reset: 0h. See2.1.11.2.1.14 [Generalized Local Vector Table]." />
      <field name="Vector" bit="0" size="8" desc="Read-write. Reset: 00h. Interrupt vector number." />
    </register>
    <register name="ThermalLvtEntry" type="mmio" bar="APIC" offset="0x330" size="4" desc="LVT Thermal Sensor. Reset: 0001_0000h.">
      <!-- Bits 31:17 reserved. -->
      <field name="Mask" bit="16" size="1" desc="Read-write. Reset: 1. 0=Not masked. 1=Masked." />
      <!-- Bits 15:13 reserved. -->
      <field name="DS" bit="12" size="1" desc="interrupt delivery status. Read-only,Volatile. Reset: 0. 0=Idle. 1=Send pending. (Indicates that the interrupt has not yet been accepted by the core.)" />
      <!-- Bit 11 reserved. -->
      <field name="MsgType" bit="8" size="3" desc="message type. Read-write. Reset: 0h. See2.1.11.2.1.14 [Generalized Local Vector Table]." />
      <field name="Vector" bit="0" size="8" desc="Read-write. Reset: 00h. Interrupt vector number." />
    </register>
    <register name="PerformanceCounterLvtEntry" type="mmio" bar="APIC" offset="0x340" size="4" desc="LVT Performance Monitor. Reset: 0001_0000h. Interrupts for this local vector table are caused by overflows of: • Core::X86::Msr::PERF_LEGACY_CTL(Performance Event Select [3:0]). • Core::X86::Msr::PERF_CTL(Performance Event Select [5:0]).">
      <!-- Bits 31:17 reserved. -->
      <field name="Mask" bit="16" size="1" desc="Read-write. Reset: 1. 0=Not masked. 1=Masked." />
      <!-- Bits 15:13 reserved. -->
      <field name="DS" bit="12" size="1" desc="interrupt delivery status. Read-only,Volatile. Reset: 0. 0=Idle. 1=Send pending. (Indicates that the interrupt has not yet been accepted by the core.)" />
      <!-- Bit 11 reserved. -->
      <field name="MsgType" bit="8" size="3" desc="message type. Read-write. Reset: 0h. See2.1.11.2.1.14 [Generalized Local Vector Table]." />
      <field name="Vector" bit="0" size="8" desc="Read-write. Reset: 00h. Interrupt vector number." />
    </register>

    <!-- page 60 -->

    <!-- TODO Multiple BAR instances, keeping only first one: APICx3[5...6]0 [LVT LINT[1:0]] (Core::X86::Apic::LVTLINT) -->
    <register name="LVTLINT" type="mmio" bar="APIC" offset="0x350" size="4" desc="LVT LINT[1:0]. Reset: 0001_0000h.">
      <!-- Bits 31:17 reserved. -->
      <field name="Mask" bit="16" size="1" desc="Read-write. Reset: 1. 0=Not masked. 1=Masked." />
      <field name="TM" bit="15" size="1" desc="trigger mode. Read-write. Reset: 0. 0=Edge. 1=Level." />
      <field name="RmtIRR" bit="14" size="1" desc="Read-only,Volatile. Reset: 0. If trigger mode is level, remote Core::X86::Apic::InterruptRequest is set when the interrupt has begun service. Remote Core::X86::Apic::InterruptRequest is cleared when the end of interrupt has occurred." />
      <!-- Bit 13 reserved. -->
      <field name="DS" bit="12" size="1" desc="interrupt delivery status. Read-only,Volatile. Reset: 0. 0=Idle. 1=Send pending. (Indicates that the interrupt has not yet been accepted by the core.)" />
      <!-- Bit 11 reserved. -->
      <field name="MsgType" bit="8" size="3" desc="message type. Read-write. Reset: 0h. See2.1.11.2.1.14 [Generalized Local Vector Table]." />
      <field name="Vector" bit="0" size="8" desc="Read-write. Reset: 00h. Interrupt vector number." />
    </register>
    <register name="ErrorLvtEntry" type="mmio" bar="APIC" offset="0x370" size="4" desc="LVT Error. Reset: 0001_0000h.">
      <!-- Bits 31:17 reserved. -->
      <field name="Mask" bit="16" size="1" desc="Read-write. Reset: 1. 0=Not masked. 1=Masked." />
      <!-- Bits 15:13 reserved. -->
      <field name="DS" bit="12" size="1" desc="interrupt delivery status. Read-only,Volatile. Reset: 0. 0=Idle. 1=Send pending. (Indicates that the interrupt has not yet been accepted by the core.)" />
      <!-- Bit 11 reserved. -->
      <field name="MsgType" bit="8" size="3" desc="message type. Read-write. Reset: 0h. See 2.1.11.2.1.14 [Generalized Local Vector Table]." />
      <field name="Vector" bit="0" size="8" desc="Read-write. Reset: 00h. Interrupt vector number." />
    </register>
    <register name="TimerInitialCount" type="mmio" bar="APIC" offset="0x380" size="4" desc="Timer Initial Count. Read-write,Volatile. Reset: 0000_0000h.">
      <field name="Count" bit="0" size="32" desc="Read-write,Volatile. Reset: 0000_0000h. The value copied into the current count register when the timer is loaded or reloaded." />
    </register>
    <register name="TimerCurrentCount" type="mmio" bar="APIC" offset="0x390" size="4" desc="Timer Current Count. Read-only,Volatile. Reset: 0000_0000h.">
      <field name="Count" bit="0" size="32" desc="Read-only,Volatile. Reset: 0000_0000h. The current value of the counter." />
    </register>
    <register name="TimerDivideConfiguration" type="mmio" bar="APIC" offset="0x3E0" size="4" desc="Timer Divide Configuration. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:4 reserved. -->
      <field name="Div[3:0]" bit="0" size="4" desc="Read-write. Reset: 0h. Div[2] is unused." />
    </register>

    <!-- page 61 -->

    <register name="ExtendedApicFeature" type="mmio" bar="APIC" offset="0x400" size="4" desc="Extended APIC Feature. Read-only. Reset: 0004_0007h.">
      <!-- Bits 31:24 reserved. -->
      <field name="ExtLvtCount" bit="16" size="8" desc="extended local vector table count. Read-only. Reset: 04h. This specifies the number of extended LVT registers (Core::X86::Apic::ExtendedInterruptLvtEntries) in the local APIC." />
      <!-- Bits 15:3 reserved. -->
      <field name="ExtApicIdCap" bit="2" size="1" desc="extended APIC ID capable. Read-only. Reset: 1. 1=The processor is capable of supporting an 8-bit APIC ID, as controlled by Core::X86::Apic::ExtendedApicControl[ExtApicIdEn]." />
      <field name="SeoiCap" bit="1" size="1" desc="specific end of interrupt capable. Read-only. Reset: 1. 1=The Core::X86::Apic::SpecificEndOfInterrupt is present." />
      <field name="IerCap" bit="0" size="1" desc="interrupt enable register capable. Read-only. Reset: 1. This bit indicates that the Core::X86::Apic::InterruptEnable are present. See2.1.11.2.1.8 [Interrupt Masking]." />
    </register>
    <register name="ExtendedApicControl" type="mmio" bar="APIC" offset="0x410" size="4" desc="Extended APIC Control. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:3 reserved. -->
      <field name="ExtApicIdEn" bit="2" size="1" desc="extended APIC ID enable. Read-write. Reset: 0. 1=Enable 8-bit APIC ID; Core::X86::Apic::ApicId[ApicId] supports an 8-bit value; an interrupt broadcast in physical destination mode requires that the IntDest[7:0] == 1111_1111b (instead of XXXX_1111b); a match in physical destination mode occurs when (IntDest[7:0] == ApicId[7:0]) instead of (IntDest[3:0] == ApicId[3:0])." />
      <field name="SeoiEn" bit="1" size="1" desc="Read-write. Reset: 0. 1=Enable SEOI generation when a Write to Core::X86::Apic::SpecificEndOfInterrupt is received." />
      <field name="IerEn" bit="0" size="1" desc="Read-write. Reset: 0. 1=Enable writes to the interrupt enable registers." />
    </register>
    <register name="SpecificEndOfInterrupt" type="mmio" bar="APIC" offset="0x420" size="4" desc="Specific End Of Interrupt. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:8 reserved. -->
      <field name="EoiVec" bit="0" size="8" desc="end of interrupt vector. Read-write. Reset: 00h. A Write to this field causes an end of interrupt cycle to be performed for the vector specified in this field. The behavior is undefined if no interrupt is pending for the specified interrupt vector." />
    </register>

    <!-- page 62 -->

    <!-- TODO Multiple BAR instances, keeping only first one: APICx4[8...F]0 [Interrupt Enable] (Core::X86::Apic::InterruptEnable) -->
    <register name="InterruptEnable" type="mmio" bar="APIC" offset="0x480" size="4" desc="Interrupt Enable. Read-write. Reset: FFFF_FFFFh.">
      <field name="InterruptEnableBits" bit="0" size="32" desc="Read-write. Reset: FFFF_FFFFh. The interrupt enable bits can be used to enable each of the 256 interrupts." />
    </register>

    <!-- TODO Multiple BAR instances, keeping only first one: APICx5[0...3]0 [Extended Interrupt Local Vector Table] (Core::X86::Apic::ExtendedInterruptLvtEntries) -->
    <register name="ExtendedInterruptLvtEntries" type="mmio" bar="APIC" offset="0x500" size="4" desc="Extended Interrupt Local Vector Table. Reset: 0001_0000h. Assignments conventions: • APIC500 provides a local vector table entry for IBS. • APIC510 provides a local vector table entry for error thresholding. See Core::X86::Msr::McaIntrCfg[ThresholdLvtOffset]. • APIC520 provides a local vector table entry for Deferred errors. See MCi_CONFIG[DeferredIntType].">
      <!-- Bits 31:17 reserved. -->
      <field name="Mask" bit="16" size="1" desc="Read-write. Reset: 1. 0=Not masked. 1=Masked." />
      <!-- Bits 15:13 reserved. -->
      <field name="DS" bit="12" size="1" desc="interrupt delivery status. Read-only,Volatile. Reset: 0. 0=Idle. 1=Send pending. (Indicates that the interrupt has not yet been accepted by the core.)" />
      <!-- Bit 11 reserved. -->
      <field name="MsgType" bit="8" size="3" desc="message type. Read-write. Reset: 0h. See2.1.11.2.1.14 [Generalized Local Vector Table]." />
      <field name="Vector" bit="0" size="8" desc="Read-write. Reset: 00h. Interrupt vector number." />
    </register>

    <!-- 2.1.12.1 CPUID Instruction Functions -->

    <register name="LargFuncNum" type="cpuid" eax="0x00000000" output="EAX" size="4" desc="Processor Vendor and Largest Standard Function Number. Read-only. Reset: Fixed,0000_000Dh.">
      <field name="LFuncStd" bit="0" size="32" desc="largest standard function. Read-only. Reset: Fixed,0000_000Dh. The largest CPUID standard function input value supported by the processor implementation." />
    </register>

    <!-- page 63 -->

    <register name="ProcVendEbx" type="cpuid" eax="0x00000000" output="EBX" size="4" desc="Processor Vendor (ASCII Bytes [3:0]). Read-only. Reset: Fixed,6874_7541h. Core::X86::Cpuid::ProcVendEbx and Core::X86::Cpuid::ProcVendExtEbx return the same value.">
      <field name="Vendor" bit="0" size="32" desc="Read-only. Reset: Fixed,6874_7541h. ASCII Bytes [3:0] (&quot;h t u A&quot;) of the string &quot;AuthenticAMD&quot;." />
    </register>
    <register name="ProcVendEcx" type="cpuid" eax="0x00000000" output="ECX" size="4" desc="Processor Vendor (ASCII Bytes [11:8]). Read-only. Reset: Fixed,444D_4163h. Core::X86::Cpuid::ProcVendEcx and Core::X86::Cpuid::ProcVendExtEcx return the same value.">
      <field name="Vendor" bit="0" size="32" desc="Read-only. Reset: Fixed,444D_4163h. ASCII Bytes [11:8] (&quot;D M A c&quot;) of the string &quot;AuthenticAMD&quot;." />
    </register>
    <register name="ProcVendEdx" type="cpuid" eax="0x00000000" output="EDX" size="4" desc="Processor Vendor (ASCII Bytes [7:4]). Read-only. Reset: Fixed,6974_6E65h. Core::X86::Cpuid::ProcVendEdx and Core::X86::Cpuid::ProcVendExtEdx return the same value.">
      <field name="Vendor" bit="0" size="32" desc="Read-only. Reset: Fixed,6974_6E65h. ASCII Bytes [7:4] (&quot;i t n e&quot;) of the string &quot;AuthenticAMD&quot;." />
    </register>
    <register name="FamModStep" type="cpuid" eax="0x00000001" output="EAX" size="4" desc="Family, Model, Stepping Identifiers. Read-only. Core::X86::Cpuid::FamModStep and Core::X86::Cpuid::FamModStepExt return the same value. Family: Is an 8-bit value and is defined as: Family[7:0]=({0000b,BaseFamily[3:0]}+ExtendedFamily[7:0]). • E.g., If BaseFamily[3:0] == Fh and ExtendedFamily[7:0] == 08h, then Family[7:0] = 17h. Model: Is an 8-bit value and is defined as: Model[7:0]={ExtendedModel[3:0],BaseModel[3:0]}. • E.g., If ExtendedModel[3:0] == 1h and BaseModel[3:0] == 8h, then Model[7:0] = 18h. • Model numbers vary with product. Model numbers are are assigned a letter, 0h = &quot;A&quot;, 1h = &quot;B&quot;, and so on. Model and Stepping form the Revision. E.g., B1.">
      <!-- Bits 31:28 reserved. -->
      <field name="ExtFamily" bit="20" size="8" desc="extended family. Read-only. Reset: 08h. See Family above." />
      <field name="ExtModel" bit="16" size="4" desc="extended model. Read-only. Reset: 1h. See Model above." />
      <!-- Bits 15:12 reserved. -->
      <field name="BaseFamily" bit="8" size="4" desc="Read-only. Reset: Fh. See Family description above." />
      <field name="BaseModel" bit="4" size="4" desc="Read-only. Reset: Xh. Model numbers vary with product." />
      <field name="Stepping" bit="0" size="4" desc="Read-only. Reset: 1h. Processor stepping (revision) for a specific model." />
    </register>
    <register name="FeatureIdEbx" type="cpuid" eax="0x00000001" output="EBX" size="4" desc="LocalApicId, LogicalProcessorCount, CLFlush. Read-only.">
      <field name="LocalApicId" bit="24" size="8" desc="Read-only. Reset: XXh. Initial local APIC physical ID." />
      <field name="LogicalProcessorCount" bit="16" size="8" desc="logical processor count. Read-only. Reset: Fixed,(Core::X86::Cpuid::SizeId[NC] + 1). Specifies the number of threads in the processor as Core::X86::Cpuid::SizeId[NC] + 1." />
      <field name="CLFlush" bit="8" size="8" desc="Read-only. Reset: Fixed,08h. CLFLUSH size in quadwords." />
      <!-- Bits 7:0 reserved. -->
    </register>

    <!-- page 64 -->

    <register name="FeatureIdEcx" type="cpuid" eax="0x00000001" output="ECX" size="4" desc="Feature Identifiers. Read-only. These values can be over-written by Core::X86::Msr::CPUID_Features.">
      <!-- Bit 31 reserved. -->
      <field name="RDRAND" bit="30" size="1" desc="Read-only. Reset: Fixed,1. RDRAND instruction support." />
      <field name="F16C" bit="29" size="1" desc="Read-only. Reset: Fixed,1. Half-precision convert instruction support." />
      <field name="AVX" bit="28" size="1" desc="Read-only. Reset: Fixed,1. AVX instruction support." />
      <field name="OSXSAVE" bit="27" size="1" desc="Read-only. Reset: X. 1=The OS has enabled support for XGETBV/XSETBV instructions to query processor extended states. OS enabled support for XGETBV/XSETBV." />
      <field name="XSAVE" bit="26" size="1" desc="Read-only. Reset: Fixed,1. 1=Support provided for the XSAVE, XRSTOR, XSETBV, and XGETBV instructions and the XFEATURE_ENABLED_MASK register. XSAVE (and related) instruction support." />
      <field name="AES" bit="25" size="1" desc="AES instruction support. Read-only. Reset: X. AES instruction support." />
      <!-- Bit 24 reserved. -->
      <field name="POPCNT" bit="23" size="1" desc="Read-only. Reset: Fixed,1. POPCNT instruction." />
      <field name="MOVBE" bit="22" size="1" desc="Read-only. Reset: Fixed,1. MOVBE instruction support." />
      <field name="X2APIC" bit="21" size="1" desc="Read-only. Reset: Fixed,0. x2APIC capability." />
      <field name="SSE42" bit="20" size="1" desc="Read-only. Reset: Fixed,1. SSE4.2 instruction support." />
      <field name="SSE41" bit="19" size="1" desc="Read-only. Reset: Fixed,1. SSE4.1 instruction support." />
      <!-- Bits 18:14 reserved. -->
      <field name="CMPXCHG16B" bit="13" size="1" desc="Read-only. Reset: Fixed,1. CMPXCHG16B instruction." />
      <field name="FMA" bit="12" size="1" desc="Read-only. Reset: Fixed,1. FMA instruction support." />
      <!-- Bits 11:10 reserved. -->
      <field name="SSSE3" bit="9" size="1" desc="Read-only. Reset: Fixed,1. Supplemental SSE3 extensions." />
      <!-- Bits 8:4 reserved. -->
      <field name="Monitor" bit="3" size="1" desc="Read-only. Reset: !Core::X86::Msr::HWCR[MonMwaitDis]. Monitor/Mwait instructions." />
      <!-- Bit 2 reserved. -->
      <field name="PCLMULQDQ" bit="1" size="1" desc="Read-only. Reset: X. PCLMULQDQ instruction support." />
      <field name="SSE3" bit="0" size="1" desc="Read-only. Reset: Fixed,1. SSE3 extensions." />
    </register>
    <register name="FeatureIdEdx" type="cpuid" eax="0x00000001" output="EDX" size="4" desc="Feature Identifiers. Read-only. These values can be over-written by Core::X86::Msr::CPUID_Features.">
      <!-- Bits 31:29 reserved. -->
      <field name="HTT" bit="28" size="1" desc="Read-only. Reset: Fixed,(Core::X86::Cpuid::SizeId[NC] != 0). 0=Single thread product (Core::X86::Cpuid::SizeId[NC] == 0). 1=Multi thread product (Core::X86::Cpuid::SizeId[NC] != 0). Hyper- threading technology." />
      <!-- Bit 27 reserved. -->
      <field name="SSE2" bit="26" size="1" desc="Read-only. Reset: Fixed,1. SSE2: SSE2 extensions." />
      <field name="SSE" bit="25" size="1" desc="Read-only. Reset: Fixed,1. SSE extensions." />
      <field name="FXSR" bit="24" size="1" desc="Read-only. Reset: Fixed,1. FXSAVE and FXRSTOR instructions." />
      <field name="MMX" bit="23" size="1" desc="Read-only. Reset: Fixed,1. MMX instructions" />
      <!-- Bits 22:20 reserved. -->
      <field name="CLFSH" bit="19" size="1" desc="Read-only. Reset: Fixed,1. CLFLUSH instruction." />
      <!-- Bit 18 reserved. -->
      <field name="PSE36" bit="17" size="1" desc="Read-only. Reset: Fixed,1. Page-size extensions." />
      <field name="PAT" bit="16" size="1" desc="Read-only. Reset: Fixed,1. Page attribute table." />
      <field name="CMOV" bit="15" size="1" desc="Read-only. Reset: Fixed,1. Conditional move instructions, CMOV, FCOMI, FCMOV." />
      <field name="MCA" bit="14" size="1" desc="Read-only. Reset: Fixed,1. Machine check architecture, MCG_CAP." />
      <field name="PGE" bit="13" size="1" desc="Read-only. Reset: Fixed,1. Page global extension, CR4.PGE." />
      <field name="MTRR" bit="12" size="1" desc="Read-only. Reset: Fixed,1. Memory-type range registers." />
      <field name="SysEnterSysExit" bit="11" size="1" desc="Read-only. Reset: Fixed,1. SYSENTER and SYSEXIT instructions." />
      <!-- Bit 10 reserved. -->
      <field name="APIC" bit="9" size="1" desc="advanced programmable interrupt controller (APIC) exists and is enabled. Read-only. Reset: X. Core::X86::Msr::APIC_BAR[ApicEn]." />
      <field name="CMPXCHG8B" bit="8" size="1" desc="Read-only. Reset: Fixed,1. CMPXCHG8B instruction." />
      <field name="MCE" bit="7" size="1" desc="Read-only. Reset: Fixed,1. Machine check exception, CR4.MCE." />
      <field name="PAE" bit="6" size="1" desc="Read-only. Reset: Fixed,1. Physical-address extensions (PAE)." />
      <field name="MSR" bit="5" size="1" desc="Read-only. Reset: Fixed,1. AMD model-specific registers (MSRs), with RDMSR and WRMSR instructions." />
      <field name="TSC" bit="4" size="1" desc="Read-only. Reset: Fixed,1. Time Stamp Counter, RDTSC/RDTSCP instructions, CR4.TSD." />
      <field name="PSE" bit="3" size="1" desc="Read-only. Reset: Fixed,1. Page-size extensions (4 MB pages)." />
      <field name="DE" bit="2" size="1" desc="Read-only. Reset: Fixed,1. Debugging extensions, IO breakpoints, CR4.DE." />
      <field name="VME" bit="1" size="1" desc="Read-only. Reset: Fixed,1. Virtual-mode enhancements." />
      <field name="FPU" bit="0" size="1" desc="Read-only. Reset: Fixed,1. x87 floating-point unit on-chip." />
    </register>

    <!-- page 65 -->

    <register name="MonMWaitEax" type="cpuid" eax="0x00000005" output="EAX" size="4" desc="Monitor/MWait. Read-only. Reset: Fixed,0000_0040h.">
      <!-- Bits 31:16 reserved. -->
      <field name="MonLineSizeMin" bit="0" size="16" desc="Read-only. Reset: Fixed,0040h. Smallest monitor-line size in bytes." />
    </register>
    <register name="MonMWaitEbx" type="cpuid" eax="0x00000005" output="EBX" size="4" desc="Monitor/MWait. Read-only. Reset: Fixed,0000_0040h.">
      <!-- Bits 31:16 reserved. -->
      <field name="MonLineSizeMax" bit="0" size="16" desc="Read-only. Reset: Fixed,0040h. Largest monitor-line size in bytes." />
    </register>
    <register name="MonMWaitEcx" type="cpuid" eax="0x00000005" output="ECX" size="4" desc="Monitor/MWait. Read-only. Reset: Fixed,0000_0003h.">
      <!-- Bits 31:2 reserved. -->
      <field name="IBE" bit="1" size="1" desc="Read-only. Reset: Fixed,1. Interrupt break-event." />
      <field name="EMX" bit="0" size="1" desc="Read-only. Reset: Fixed,1. Enumerate MONITOR/MWAIT extensions." />
    </register>
    <register name="MonMWaitEdx" type="cpuid" eax="0x00000005" output="EDX" size="4" desc="Monitor/MWait. Read-only. Reset: Fixed,0000_0011h.">
      <!-- Bits 31:8 reserved. -->
      <field name="MWaitC1SubStates" bit="4" size="4" desc="Read-only. Reset: Fixed,1h. Number of C1 sub-cstates supported by MWAIT." />
      <field name="MWaitC0SubStates" bit="0" size="4" desc="Read-only. Reset: Fixed,1h. Number of C0 sub-cstates supported by MWAIT." />
    </register>

    <!-- page 66 -->

    <register name="ThermalPwrMgmtEax" type="cpuid" eax="0x00000006" output="EAX" size="4" desc="Thermal and Power Management. Read-only. Reset: Fixed,0000_0004h.">
      <!-- Bits 31:3 reserved. -->
      <field name="ARAT" bit="2" size="1" desc="always running APIC timer. Read-only. Reset: Fixed,1. 1=Indicates support for APIC timer always running feature." />
      <!-- Bits 1:0 reserved. -->
    </register>
    <register name="ThermalPwrMgmtEbx" type="cpuid" eax="0x00000006" output="EBX" size="4" desc="Thermal and Power Management.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="ThermalPwrMgmtEcx" type="cpuid" eax="0x00000006" output="ECX" size="4" desc="Thermal and Power Management. Read-only. Reset: Fixed,0000_0001h. These values can be over-written by Core::X86::Msr::CPUID_PWR_THERM.">
      <!-- Bits 31:1 reserved. -->
      <field name="EffFreq" bit="0" size="1" desc="effective frequency interface. Read-only. Reset: Fixed,1. 1=Indicates presence of Core::X86::Msr::MPERF and Core::X86::Msr::APERF." />
    </register>
    <register name="ThermalPwrMgmtEdx" type="cpuid" eax="0x00000006" output="EDX" size="4" desc="Thermal and Power Management.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="StructExtFeatIdEax0" type="cpuid" eax="0x00000007" ecx="0x00" output="EAX" size="4" desc="Structured Extended Feature Identifiers. Read-only. Reset: Fixed,0000_0000h.">
      <field name="StructExtFeatIdMax" bit="0" size="32" desc="Read-only. Reset: Fixed,0000_0000h. The largest CPUID Fn0000_0007 sub-function supported by the processor implementation." />
    </register>
    <register name="StructExtFeatIdEbx0" type="cpuid" eax="0x00000007" ecx="0x00" output="EBX" size="4" desc="Structured Extended Feature Identifiers. Read-only. Reset: Fixed,209C_01A9h.">
      <!-- Bits 31:30 reserved. -->
      <field name="SHA" bit="29" size="1" desc="Read-only. Reset: Fixed,1. 1=SHA Extensions available." />
      <!-- Bits 28:24 reserved. -->
      <field name="CLFSHOPT" bit="23" size="1" desc="Read-only. Reset: Fixed,1. Optimized Cache Line Flush." />
      <!-- Bits 22:21 reserved. -->
      <field name="SMAP" bit="20" size="1" desc="Read-only. Reset: Fixed,1. Secure Mode Access Prevention is supported." />
      <field name="ADX" bit="19" size="1" desc="Read-only. Reset: Fixed,1. ADCX and ADOX are present." />
      <field name="RDSEED" bit="18" size="1" desc="Read-only. Reset: Fixed,1. RDSEED is present." />
      <!-- Bits 17:9 reserved. -->
      <field name="BMI2" bit="8" size="1" desc="Read-only. Reset: Fixed,1. Bit manipulation group 2 instruction support." />
      <field name="SMEP" bit="7" size="1" desc="Read-only. Reset: Fixed,1. Supervisor Mode Execution protection." />
      <!-- Bit 6 reserved. -->
      <field name="AVX2" bit="5" size="1" desc="Read-only. Reset: Fixed,1. AVX extension support." />
      <!-- Bit 4 reserved. -->
      <field name="BMI1" bit="3" size="1" desc="Read-only. Reset: Fixed,1. Bit manipulation group 1 instruction support." />
      <!-- Bits 2:1 reserved. -->
      <field name="FSGSBASE" bit="0" size="1" desc="Read-only. Reset: Fixed,1. FS and GS base read write instruction support." />
    </register>

    <!-- page 67 -->

    <register name="StructExtFeatIdEcx0" type="cpuid" eax="0x00000007" ecx="0x00" output="ECX" size="4" desc="Structured Extended Feature Identifier.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="StructExtFeatIdEdx0" type="cpuid" eax="0x00000007" ecx="0x00" output="EDX" size="4" desc="Structured Extended Feature Identifiers. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="ExtTopEnumEax" type="cpuid" eax="0x0000000B" output="EAX" size="4" desc="Extended Topology Enumeration. Read-only. Reset: Fixed,0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="ExtTopEnumEbx" type="cpuid" eax="0x0000000B" output="EBX" size="4" desc="Extended Topology Enumeration. Read-only. Reset: Fixed,0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="ExtTopEnumEcx" type="cpuid" eax="0x0000000B" output="ECX" size="4" desc="Extended Topology Enumeration. Read-only. Reset: Fixed,0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="ExtTopEnumEdx" type="cpuid" eax="0x0000000B" output="EDX" size="4" desc="Extended Topology Enumeration. Read-only.">
      <!-- Bits 31:8 reserved. -->
      <field name="ApicId" bit="0" size="8" desc="APIC ID. Read-only. Reset: XXh. APIC ID." />
    </register>

    <!-- page 68 -->

    <register name="ProcExtStateEnumEax00" type="cpuid" eax="0x0000000D" ecx="0x00" output="EAX" size="4" desc="Processor Extended State Enumeration. Read-only. Reset: Fixed,0000_0007h.">
      <field name="XFeatureSupportedMask[31:0]" bit="0" size="32" desc="Read-only. Reset: Fixed,0000_0007h. Each set bit indicates the corresponding bit in register XCR0[31:0] is settable." />
    </register>
    <register name="ProcExtStateEnumEbx00" type="cpuid" eax="0x0000000D" ecx="0x00" output="EBX" size="4" desc="Processor Extended State Enumeration. Read-only,Volatile.">
      <field name="XFeatureEnabledSizeMax" bit="0" size="32" desc="Read-only,Volatile. Reset: XXXX_XXXXh. Description: Size in bytes of an uncompacted XSAVE/XRSTOR area for all features enabled in the XCR0 register. IF (XCR0[AVX] == 1) Return EBX = 0000_0340h // legacy header + X87/SSE + AVX size ELSIF (XCR0[SSE] == 1) Return EBX=0000_0240h // legacy header + X87/SSE size ELSIF (XCR0[X87] == 1) Return EBX = 0000_0240h END" />
    </register>
    <register name="ProcExtStateEnumEcx00" type="cpuid" eax="0x0000000D" ecx="0x00" output="ECX" size="4" desc="Processor Extended State Enumeration. Read-only. Reset: Fixed,0000_0400h.">
      <field name="XFeatureSupportedSizeMax" bit="0" size="32" desc="Read-only. Reset: Fixed,0000_0400h. Size of legacy header + X87/SSE + AVX." />
    </register>
    <register name="ProcExtStateEnumEdx00" type="cpuid" eax="0x0000000D" ecx="0x00" output="EDX" size="4" desc="Processor Extended State Enumeration. Read-only. Reset: Fixed,0000_0000h.">
      <field name="XFeatureSupportedMask[63:32]" bit="0" size="32" desc="Read-only. Reset: Fixed,0000_0000h. Each set bit indicates the corresponding bit in register XCR0[63:32] is settable." />
    </register>
    <register name="ProcExtStateEnumEax01" type="cpuid" eax="0x0000000D" ecx="0x01" output="EAX" size="4" desc="Processor Extended State Enumeration. Read-only. Reset: Fixed,0000_000Fh.">
      <!-- Bits 31:4 reserved. -->
      <field name="XSAVES" bit="3" size="1" desc="Read-only. Reset: Fixed,1. XSAVES,XRSTORS, and XSS supported." />
      <field name="XGETBV" bit="2" size="1" desc="Read-only. Reset: Fixed,1. XGETBV with ECX = 1 supported." />
      <field name="XSAVEC" bit="1" size="1" desc="Read-only. Reset: Fixed,1. XSAVEC and compact XRSTOR supported." />
      <field name="XSAVEOPT" bit="0" size="1" desc="Read-only. Reset: Fixed,1. XSAVEOPT is available." />
    </register>

    <!-- page 69 -->

    <register name="ProcExtStateEnumEbx01" type="cpuid" eax="0x0000000D" ecx="0x01" output="EBX" size="4" desc="Processor Extended State Enumeration. Read-only,Volatile.">
      <field name="XFeatureEnabledSizeMax" bit="0" size="32" desc="Read-only,Volatile. Reset: XXXX_XXXXh. Value is 512 + ((XCR0[AVX]) ? 256 : 0)." />
    </register>
    <register name="ProcExtStateEnumEcx01" type="cpuid" eax="0x0000000D" ecx="0x01" output="ECX" size="4" desc="Processor Extended State Enumeration. Read-only. Reset: Fixed,0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="ProcExtStateEnumEdx01" type="cpuid" eax="0x0000000D" ecx="0x01" output="EDX" size="4" desc="Processor Extended State Enumeration. Read-only. Reset: Fixed,0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="ProcExtStateEnumEax02" type="cpuid" eax="0x0000000D" ecx="0x02" output="EAX" size="4" desc="Processor Extended State Enumeration. Read-only. Reset: Fixed,0000_0100h.">
      <field name="YmmSaveStateSize" bit="0" size="32" desc="Read-only. Reset: Fixed,0000_0100h. YMM save state byte size." />
    </register>

    <!-- page 70 -->

    <register name="ProcExtStateEnumEbx02" type="cpuid" eax="0x0000000D" ecx="0x02" output="EBX" size="4" desc="Processor Extended State Enumeration. Read-only. Reset: Fixed,0000_0240h.">
      <field name="YmmSaveStateOffset" bit="0" size="32" desc="Read-only. Reset: Fixed,0000_0240h. YMM save state byte offset." />
    </register>
    <register name="ProcExtStateEnumEcx02" type="cpuid" eax="0x0000000D" ecx="0x02" output="ECX" size="4" desc="Processor Extended State Enumeration. Read-only. Reset: Fixed,0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="ProcExtStateEnumEdx02" type="cpuid" eax="0x0000000D" ecx="0x02" output="EDX" size="4" desc="Processor Extended State Enumeration. Read-only. Reset: Fixed,0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="LargExtFuncNum" type="cpuid" eax="0x80000000" output="EAX" size="4" desc="Largest Extended Function Number. Read-only. Reset: Fixed,8000_001Fh.">
      <field name="LFuncExt" bit="0" size="32" desc="largest extended function. Read-only. Reset: Fixed,8000_001Fh. The largest CPUID extended function input value supported by the processor implementation." />
    </register>
    <register name="ProcVendExtEbx" type="cpuid" eax="0x80000000" output="EBX" size="4" desc="Processor Vendor (ASCII Bytes [3:0]). Read-only. Reset: Fixed,6874_7541h. Core::X86::Cpuid::ProcVendEbx and Core::X86::Cpuid::ProcVendExtEbx return the same value.">
      <field name="Vendor" bit="0" size="32" desc="Read-only. Reset: Fixed,6874_7541h. ASCII Bytes [3:0] (&quot;h t u A&quot;) of the string &quot;AuthenticAMD&quot;." />
    </register>
    <register name="ProcVendExtEcx" type="cpuid" eax="0x80000000" output="ECX" size="4" desc="Processor Vendor (ASCII Bytes [11:8]). Read-only. Reset: Fixed,444D_4163h. Core::X86::Cpuid::ProcVendEcx and Core::X86::Cpuid::ProcVendExtEcx return the same value.">
      <field name="Vendor" bit="0" size="32" desc="Read-only. Reset: Fixed,444D_4163h. ASCII Bytes [11:8] (&quot;D M A c&quot;) of the string &quot;AuthenticAMD&quot;." />
    </register>
    <register name="ProcVendExtEdx" type="cpuid" eax="0x80000000" output="EDX" size="4" desc="Processor Vendor (ASCII Bytes [7:4]). Read-only. Reset: Fixed,6974_6E65h. Core::X86::Cpuid::ProcVendEdx and Core::X86::Cpuid::ProcVendExtEdx return the same value.">
      <field name="Vendor" bit="0" size="32" desc="Read-only. Reset: Fixed,6974_6E65h. ASCII Bytes [7:4] (&quot;i t n e&quot;) of the string &quot;AuthenticAMD&quot;." />
    </register>
    <register name="FamModStepExt" type="cpuid" eax="0x80000001" output="EAX" size="4" desc="Family, Model, Stepping Identifiers. Read-only. Core::X86::Cpuid::FamModStep and Core::X86::Cpuid::FamModStepExt return the same value. See Core::X86::Cpuid::FamModStep.">
      <!-- Bits 31:28 reserved. -->
      <field name="ExtFamily" bit="20" size="8" desc="extended family. Read-only. Reset: 08h. See Core::X86::Cpuid::FamModStep description of Family." />
      <field name="ExtModel" bit="16" size="4" desc="extended model. Read-only. Reset: 1h. See Core::X86::Cpuid::FamModStep description of ExtModel." />
      <!-- Bits 15:12 reserved. -->
      <field name="BaseFamily" bit="8" size="4" desc="Read-only. Reset: Fh. See Core::X86::Cpuid::FamModStep description of Family." />
      <field name="BaseModel" bit="4" size="4" desc="Read-only. Reset: Xh. Model numbers vary with product." />
      <field name="Stepping" bit="0" size="4" desc="Read-only. Reset: 1h. Processor stepping (revision) for a specific model." />
    </register>

    <!-- page 71 -->

    <register name="BrandId" type="cpuid" eax="0x80000001" output="EBX" size="4" desc="BrandId Identifier. Read-only.">
      <field name="PkgType" bit="28" size="4" desc="package type. Read-only. Reset: Xh. Specifies the package type." />
      <!-- Bits 27:0 reserved. -->
    </register>
    <register name="FeatureExtIdEcx" type="cpuid" eax="0x80000001" output="ECX" size="4" desc="Feature Identifiers. Read-only. These values can be over-written by Core::X86::Msr::CPUID_ExtFeatures.">
      <!-- Bits 31:30 reserved. -->
      <field name="MwaitExtended" bit="29" size="1" desc="Read-only. Reset: !Core::X86::Msr::HWCR[MonMwaitDis]. 1=MWAITX and MONITORX capability is supported." />
      <field name="PerfCtrExtLLC" bit="28" size="1" desc="Last Level Cache performance counter extensions. Read-only. Reset: Fixed,1. 1=Indicates support for Core::X86::Msr::ChL3PmcCfg and Core::X86::Msr::ChL3Pmc L3 performance counter extensions. L3 performance counter extensions support. See 2.1.14.4 [L3 Cache Performance Monitor Counters] and 2.1.14 [Performance Monitor Counters]." />
      <field name="PerfTsc" bit="27" size="1" desc="Read-only. Reset: Fixed,0. Performance time-stamp counter supported." />
      <field name="DataBreakpointExtension" bit="26" size="1" desc="Read-only. Reset: Fixed,1. 1=Indicates data breakpoint support for Core::X86::Msr::DR0_ADDR_MASK, Core::X86::Msr::DR1_ADDR_MASK, Core::X86::Msr::DR2_ADDR_MASK and Core::X86::Msr::DR3_ADDR_MASK." />
      <!-- Bit 25 reserved. -->
      <field name="PerfCtrExtDF" bit="24" size="1" desc="data fabric performance counter extensions support. Read-only. Reset: Fixed,1. 1=Indicates support for Core::X86::Msr::DF_PERF_CTL and Core::X86::Msr::DF_PERF_CTR." />
      <field name="PerfCtrExtCore" bit="23" size="1" desc="core performance counter extensions support. Read-only. Reset: Fixed,1. 1=Indicates support for Core::X86::Msr::PERF_CTL and Core::X86::Msr::PERF_CTR. See See 2.1.14.3 [Core Performance Monitor Counters] and 2.1.14 [Performance Monitor Counters]." />
      <field name="TopologyExtensions" bit="22" size="1" desc="topology extensions support. Read-only. Reset: Fixed,1. 1=Indicates support for Core::X86::Cpuid::CachePropEax0 and Core::X86::Cpuid::ExtApicId." />
      <!-- Bits 21:18 reserved. -->
      <field name="TCE" bit="17" size="1" desc="Read-only. Reset: Fixed,1. Translation cache extension." />
      <field name="FMA4" bit="16" size="1" desc="Read-only. Reset: Fixed,0. Four-operand FMA instruction support." />
      <field name="LWP" bit="15" size="1" desc="Read-only. Reset: Fixed,0. Lightweight profiling support." />
      <!-- Bit 14 reserved. -->
      <field name="WDT" bit="13" size="1" desc="Read-only. Reset: Fixed,1. Watchdog timer support." />
      <field name="SKINIT" bit="12" size="1" desc="Read-only. Reset: Fixed,1. SKINIT and STGI support." />
      <field name="XOP" bit="11" size="1" desc="Read-only. Reset: Fixed,0. Extended operation support." />
      <field name="IBS" bit="10" size="1" desc="Read-only. Reset: 0. Instruction Based Sampling." />
      <field name="OSVW" bit="9" size="1" desc="Read-only. Reset: Fixed,1. OS Visible Work-around support." />
      <field name="ThreeDNowPrefetch" bit="8" size="1" desc="Read-only. Reset: Fixed,1. Prefetch and PrefetchW instructions." />
      <field name="MisAlignSse" bit="7" size="1" desc="Read-only. Reset: Fixed,1. Misaligned SSE Mode." />
      <field name="SSE4A" bit="6" size="1" desc="Read-only. Reset: Fixed,1. EXTRQ, INSERTQ, MOVNTSS, and MOVNTSD instruction support." />
      <field name="ABM" bit="5" size="1" desc="advanced bit manipulation. Read-only. Reset: Fixed,1. LZCNT instruction support." />
      <field name="AltMovCr8" bit="4" size="1" desc="Read-only. Reset: Fixed,1. LOCK MOV CR0 means MOV CR8." />
      <field name="ExtApicSpace" bit="3" size="1" desc="Read-only. Reset: Fixed,1. Extended APIC register space." />
      <field name="SVM" bit="2" size="1" desc="Secure Virtual Mode feature. Read-only. Reset: Fixed,1. Indicates support for: VMRUN, VMLOAD, VMSAVE, CLGI, VMMCALL, and INVLPGA." />
      <field name="CmpLegacy" bit="1" size="1" desc="Read-only. Reset: Fixed,(Core::X86::Cpuid::SizeId[NC] > 0). 0=Single core product (Core::X86::Cpuid::SizeId[NC] == 0). 1=Multi core product (Core::X86::Cpuid::SizeId[NC] !=0 ). Core multi- processing legacy mode." />
      <field name="LahfSahf" bit="0" size="1" desc="Read-only. Reset: Fixed,1. LAHF and SAHF instruction support in 64-bit mode." />
    </register>

    <!-- page 72 -->

    <register name="FeatureExtIdEdx" type="cpuid" eax="0x80000001" output="EDX" size="4" desc="Feature Identifiers. Read-only. These values can be over-written by Core::X86::Msr::CPUID_ExtFeatures.">
      <field name="ThreeDNow" bit="31" size="1" desc="Read-only. Reset: Fixed,0. 3DNow! instructions." />
      <field name="ThreeDNowExt" bit="30" size="1" desc="Read-only. Reset: Fixed,0. AMD extensions to 3DNow! instructions." />
      <field name="LM" bit="29" size="1" desc="Read-only. Reset: Fixed,1. Long Mode." />
      <!-- Bit 28 reserved. -->
      <field name="RDTSCP" bit="27" size="1" desc="Read-only. Reset: Fixed,1. RDTSCP instruction." />
      <field name="Page1GB" bit="26" size="1" desc="Read-only. Reset: Fixed,1. 1-GB large page support." />
      <field name="FFXSR" bit="25" size="1" desc="Read-only. Reset: Fixed,1. FXSAVE and FXRSTOR instruction optimizations." />
      <field name="FXSR" bit="24" size="1" desc="Read-only. Reset: Fixed,1. FXSAVE and FXRSTOR instructions." />
      <field name="MMX" bit="23" size="1" desc="Read-only. Reset: Fixed,1. MMX instructions." />
      <field name="MmxExt" bit="22" size="1" desc="Read-only. Reset: Fixed,1. AMD extensions to MMX instructions." />
      <!-- Bit 21 reserved. -->
      <field name="NX" bit="20" size="1" desc="Read-only. Reset: Fixed,1. No-execute page protection." />
      <!-- Bits 19:18 reserved. -->
      <field name="PSE36" bit="17" size="1" desc="Read-only. Reset: Fixed,1. Page-size extensions." />
      <field name="PAT" bit="16" size="1" desc="Read-only. Reset: Fixed,1. Page attribute table." />
      <field name="CMOV" bit="15" size="1" desc="Read-only. Reset: Fixed,1. Conditional move instructions, CMOV, FCOMI, FCMOV." />
      <field name="MCA" bit="14" size="1" desc="Read-only. Reset: Fixed,1. Machine check architecture, MCG_CAP." />
      <field name="PGE" bit="13" size="1" desc="Read-only. Reset: Fixed,1. Page global extension, CR4.PGE." />
      <field name="MTRR" bit="12" size="1" desc="Read-only. Reset: Fixed,1. Memory-type range registers." />
      <field name="SysCallSysRet" bit="11" size="1" desc="Read-only. Reset: Fixed,1. SYSCALL and SYSRET instructions." />
      <!-- Bit 10 reserved. -->
      <field name="APIC" bit="9" size="1" desc="advanced programmable interrupt controller (APIC) exists and is enabled. Read-only. Reset: X. Reset is Core::X86::Msr::APIC_BAR[ApicEn]." />
      <field name="CMPXCHG8B" bit="8" size="1" desc="Read-only. Reset: Fixed,1. CMPXCHG8B instruction." />
      <field name="MCE" bit="7" size="1" desc="Read-only. Reset: Fixed,1. Machine Check Exception, CR4.MCE." />
      <field name="PAE" bit="6" size="1" desc="Read-only. Reset: Fixed,1. Physical-address extensions (PAE)." />
      <field name="MSR" bit="5" size="1" desc="Read-only. Reset: Fixed,1. Model-specific registers (MSRs), with RDMSR and WRMSR instructions." />
      <field name="TSC" bit="4" size="1" desc="Read-only. Reset: Fixed,1. Time stamp counter, RDTSC/RDTSCP instructions, CR4.TSD." />
      <field name="PSE" bit="3" size="1" desc="Read-only. Reset: Fixed,1. Page-size extensions (4 MB pages)." />
      <field name="DE" bit="2" size="1" desc="Read-only. Reset: Fixed,1. Debugging extensions, IO breakpoints, CR4.DE." />
      <field name="VME" bit="1" size="1" desc="Read-only. Reset: Fixed,1. Virtual-mode enhancements." />
      <field name="FPU" bit="0" size="1" desc="Read-only. Reset: Fixed,1. x87 floating-point unit on-chip." />
    </register>

    <!-- page 73 -->

    <register name="ProcNameStr0Eax" type="cpuid" eax="0x80000002" output="EAX" size="4" desc="Processor Name String Identifier (Bytes [3:0]). Read-only. Is an alias of Core::X86::Msr::ProcNameString_n0.">
      <field name="ProcNameByte3" bit="24" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n0[CpuNameString3]. Processor name, byte3." />
      <field name="ProcNameByte2" bit="16" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n0[CpuNameString2]. Processor name, byte2." />
      <field name="ProcNameByte1" bit="8" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n0[CpuNameString1]. Processor name, byte1." />
      <field name="ProcNameByte0" bit="0" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n0[CpuNameString0]. Processor name, byte0." />
    </register>
    <register name="ProcNameStr0Ebx" type="cpuid" eax="0x80000002" output="EBX" size="4" desc="Processor Name String Identifier (Bytes [7:4]). Read-only. Is an alias of Core::X86::Msr::ProcNameString_n0.">
      <field name="ProcNameByte7" bit="24" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n0[CpuNameString7]. Processor name, byte 7." />
      <field name="ProcNameByte6" bit="16" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n0[CpuNameString6]. Processor name, byte 6." />
      <field name="ProcNameByte5" bit="8" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n0[CpuNameString5]. Processor name, byte 5." />
      <field name="ProcNameByte4" bit="0" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n0[CpuNameString4]. Processor name, byte 4." />
    </register>
    <register name="ProcNameStr0Ecx" type="cpuid" eax="0x80000002" output="ECX" size="4" desc="Processor Name String Identifier (Bytes [11:8]). Read-only. Is an alias of Core::X86::Msr::ProcNameString_n1.">
      <field name="ProcNameByte11" bit="24" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n1[CpuNameString3]. Processor name, byte 11." />
      <field name="ProcNameByte10" bit="16" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n1[CpuNameString2]. Processor name, byte 10." />
      <field name="ProcNameByte9" bit="8" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n1[CpuNameString1]. Processor name, byte 9." />
      <field name="ProcNameByte8" bit="0" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n1[CpuNameString0]. Processor name, byte 8." />
    </register>

    <!-- page 74 -->

    <register name="ProcNameStr0Edx" type="cpuid" eax="0x80000002" output="EDX" size="4" desc="Processor Name String Identifier (Bytes [15:12]). Read-only. Is an alias of Core::X86::Msr::ProcNameString_n1.">
      <field name="ProcNameByte15" bit="24" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n1[CpuNameString7]. Processor name, byte 15." />
      <field name="ProcNameByte14" bit="16" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n1[CpuNameString6]. Processor name, byte 14." />
      <field name="ProcNameByte13" bit="8" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n1[CpuNameString5]. Processor name, byte 13." />
      <field name="ProcNameByte12" bit="0" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n1[CpuNameString4]. Processor name, byte 12." />
    </register>
    <register name="ProcNameStr1Eax" type="cpuid" eax="0x80000003" output="EAX" size="4" desc="Processor Name String Identifier (Bytes [19:16]). Read-only. Is an alias of Core::X86::Msr::ProcNameString_n2.">
      <field name="ProcNameByte19" bit="24" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n2[CpuNameString3]. Processor name, byte 19." />
      <field name="ProcNameByte18" bit="16" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n2[CpuNameString2]. Processor name, byte 18." />
      <field name="ProcNameByte17" bit="8" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n2[CpuNameString1]. Processor name, byte 17." />
      <field name="ProcNameByte16" bit="0" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n2[CpuNameString0]. Processor name, byte 16." />
    </register>
    <register name="ProcNameStr1Ebx" type="cpuid" eax="0x80000003" output="EBX" size="4" desc="Processor Name String Identifier (Bytes [23:20]). Read-only. Is an alias of Core::X86::Msr::ProcNameString_n2.">
      <field name="ProcNameByte23" bit="24" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n2[CpuNameString7]. Processor name, byte 23." />
      <field name="ProcNameByte22" bit="16" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n2[CpuNameString6]. Processor name, byte 22." />
      <field name="ProcNameByte21" bit="8" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n2[CpuNameString5]. Processor name, byte 21." />
      <field name="ProcNameByte20" bit="0" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n2[CpuNameString4]. Processor name, byte 20." />
    </register>
    <register name="ProcNameStr1Ecx" type="cpuid" eax="0x80000003" output="ECX" size="4" desc="Processor Name String Identifier (Bytes [27:24]). Read-only. Is an alias of Core::X86::Msr::ProcNameString_n3.">
      <field name="ProcNameByte27" bit="24" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n3[CpuNameString3]. Processor name, byte 27." />
      <field name="ProcNameByte26" bit="16" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n3[CpuNameString2]. Processor name, byte 26." />
      <field name="ProcNameByte25" bit="8" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n3[CpuNameString1]. Processor name,   byte 25." />
      <field name="ProcNameByte24" bit="0" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n3[CpuNameString0]. Processor name, byte 24." />
    </register>

    <!-- page 75 -->

    <register name="ProcNameStr1Edx" type="cpuid" eax="0x80000003" output="EDX" size="4" desc="Processor Name String Identifier (Bytes [31:28]). Read-only. Is an alias of Core::X86::Msr::ProcNameString_n3.">
      <field name="ProcNameByte31" bit="24" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n3[CpuNameString7]. Processor name, byte 31." />
      <field name="ProcNameByte30" bit="16" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n3[CpuNameString6]. Processor name, byte 30." />
      <field name="ProcNameByte29" bit="8" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n3[CpuNameString5]. Processor name, byte 29." />
      <field name="ProcNameByte28" bit="0" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n3[CpuNameString4]. Processor name, byte 28." />
    </register>
    <register name="ProcNameStr2Eax" type="cpuid" eax="0x80000004" output="EAX" size="4" desc="Processor Name String Identifier (Bytes [35:32]). Read-only. Is an alias of Core::X86::Msr::ProcNameString_n4.">
      <field name="ProcNameByte35" bit="24" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n4[CpuNameString3]. Processor name, byte 35." />
      <field name="ProcNameByte34" bit="16" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n4[CpuNameString2]. Processor name, byte 34." />
      <field name="ProcNameByte33" bit="8" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n4[CpuNameString1]. Processor name, byte 33." />
      <field name="ProcNameByte32" bit="0" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n4[CpuNameString0]. Processor name, byte 32." />
    </register>
    <register name="ProcNameStr2Ebx" type="cpuid" eax="0x80000004" output="EBX" size="4" desc="Processor Name String Identifier (Bytes [39:36]). Read-only. Is an alias of Core::X86::Msr::ProcNameString_n4.">
      <field name="ProcNameByte39" bit="24" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n4[CpuNameString7]. Processor name, byte 39." />
      <field name="ProcNameByte38" bit="16" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n4[CpuNameString6]. Processor name, byte 38." />
      <field name="ProcNameByte37" bit="8" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n4[CpuNameString5]. Processor name, byte 37." />
      <field name="ProcNameByte36" bit="0" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n4[CpuNameString4]. Processor name, byte 36." />
    </register>

    <!-- page 76 -->

    <register name="ProcNameStr2Ecx" type="cpuid" eax="0x80000004" output="ECX" size="4" desc="Processor Name String Identifier (Bytes [43:40]). Read-only. Is an alias of Core::X86::Msr::ProcNameString_n5.">
      <field name="ProcNameByte43" bit="24" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n5[CpuNameString3]. Processor name, byte 43." />
      <field name="ProcNameByte42" bit="16" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n5[CpuNameString2]. Processor name, byte 42." />
      <field name="ProcNameByte41" bit="8" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n5[CpuNameString1]. Processor name, byte 41." />
      <field name="ProcNameByte40" bit="0" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n5[CpuNameString0]. Processor name, byte 40." />
    </register>
    <register name="ProcNameStr2Edx" type="cpuid" eax="0x80000004" output="EDX" size="4" desc="Processor Name String Identifier (Bytes [47:44]). Read-only. Is an alias of Core::X86::Msr::ProcNameString_n5.">
      <field name="ProcNameByte47" bit="24" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n5[CpuNameString7]. Processor name, byte 47." />
      <field name="ProcNameByte46" bit="16" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n5[CpuNameString6]. Processor name, byte 46." />
      <field name="ProcNameByte45" bit="8" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n5[CpuNameString5]. Processor name, byte 45." />
      <field name="ProcNameByte44" bit="0" size="8" desc="Read-only. Reset: Core::X86::Msr::ProcNameString_n5[CpuNameString4]. Processor name, byte 44." />
    </register>
    <register name="L1Tlb2M4M" type="cpuid" eax="0x80000005" output="EAX" size="4" desc="L1 TLB 2M/4M Identifiers. Read-only. This function provides the processor's first level cache and TLB characteristics for each core.">
      <field name="L1DTlb2and4MAssoc" bit="24" size="8" desc="data TLB associativity for 2-MB and 4-MB pages. Read-only. Reset: Fixed,FFh. See Core::X86::Cpuid::L1DcId[L1DcAssoc]." />
      <field name="L1DTlb2and4MSize" bit="16" size="8" desc="data TLB number of entries for 2-MB and 4 MB-pages. Read-only. Reset: Fixed,64. The value returned is for the number of entries available for the 2-MB page size; 4-MB pages require two 2-MB entries, so the number of entries available for the 4-MB page size is one-half the returned value." />
      <field name="L1ITlb2and4MAssoc" bit="8" size="8" desc="instruction TLB associativity for 2-MB and 4 MB-pages. Read-only. Reset: Fixed,FFh. See Core::X86::Cpuid::L1DcId[L1DcAssoc]." />
      <field name="L1ITlb2and4MSize" bit="0" size="8" desc="instruction TLB number of entries for 2-MB and 4-MB pages. Read-only. Reset: Fixed,64. The value returned is for the number of entries available for the 2-MB page size; 4-MB pages require two 2-MB entries, so the number of entries available for the 4-MB page size is one-half the returned value." />
    </register>
    <register name="L1Tlb4K" type="cpuid" eax="0x80000005" output="EBX" size="4" desc="L1 TLB 4K Identifiers. Read-only. See Core::X86::Cpuid::L1Tlb2M4M.">
      <field name="L1DTlb4KAssoc" bit="24" size="8" desc="Read-only. Reset: Fixed,FFh. Data TLB associativity for 4-KB pages. See Core::X86::Cpuid::L1DcId[L1DcAssoc]." />
      <field name="L1DTlb4KSize" bit="16" size="8" desc="Read-only. Reset: Fixed,64. Data TLB number of entries for 4-KB pages." />
      <field name="L1ITlb4KAssoc" bit="8" size="8" desc="Read-only. Reset: Fixed,FFh. Instruction TLB associativity for 4-KB pages. See   Core::X86::Cpuid::L1DcId[L1DcAssoc]." />
      <field name="L1ITlb4KSize" bit="0" size="8" desc="Read-only. Reset: Fixed,64. Instruction TLB number of entries for 4-KB pages." />
    </register>

    <!-- page 77 -->

    <register name="L1DcId" type="cpuid" eax="0x80000005" output="ECX" size="4" desc="L1 Data Cache Identifiers. Read-only. This function provides first level cache characteristics for each core.">
      <field name="L1DcSize" bit="24" size="8" desc="Read-only. Reset: Fixed,32. L1 data cache size in KB." />
      <field name="L1DcAssoc" bit="16" size="8" desc="Read-only. Reset: Fixed,8. L1 data cache associativity." />
      <field name="L1DcLinesPerTag" bit="8" size="8" desc="Read-only. Reset: Fixed,01h. L1 data cache lines per tag." />
      <field name="L1DcLineSize" bit="0" size="8" desc="Read-only. Reset: Fixed,64. L1 data cache line size in bytes." />
    </register>
    <register name="L1IcId" type="cpuid" eax="0x80000005" output="EDX" size="4" desc="L1 Instruction Cache Identifiers. Read-only. This function provides first level cache characteristics for each core.">
      <field name="L1IcSize" bit="24" size="8" desc="Read-only. Reset: Fixed,64. L1 instruction cache size KB." />
      <field name="L1IcAssoc" bit="16" size="8" desc="Read-only. Reset: Fixed,4. L1 instruction cache associativity." />
      <field name="L1IcLinesPerTag" bit="8" size="8" desc="Read-only. Reset: Fixed,01h. L1 instruction cache lines per tag." />
      <field name="L1IcLineSize" bit="0" size="8" desc="Read-only. Reset: Fixed,64. L1 instruction cache line size in bytes." />
    </register>

    <!-- page 78 -->

    <register name="L2Tlb2M4M" type="cpuid" eax="0x80000006" output="EAX" size="4" desc="L2 TLB 2M/4M Identifiers. Read-only. This function provides the processor's second level cache and TLB characteristics for each core.">
      <field name="L2DTlb2and4MAssoc" bit="28" size="4" desc="L2 data TLB associativity for 2-MB and 4-MB pages. Read-only. Reset: Xh." />
      <field name="L2DTlb2and4MSize" bit="16" size="12" desc="L2 data TLB number of entries for 2-MB and 4-MB pages. Read-only. Reset: Fixed,1536. The value returned is for the number of entries available for the 2-MB page size; 4-MB pages require two 2-MB entries, so the number of entries available for the 4-MB page size is one-half the returned value." />
      <field name="L2ITlb2and4MAssoc" bit="12" size="4" desc="L2 instruction TLB associativity for 2-MB and 4-MB pages. Read-only. Reset: Fixed,6." />
      <field name="L2ITlb2and4MSize" bit="0" size="12" desc="L2 instruction TLB number of entries for 2-MB and 4-MB pages. Read-only. Reset: Fixed,1024. The value returned is for the number of entries available for the 2-MB page size; 4-MB pages require two 2-MB entries, so the number of entries available for the 4-MB page size is one-half the returned value." />
    </register>
    <register name="L2Tlb4K" type="cpuid" eax="0x80000006" output="EBX" size="4" desc="L2 TLB 4K Identifiers. Read-only. This function provides the processor's second level cache and TLB characteristics for each core.">
      <field name="L2DTlb4KAssoc" bit="28" size="4" desc="Read-only. Reset: Xh. L2 data TLB associativity for 4-KB pages." />
      <field name="L2DTlb4KSize" bit="16" size="12" desc="Read-only. Reset: Fixed,1536. L2 data TLB number of entries for 4-KB pages." />
      <field name="L2ITlb4KAssoc" bit="12" size="4" desc="Read-only. Reset: Fixed,6. L2 instruction TLB associativity for 4-KB pages." />
      <field name="L2ITlb4KSize" bit="0" size="12" desc="Read-only. Reset: Fixed,1024. L2 instruction TLB number of entries for 4-KB pages." />
    </register>

    <!-- page 79 -->

    <register name="L2CacheId" type="cpuid" eax="0x80000006" output="ECX" size="4" desc="L2 Cache Identifiers. Read-only. This function provides second level cache characteristics for each core.">
      <field name="L2Size" bit="16" size="16" desc="Read-only. Reset: Fixed,0200h. L2 cache size in KB." />
      <field name="L2Assoc" bit="12" size="4" desc="Read-only. Reset: Fixed,6. L2 cache associativity." />
      <field name="L2LinesPerTag" bit="8" size="4" desc="Read-only. Reset: Fixed,1h. L2 cache lines per tag." />
      <field name="L2LineSize" bit="0" size="8" desc="Read-only. Reset: Fixed,64. L2 cache line size in bytes." />
    </register>
    <register name="L3CacheId" type="cpuid" eax="0x80000006" output="EDX" size="4" desc="L3 Cache Identifiers. Read-only. This function provides third level cache characteristics shared by all cores of a processor.">
      <field name="L3Size" bit="18" size="14" desc="L3 cache size. Read-only. Reset: XXXXh. The L3 cache size in 512 KB units." />
      <!-- Bits 17:16 reserved. -->
      <field name="L3Assoc" bit="12" size="4" desc="Read-only. Reset: Xh. L3 cache associativity." />
      <field name="L3LinesPerTag" bit="8" size="4" desc="Read-only. Reset: Fixed,1h. L3 cache lines per tag." />
      <field name="L3LineSize" bit="0" size="8" desc="Read-only. Reset: Fixed,64. L3 cache line size in bytes." />
    </register>

    <!-- page 80 -->

    <register name="ProcFeedbackCap" type="cpuid" eax="0x80000007" output="EAX" size="4" desc="Reserved. Read-only. Reset: Fixed,0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="RasCap" type="cpuid" eax="0x80000007" output="EBX" size="4" desc="RAS Capabilities. Read-only.">
      <!-- Bits 31:4 reserved. -->
      <field name="ScalableMca" bit="3" size="1" desc="Read-only. Reset: Fixed,1. 0=Scalable MCA is not supported. 1=Scalable MCA is supported. See 3.1.1.2 [Machine Check Architecture Extensions] and MCA_CONFIG[McaX] for the respective bank." />
      <field name="HWA" bit="2" size="1" desc="Read-only. Reset: Fixed,0. Hardware assert supported." />
      <field name="SUCCOR" bit="1" size="1" desc="Software uncorrectable error containment and recovery capability. Read-only. Reset: X. The processor supports software containment of uncorrectable errors through context synchronizing data poisoning and deferred error interrupts; MSR Core::X86::Msr::McaIntrCfg, MCA_STATUS[Deferred] and MCA_STATUS[Poison] exist." />
      <field name="McaOverflowRecov" bit="0" size="1" desc="MCA overflow recovery support. Read-only. Reset: Fixed,1. 0=MCA overflow conditions require software to shutdown the system. 1=MCA overflow conditions (MCi_STATUS[Overflow] == 1) are not fatal; software may safely ignore such conditions. See 3.1 [Machine Check Architecture]." />
    </register>
    <register name="ApmInfoEcx" type="cpuid" eax="0x80000007" output="ECX" size="4" desc="Advanced Power Management Information. Read-only. Reset: Fixed,0000_0000h.">
      <field name="CpuPwrSampleTimeRatio" bit="0" size="32" desc="Read-only. Reset: Fixed,0000_0000h. Specifies the ratio of the compute unit power accumulator sample period to the TSC counter period." />
    </register>
    <register name="ApmInfoEdx" type="cpuid" eax="0x80000007" output="EDX" size="4" desc="Advanced Power Management Information. Read-only. This function provides advanced power management feature identifiers.">
      <!-- Bits 31:15 reserved. -->
      <field name="RAPL" bit="14" size="1" desc="Read-only. Reset: Fixed,1. Running average power limit." />
      <field name="ConnectedStandby" bit="13" size="1" desc="Read-only. Reset: Fixed,1. Connected Standby." />
      <field name="ProcPowerReporting" bit="12" size="1" desc="Read-only. Reset: Fixed,0. Core power reporting interface supported." />
      <field name="ProcFeedbackInterface" bit="11" size="1" desc="processor feedback interface. Read-only. Reset: Fixed,0. 1=Indicates support for processor feedback interface; Core::X86::Cpuid::ProcFeedbackCap." />
      <field name="EffFreqRO" bit="10" size="1" desc="read-only effective frequency interface. Read-only. Reset: Fixed,1. Indicates presence of Core::X86::Msr::MPerfReadOnly and Core::X86::Msr::APerfReadOnly." />
      <field name="CPB" bit="9" size="1" desc="core performance boost. Read-only. Reset: X. 1=Indicates presence of Core::X86::Msr::HWCR[CpbDis] and support for core performance boost." />
      <field name="TscInvariant" bit="8" size="1" desc="TSC invariant. Read-only. Reset: Fixed,1. The TSC rate is invariant." />
      <field name="HwPstate" bit="7" size="1" desc="hardware P-state control. Read-only. Reset: Fixed,1. Core::X86::Msr::PStateCurLim, Core::X86::Msr::PStateCtl and Core::X86::Msr::PStateStat exist." />
      <field name="OneHundredMHzSteps" bit="6" size="1" desc="Read-only. Reset: Fixed,0. 100 MHz multiplier Control." />
      <!-- Bit 5 reserved. -->
      <field name="TM" bit="4" size="1" desc="Read-only. Reset: Fixed,1. Hardware thermal control (HTC)." />
      <field name="TTP" bit="3" size="1" desc="Read-only. Reset: Fixed,1. THERMTRIP." />
      <field name="VID" bit="2" size="1" desc="Voltage ID control. Read-only. Reset: Fixed,0. Function replaced by HwPstate." />
      <field name="FID" bit="1" size="1" desc="Frequency ID control. Read-only. Reset: Fixed,0. Function replaced by HwPstate." />
      <field name="TS" bit="0" size="1" desc="Read-only. Reset: Fixed,1. Temperature sensor." />
    </register>

    <!-- page 81 -->

    <register name="LongModeInfo" type="cpuid" eax="0x80000008" output="EAX" size="4" desc="Long Mode Address Size Identifiers. Read-only. Reset: Fixed,0000_3030h. This provides information about the maximum physical and linear address width supported by the processor.">
      <!-- Bits 31:24 reserved. -->
      <field name="GuestPhysAddrSize" bit="16" size="8" desc="Read-only. Reset: Fixed,00h. Maximum guest physical byte address size in bits." />
      <field name="LinAddrSize" bit="8" size="8" desc="Read-only. Reset: Fixed,30h. Maximum linear byte address size in bits." />
      <field name="PhysAddrSize" bit="0" size="8" desc="Read-only. Reset: Fixed,30h. Maximum physical byte address size in bits." />
    </register>
    <register name="FeatureExtIdEbx" type="cpuid" eax="0x80000008" output="EBX" size="4" desc="Extended Feature Extensions ID EBX. Read-only. Reset: Fixed,0000_0007h.">
      <!-- Bits 31:3 reserved. -->
      <field name="RstrFpErrPtrs" bit="2" size="1" desc="Read-only. Reset: Fixed,1. 1=FXSAVE, XSAVE, FXSAVEOPT, XSAVEC, XSAVES always save error pointers and FXRSTOR, XRSTOR, XRSTORS always restore error pointers is supported." />
      <field name="InstRetCntMsr" bit="1" size="1" desc="instructions retired count support. Read-only. Reset: Fixed,1. 1=Core::X86::Msr::IRPerfCount supported." />
      <field name="CLZERO" bit="0" size="1" desc="Clear Zero Instruction. Read-only. Reset: Fixed,1. CLZERO instruction zero's out the 64-byte cache line specified in RAX. Note: CLZERO instruction operations are cache-line aligned and RAX[5:0] is ignored." />
    </register>
    <register name="SizeId" type="cpuid" eax="0x80000008" output="ECX" size="4" desc="Size Identifiers. Read-only. This provides information about the number of threads supported by the processor.">
      <!-- Bits 31:18 reserved. -->
      <field name="PerfTscSize" bit="16" size="2" desc="performance time-stamp counter size. Read-only. Reset: Fixed,0h." />
      <field name="ApicIdSize" bit="12" size="4" desc="APIC ID size. Read-only. Reset: Xh. The number of bits in the initial Core::X86::Apic::ApicId[ApicId] value that indicate thread ID within a package." />
      <!-- Bits 11:8 reserved. -->
      <field name="NC" bit="0" size="8" desc="number of threads - 1. Read-only. Reset: XXh. The number of threads in the package is NC + 1 (e.g., if NC == 0, then there is one thread)." />
    </register>

    <!-- page 82 -->

    <register name="SvmRevFeatIdEax" type="cpuid" eax="0x8000000A" output="EAX" size="4" desc="SVM Revision and Feature Identification. Read-only. Reset: Fixed,0000_0001h. Enable: Core::X86::Cpuid::FeatureExtIdEcx[SVM].">
      <!-- Bits 31:8 reserved. -->
      <field name="SvmRev" bit="0" size="8" desc="Read-only. Reset: Fixed,01h. SVM revision." />
    </register>
    <register name="SvmRevFeatIdEbx" type="cpuid" eax="0x8000000A" output="EBX" size="4" desc="SVM Revision and Feature Identification. Read-only,Volatile. Reset: 0000_8000h. Enable: Core::X86::Cpuid::FeatureExtIdEcx[SVM]. This provides SVM revision and feature information.">
      <field name="NASID" bit="0" size="32" desc="number of address space identifiers (ASID). Read-only,Volatile. Reset: 0000_8000h." />
    </register>
    <register name="SvmRevFeatIdEdx" type="cpuid" eax="0x8000000A" output="EDX" size="4" desc="SVM Revision and Feature Identification. Read-only. Reset: Fixed,0001_B4FFh. Enable: Core::X86::Cpuid::FeatureExtIdEcx[SVM]. This provides SVM feature information.">
      <!-- Bits 31:17 reserved. -->
      <field name="vGIF" bit="16" size="1" desc="Read-only. Reset: Fixed,1. Virtualized GIF." />
      <field name="V_VMSAVE_VMLOAD" bit="15" size="1" desc="Read-only. Reset: Fixed,1. Virtualized VMLOAD and VMSAVE." />
      <!-- Bit 14 reserved. -->
      <field name="AVIC" bit="13" size="1" desc="AMD virtual interrupt controller. Read-only. Reset: Fixed,1. 1=Support indicated for SVM mode virtualized interrupt controller; Indicates support for Core::X86::Msr::AvicDoorbell." />
      <field name="PauseFilterThreshold" bit="12" size="1" desc="Read-only. Reset: Fixed,1. PAUSE filter threshold." />
      <!-- Bit 11 reserved. -->
      <field name="PauseFilter" bit="10" size="1" desc="Read-only. Reset: Fixed,1. Pause intercept filter." />
      <!-- Bits 9:8 reserved. -->
      <field name="DecodeAssists" bit="7" size="1" desc="Read-only. Reset: Fixed,1. Decode assists." />
      <field name="FlushByAsid" bit="6" size="1" desc="Read-only. Reset: Fixed,1. Flush by ASID." />
      <field name="VmcbClean" bit="5" size="1" desc="Read-only. Reset: Fixed,1. VMCB clean bits." />
      <field name="TscRateMsr" bit="4" size="1" desc="MSR based TSC rate control. Read-only. Reset: Fixed,1. 1=Indicates support for TSC ratio Core::X86::Msr::TscRateMsr." />
      <field name="NRIPS" bit="3" size="1" desc="Read-only. Reset: Fixed,1. NRIP Save." />
      <field name="SVML" bit="2" size="1" desc="Read-only. Reset: Fixed,1. SVM lock." />
      <field name="LbrVirt" bit="1" size="1" desc="Read-only. Reset: Fixed,1. LBR virtualization." />
      <field name="NP" bit="0" size="1" desc="Read-only. Reset: Fixed,1. Nested Paging." />
    </register>
    <register name="L1Tlb1G" type="cpuid" eax="0x80000019" output="EAX" size="4" desc="L1 TLB 1G Identifiers. Read-only. This function provides first level TLB characteristics for 1-GB pages.">
      <field name="L1DTlb1GAssoc" bit="28" size="4" desc="L1 data TLB associativity for 1-GB pages. Read-only. Reset: Fixed,Fh. See Core::X86::Cpuid::L2CacheId[L2Assoc]." />
      <field name="L1DTlb1GSize" bit="16" size="12" desc="Read-only. Reset: Fixed,64. L1 data TLB number of entries for 1-GB pages." />
      <field name="L1ITlb1GAssoc" bit="12" size="4" desc="Read-only. Reset: Fixed,Fh. L1 instruction TLB associativity for 1-GB pages. See Core::X86::Cpuid::L2CacheId[L2Assoc]." />
      <field name="L1ITlb1GSize" bit="0" size="12" desc="Read-only. Reset: Fixed,64. L1 instruction TLB number of entries for 1-GB pages." />
    </register>

    <!-- page 83 -->

    <register name="L2Tlb1G" type="cpuid" eax="0x80000019" output="EBX" size="4" desc="L2 TLB 1G Identifiers. Read-only. Reset: Fixed,0000_0000h. This provides 1-GB paging information. The associativity fields are defined by Core::X86::Cpuid::L2Tlb2M4M, Core::X86::Cpuid::L2Tlb4K, Core::X86::Cpuid::L2CacheId and Core::X86::Cpuid::L3CacheId.">
      <field name="L2DTlb1GAssoc" bit="28" size="4" desc="Read-only. Reset: Fixed,0h. L2 data TLB associativity for 1-GB pages. See Core::X86::Cpuid::L2CacheId[L2Assoc]." />
      <field name="L2DTlb1GSize" bit="16" size="12" desc="Read-only. Reset: Fixed,000h. L2 data TLB number of entries for 1-GB pages." />
      <field name="L2ITlb1GAssoc" bit="12" size="4" desc="Read-only. Reset: Fixed,0h. L2 instruction TLB associativity for 1-GB pages. See Core::X86::Cpuid::L2CacheId[L2Assoc]." />
      <field name="L2ITlb1GSize" bit="0" size="12" desc="Read-only. Reset: Fixed,000h. L2 instruction TLB number of entries for 1-GB pages." />
    </register>
    <register name="PerfOptId" type="cpuid" eax="0x8000001A" output="EAX" size="4" desc="Performance Optimization Identifiers. Read-only. Reset: Fixed,0000_0003h. This function returns performance related information.">
      <!-- Bits 31:3 reserved. -->
      <field name="FP256" bit="2" size="1" desc="Read-only. Reset: Fixed,0. 256-bit AVX instructions are executed with full-width internal operations and pipelines rather than decomposing them into internal 128-bit suboperations." />
      <field name="MOVU" bit="1" size="1" desc="Read-only. Reset: Fixed,1. MOVU SSE instructions are more efficient and should be preferred to SSE MOVL/MOVH. MOVUPS is more efficient than MOVLPS/MOVHPS. MOVUPD is more efficient than MOVLPD/MOVHPD." />
      <field name="FP128" bit="0" size="1" desc="Read-only. Reset: Fixed,1. 128-bit SSE (multimedia) instructions are executed with full-width internal operations and pipelines rather than decomposing them into internal 64-bit suboperations." />
    </register>
    <register name="IbsIdEax" type="cpuid" eax="0x8000001B" output="EAX" size="4" desc="Instruction Based Sampling Identifiers. Read-only. Reset: Fixed,0000_03FFh. This function returns IBS feature information.">
      <!-- Bits 31:11 reserved. -->
      <field name="IbsOpData4" bit="10" size="1" desc="Read-only. Reset: Fixed,0. IBS op data 4 MSR supported." />
      <field name="IbsFetchCtlExtd" bit="9" size="1" desc="IBS fetch control extended MSR supported. Read-only. Reset: Fixed,1. Indicates support for Core::X86::Msr::IC_IBS_EXTD_CTL." />
      <field name="OpBrnFuse" bit="8" size="1" desc="fused branch op indication supported. Read-only. Reset: Fixed,1. Indicates support for Core::X86::Msr::IBS_OP_DATA[IbsOpBrnFuse]." />
      <field name="RipInvalidChk" bit="7" size="1" desc="invalid RIP indication supported. Read-only. Reset: Fixed,1. Indicates support for Core::X86::Msr::IBS_OP_DATA[IbsRipInvalid]." />
      <field name="OpCntExt" bit="6" size="1" desc="IbsOpCurCnt and IbsOpMaxCnt extend by 7 bits. Read-only. Reset: Fixed,1. Indicates support for Core::X86::Msr::IBS_OP_CTL[IbsOpCurCnt[26:20],IbsOpMaxCnt[26:20]]." />
      <field name="BrnTrgt" bit="5" size="1" desc="Read-only. Reset: Fixed,1. Branch target address reporting supported." />
      <field name="OpCnt" bit="4" size="1" desc="Read-only. Reset: Fixed,1. Op counting mode supported." />
      <field name="RdWrOpCnt" bit="3" size="1" desc="Read-only. Reset: Fixed,1. Read/Write of op counter supported." />
      <field name="OpSam" bit="2" size="1" desc="Read-only. Reset: Fixed,1. IBS execution sampling supported." />
      <field name="FetchSam" bit="1" size="1" desc="Read-only. Reset: Fixed,1. IBS fetch sampling supported." />
      <field name="IBSFFV" bit="0" size="1" desc="Read-only. Reset: Fixed,1. IBS feature flags valid." />
    </register>

    <!-- page 84 -->

    <register name="CachePropEax0" type="cpuid" eax="0x8000001D" ecx="0x00" output="EAX" size="4" desc="Cache Properties (DC). Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. Core::X86::Cpuid::CachePropEax0 reports topology information for the DC.">
      <!-- Bits 31:26 reserved. -->
      <field name="NumSharingCache" bit="14" size="12" desc="number of logical processors sharing cache. Read-only. Reset: XXXh. The number of logical processors sharing this cache is NumSharingCache + 1." />
      <!-- Bits 13:10 reserved. -->
      <field name="FullyAssociative" bit="9" size="1" desc="fully associative cache. Read-only. Reset: Fixed,0. 1=Cache is fully associative." />
      <field name="SelfInitialization" bit="8" size="1" desc="cache is self-initializing. Read-only. Reset: Fixed,1. 1=Cache is self initializing; cache does not need software initialization." />
      <field name="CacheLevel" bit="5" size="3" desc="cache level. Read-only. Reset: Fixed,1h. Identifies the cache level." />
      <field name="CacheType" bit="0" size="5" desc="cache type. Read-only. Reset: Fixed,01h. Identifies the type of cache." />
    </register>
    <register name="CachePropEax1" type="cpuid" eax="0x8000001D" ecx="0x01" output="EAX" size="4" desc="Cache Properties (IC). Read-only. Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. Core::X86::Cpuid::CachePropEax1 reports topology information for the IC. See Core::X86::Cpuid::CachePropEax0.">
      <!-- Bits 31:26 reserved. -->
      <field name="NumSharingCache" bit="14" size="12" desc="number of logical processors sharing cache. Read-only. Reset: XXXh. See Core::X86::Cpuid::CachePropEax0[NumSharingCache]." />
      <!-- Bits 13:10 reserved. -->
      <field name="FullyAssociative" bit="9" size="1" desc="fully associative cache. Read-only. Reset: Fixed,0. See Core::X86::Cpuid::CachePropEax0[FullyAssociative]." />
      <field name="SelfInitialization" bit="8" size="1" desc="cache is self-initializing. Read-only. Reset: Fixed,1. See Core::X86::Cpuid::CachePropEax0[SelfInitialization]." />
      <field name="CacheLevel" bit="5" size="3" desc="cache level. Read-only. Reset: Fixed,1h. Identifies the cache level. See Core::X86::Cpuid::CachePropEax0[CacheLevel]." />
      <field name="CacheType" bit="0" size="5" desc="cache type. Read-only. Reset: Fixed,02h. See Core::X86::Cpuid::CachePropEax0[CacheType]." />
    </register>

    <!-- page 85 -->

    <register name="CachePropEax2" type="cpuid" eax="0x8000001D" ecx="0x02" output="EAX" size="4" desc="Cache Properties (L2). Read-only. Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. Core::X86::Cpuid::CachePropEax2 reports topology information for the L2. See Core::X86::Cpuid::CachePropEax0.">
      <!-- Bits 31:26 reserved. -->
      <field name="NumSharingCache" bit="14" size="12" desc="number of logical processors sharing cache. Read-only. Reset: XXXh. Core::X86::Cpuid::CachePropEax0[NumSharingCache]." />
      <!-- Bits 13:10 reserved. -->
      <field name="FullyAssociative" bit="9" size="1" desc="fully associative cache. Read-only. Reset: Fixed,0. Core::X86::Cpuid::CachePropEax0[FullyAssociative]." />
      <field name="SelfInitialization" bit="8" size="1" desc="cache is self-initializing. Read-only. Reset: Fixed,1. Core::X86::Cpuid::CachePropEax0[SelfInitialization]." />
      <field name="CacheLevel" bit="5" size="3" desc="cache level. Read-only. Reset: Fixed,2h. Identifies the cache level. Core::X86::Cpuid::CachePropEax0[CacheLevel]." />
      <field name="CacheType" bit="0" size="5" desc="cache type. Read-only. Reset: Fixed,03h. Core::X86::Cpuid::CachePropEax0[CacheType]." />
    </register>
    <register name="CachePropEax3" type="cpuid" eax="0x8000001D" ecx="0x03" output="EAX" size="4" desc="Cache Properties (L3). Read-only. Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. Core::X86::Cpuid::CachePropEax3 reports topology information for the L3.">
      <!-- Bits 31:26 reserved. -->
      <field name="NumSharingCache" bit="14" size="12" desc="number of logical processors sharing cache. Read-only. Reset: XXXh. The number of logical processors sharing this cache is NumSharingCache + 1." />
      <!-- Bits 13:10 reserved. -->
      <field name="FullyAssociative" bit="9" size="1" desc="fully associative cache. Read-only. Reset: Fixed,0. Core::X86::Cpuid::CachePropEax0[FullyAssociative]." />
      <field name="SelfInitialization" bit="8" size="1" desc="cache is self-initializing. Read-only. Reset: Fixed,1. Core::X86::Cpuid::CachePropEax0[SelfInitialization]." />
      <field name="CacheLevel" bit="5" size="3" desc="cache level. Read-only. Reset: Fixed,3h. Identifies the cache level. Core::X86::Cpuid::CachePropEax0[CacheLevel]." />
      <field name="CacheType" bit="0" size="5" desc="cache type. Read-only. Reset: Fixed,03h. Core::X86::Cpuid::CachePropEax0[CacheType]." />
    </register>
    <register name="CachePropEax4" type="cpuid" eax="0x8000001D" ecx="0x04" output="EAX" size="4" desc="Cache Properties Null. Read-only. Reset: Fixed,0000_0000h. Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. Core::X86::Cpuid::CachePropEax4 reports done/null. See Core::X86::Cpuid::CachePropEax0.">
      <!-- Bits 31:5 reserved. -->
      <field name="CacheType" bit="0" size="5" desc="cache type. Read-only. Reset: Fixed,00h. Core::X86::Cpuid::CachePropEax0[CacheType]." />
    </register>
    <register name="CachePropEbx0" type="cpuid" eax="0x8000001D" ecx="0x00" output="EBX" size="4" desc="Cache Properties (DC). Read-only. Reset: Fixed,01C0_003Fh. Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. Core::X86::Cpuid::CachePropEbx0 reports topology information for the DC. See Core::X86::Cpuid::CachePropEax0.">
      <field name="CacheNumWays" bit="22" size="10" desc="cache number of ways. Read-only. Reset: Fixed,007h. Cache number of ways is CacheNumWays + 1." />
      <field name="CachePhysPartitions" bit="12" size="10" desc="cache physical line partitions. Read-only. Reset: Fixed,000h. Cache partitions is CachePhysPartitions + 1." />
      <field name="CacheLineSize" bit="0" size="12" desc="cache line size in bytes. Read-only. Reset: Fixed,03Fh. Cache line size in bytes is CacheLineSize + 1." />
    </register>

    <!-- page 86 -->

    <register name="CachePropEbx1" type="cpuid" eax="0x8000001D" ecx="0x01" output="EBX" size="4" desc="Cache Properties (IC). Read-only. Reset: Fixed,00C0_003Fh. Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. Core::X86::Cpuid::CachePropEbx1 reports topology information for the IC. See Core::X86::Cpuid::CachePropEax0.">
      <field name="CacheNumWays" bit="22" size="10" desc="cache number of ways. Read-only. Reset: Fixed,003h. Core::X86::Cpuid::CachePropEbx0[CacheNumWays]." />
      <field name="CachePhysPartitions" bit="12" size="10" desc="cache physical line partitions. Read-only. Reset: Fixed,000h. Core::X86::Cpuid::CachePropEbx0[CachePhysPartitions]." />
      <field name="CacheLineSize" bit="0" size="12" desc="cache line size in bytes. Read-only. Reset: Fixed,03Fh. Core::X86::Cpuid::CachePropEbx0[CacheLineSize]." />
    </register>
    <register name="CachePropEbx2" type="cpuid" eax="0x8000001D" ecx="0x02" output="EBX" size="4" desc="Cache Properties (L2). Read-only. Reset: Fixed,01C0_003Fh. Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. Core::X86::Cpuid::CachePropEbx2 reports topology information for the L2. See Core::X86::Cpuid::CachePropEax0.">
      <field name="CacheNumWays" bit="22" size="10" desc="cache number of ways. Read-only. Reset: Fixed,007h. See Core::X86::Cpuid::CachePropEbx0[CacheNumWays]." />
      <field name="CachePhysPartitions" bit="12" size="10" desc="cache physical line partitions. Read-only. Reset: Fixed,000h. See Core::X86::Cpuid::CachePropEbx0[CachePhysPartitions]." />
      <field name="CacheLineSize" bit="0" size="12" desc="cache line size in bytes. Read-only. Reset: Fixed,03Fh. See Core::X86::Cpuid::CachePropEbx0[CacheLineSize]." />
    </register>
    <register name="CachePropEbx3" type="cpuid" eax="0x8000001D" ecx="0x03" output="EBX" size="4" desc="Cache Properties (L3). Read-only. Reset: Fixed,03C0_003Fh. Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. Core::X86::Cpuid::CachePropEbx3 reports topology information for the L3. See Core::X86::Cpuid::CachePropEax0.">
      <field name="CacheNumWays" bit="22" size="10" desc="cache number of ways. Read-only. Reset: Fixed,00Fh. See Core::X86::Cpuid::CachePropEbx0[CacheNumWays]." />
      <field name="CachePhysPartitions" bit="12" size="10" desc="cache physical line partitions. Read-only. Reset: Fixed,000h. See Core::X86::Cpuid::CachePropEbx0[CachePhysPartitions]." />
      <field name="CacheLineSize" bit="0" size="12" desc="cache line size in bytes. Read-only. Reset: Fixed,03Fh. See Core::X86::Cpuid::CachePropEbx0[CacheLineSize]." />
    </register>
    <register name="CachePropEbx4" type="cpuid" eax="0x8000001D" ecx="0x04" output="EBX" size="4" desc="Cache Properties Null. Read-only. Reset: Fixed,0000_0000h. Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. Core::X86::Cpuid::CachePropEax4 reports done/null. See Core::X86::Cpuid::CachePropEax0.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="CachePropEcx0" type="cpuid" eax="0x8000001D" ecx="0x00" output="ECX" size="4" desc="Cache Properties (DC). Read-only. Reset: Fixed,0000_003Fh. Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. Core::X86::Cpuid::CachePropEcx0 reports topology information for the DC. See Core::X86::Cpuid::CachePropEax0.">
      <field name="CacheNumSets" bit="0" size="32" desc="cache number of sets. Read-only. Reset: Fixed,0000_003Fh. Cache number of sets is CacheNumSets + 1." />
    </register>

    <!-- page 87 -->

    <register name="CachePropEcx1" type="cpuid" eax="0x8000001D" ecx="0x01" output="ECX" size="4" desc="Cache Properties (IC). Read-only. Reset: Fixed,0000_00FFh. Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. Core::X86::Cpuid::CachePropEcx1 reports topology information for the IC. See Core::X86::Cpuid::CachePropEax0.">
      <field name="CacheNumSets" bit="0" size="32" desc="cache number of sets. Read-only. Reset: Fixed,0000_00FFh. See Core::X86::Cpuid::CachePropEcx0[CacheNumSets]." />
    </register>
    <register name="CachePropEcx2" type="cpuid" eax="0x8000001D" ecx="0x02" output="ECX" size="4" desc="Cache Properties (L2). Read-only. Reset: Fixed,0000_03FFh. Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. Core::X86::Cpuid::CachePropEcx2 reports topology information for the L2. See Core::X86::Cpuid::CachePropEax0.">
      <field name="CacheNumSets" bit="0" size="32" desc="cache number of sets. Read-only. Reset: Fixed,0000_03FFh. See Core::X86::Cpuid::CachePropEcx0[CacheNumSets]." />
    </register>
    <register name="CachePropEcx3" type="cpuid" eax="0x8000001D" ecx="0x03" output="ECX" size="4" desc="Cache Properties (L3). Read-only. Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. Core::X86::Cpuid::CachePropEcx3 reports topology information for the L3.">
      <field name="CacheNumSets" bit="0" size="32" desc="cache number of sets. Read-only. Reset: 0000_XXXXh. See Core::X86::Cpuid::CachePropEcx0[CacheNumSets]." />
    </register>
    <register name="CachePropEcx4" type="cpuid" eax="0x8000001D" ecx="0x04" output="ECX" size="4" desc="Cache Properties Null. Read-only. Reset: Fixed,0000_0000h. Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. Core::X86::Cpuid::CachePropEax3 reports done/null. See Core::X86::Cpuid::CachePropEax0.">
      <field name="CacheNumSets" bit="0" size="32" desc="Read-only. Reset: Fixed,0000_0000h. Cache number of sets." />
    </register>
    <register name="CachePropEdx0" type="cpuid" eax="0x8000001D" ecx="0x00" output="EDX" size="4" desc="Cache Properties (DC). Read-only. Reset: Fixed,0000_0000h. Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. Core::X86::Cpuid::CachePropEdx0 reports topology information for the DC. See Core::X86::Cpuid::CachePropEax0.">
      <!-- Bits 31:2 reserved. -->
      <field name="CacheInclusive" bit="1" size="1" desc="cache inclusive. Read-only. Reset: Fixed,0. 0=Cache is not inclusive of lower cache levels. 1=Cache is inclusive of lower cache levels." />
      <field name="WBINVD" bit="0" size="1" desc="Write-Back Invalidate/Invalidate. Read-only. Reset: Fixed,0. 0=WBINVD/INVD invalidates all lower level caches of non-originating cores sharing this cache. 1=WBINVD/INVD not ensured to invalidate all   lower level caches of non-originating cores sharing this cache." />
    </register>

    <!-- page 88 -->

    <register name="CachePropEdx1" type="cpuid" eax="0x8000001D" ecx="0x01" output="EDX" size="4" desc="Cache Properties (IC). Read-only. Reset: Fixed,0000_0000h. Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. Core::X86::Cpuid::CachePropEdx1 reports topology information for the IC. See Core::X86::Cpuid::CachePropEax0.">
      <!-- Bits 31:2 reserved. -->
      <field name="CacheInclusive" bit="1" size="1" desc="cache inclusive. Read-only. Reset: Fixed,0. See Core::X86::Cpuid::CachePropEdx0[CacheInclusive]." />
      <field name="WBINVD" bit="0" size="1" desc="Write-Back Invalidate/Invalidate. Read-only. Reset: Fixed,0. 0=WBINVD/INVD invalidates all lower level caches of non-originating cores sharing this cache. 1=WBINVD/INVD may not invalidate all lower level caches of non-originating cores sharing this cache. See Core::X86::Cpuid::CachePropEdx0[WBINVD]." />
    </register>
    <register name="CachePropEdx2" type="cpuid" eax="0x8000001D" ecx="0x02" output="EDX" size="4" desc="Cache Properties (L2). Read-only. Reset: Fixed,0000_0002h. Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. Core::X86::Cpuid::CachePropEdx2 reports topology information for the L2. See Core::X86::Cpuid::CachePropEax0.">
      <!-- Bits 31:2 reserved. -->
      <field name="CacheInclusive" bit="1" size="1" desc="cache inclusive. Read-only. Reset: Fixed,1. See Core::X86::Cpuid::CachePropEdx0[CacheInclusive]." />
      <field name="WBINVD" bit="0" size="1" desc="Write-Back Invalidate/Invalidate. Read-only. Reset: Fixed,0. 0=WBINVD/INVD invalidates all lower level caches of non-originating cores sharing this cache. 1=WBINVD/INVD may not invalidate all lower level caches of non-originating cores sharing this cache." />
    </register>
    <register name="CachePropEdx3" type="cpuid" eax="0x8000001D" ecx="0x03" output="EDX" size="4" desc="Cache Properties (L3). Read-only. Reset: Fixed,0000_0001h. Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. Core::X86::Cpuid::CachePropEdx3 reports reports topology information for the L3. See Core::X86::Cpuid::CachePropEax0.">
      <!-- Bits 31:2 reserved. -->
      <field name="CacheInclusive" bit="1" size="1" desc="cache inclusive. Read-only. Reset: Fixed,0. See Core::X86::Cpuid::CachePropEdx0[CacheInclusive]." />
      <field name="WBINVD" bit="0" size="1" desc="Write-Back Invalidate/Invalidate. Read-only. Reset: Fixed,1. 0=WBINVD/INVD invalidates all lower level caches of non-originating cores sharing this cache. 1=WBINVD/INVD may not invalidate all lower level caches of non-originating cores sharing this cache." />
    </register>
    <register name="CachePropEdx4" type="cpuid" eax="0x8000001D" ecx="0x04" output="EDX" size="4" desc="Cache Properties Null. Read-only. Reset: Fixed,0000_0000h. Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. Core::X86::Cpuid::CachePropEax3 reports done/null. See Core::X86::Cpuid::CachePropEax0.">
      <!-- Bits 31:0 reserved. -->
    </register>

    <!-- page 89 -->

    <register name="ExtApicId" type="cpuid" eax="0x8000001E" output="EAX" size="4" desc="Extended APIC ID. Read-only. Enable: (Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions] &amp;&amp; Core::X86::Msr::APIC_BAR[ApicEn]). If Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions] == 0 then CPUID Fn8000001E_E[D,C,B,A]X are Reserved. If (Core::X86::Msr::APIC_BAR[ApicEn] == 0) then Core::X86::Cpuid::ExtApicId[ExtendedApicId] is Reserved.">
      <field name="ExtendedApicId" bit="0" size="32" desc="extended APIC ID. Read-only. See 2.1.11.2.1.3 [ApicId Enumeration Requirements]. Reset: Core::X86::Msr::APIC_BAR[ApicEn] ? Fixed,{00_0000h , Core::X86::Apic::ApicId[ApicId]} : Fixed,0000_0000h." />
    </register>
    <register name="CoreId" type="cpuid" eax="0x8000001E" output="EBX" size="4" desc="Core Identifiers. Read-only. Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]. See Core::X86::Cpuid::ExtApicId.">
      <!-- Bits 31:16 reserved. -->
      <field name="ThreadsPerCore" bit="8" size="8" desc="threads per core. Read-only. Reset: XXh. The number of threads per core is ThreadsPerCore + 1." />
      <field name="CoreId" bit="0" size="8" desc="core ID. Read-only. Reset: Fixed,XXh." />
    </register>
    <register name="NodeId" type="cpuid" eax="0x8000001E" output="ECX" size="4" desc="Node Identifiers. Read-only. Enable: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions].">
      <!-- Bits 31:11 reserved. -->
      <field name="NodesPerProcessor" bit="8" size="3" desc="Node per processor. Read-only. Reset: XXXb." />
      <field name="NodeId" bit="0" size="8" desc="Node ID. Read-only. Reset: Fixed,XXh." />
    </register>
    <register name="SecureEncryptionEax" type="cpuid" eax="0x8000001F" output="EAX" size="4" desc="AMD Secure Encryption EAX. Read-only. Reset: Fixed,0000_000Fh.">
      <!-- Bits 31:4 reserved. -->
      <field name="SevEs" bit="3" size="1" desc="Read-only. Reset: Fixed,1. Secure Encrypted ES." />
      <field name="VmPgFlush" bit="2" size="1" desc="VM Page Flush MSR is supported. Read-only. Reset: Fixed,1. See Core::X86::Msr::VMPAGE_FLUSH." />
      <field name="SEV" bit="1" size="1" desc="Read-only. Reset: Fixed,1. Secure Encrypted Virtualization supported." />
      <field name="SME" bit="0" size="1" desc="Read-only. Reset: Fixed,1. Secure Memory Encryption supported." />
    </register>
    <register name="SecureEncryptionEbx" type="cpuid" eax="0x8000001F" output="EBX" size="4" desc="AMD Secure Encryption EBX. Read-only.">
      <!-- Bits 31:12 reserved. -->
      <field name="MemEncryptPhysAddWidth" bit="6" size="6" desc="Read-only. Reset: 000XXXb. Reduction of physical address space in bits when memory encryption is enabled (0 indicates no reduction)." />
      <field name="CBit" bit="0" size="6" desc="Read-only. Reset: 2Fh. Page table bit number used to enable memory encryption." />
    </register>

    <!-- page 90 -->

    <register name="SecureEncryptionEcx" type="cpuid" eax="0x8000001F" output="ECX" size="4" desc="AMD Secure Encryption ECX. Read-only. Reset: 0000_000Fh.">
      <field name="NumEncryptedGuests" bit="0" size="32" desc="Read-only. Reset: 0000_000Fh. Indicates the maximum ASID value that may be used for an SEV-enabled guest." />
    </register>
    <register name="SecureEncryptionEdx" type="cpuid" eax="0x8000001F" output="EDX" size="4" desc="Minimum ASID. Read-only.">
      <field name="MinimumSEVASID" bit="0" size="32" desc="Minimum SEV enabled, SEV-ES disabled ASID. Read-only. Reset: 0000_000Xh. Indicates the minimum ASID value that must be used for an SEV-enabled, SEV-ES-disabled guest." />
    </register>

    <!-- 2.1.13.1 MSRs - MSR0000_xxxx -->

    <register name="TSC" type="msr" msr="0x00000010" desc="Time Stamp Counter. Read-write,Volatile. Reset: 0000_0000_0000_0000h. The TSC uses a common reference for all sockets, cores and threads.">
      <field name="TSC" bit="0" size="64" desc="time stamp counter. Read-write,Volatile. Reset: 0000_0000_0000_0000h. The TSC increments at the P0 frequency. The TSC counts at the same rate in all P-states, all C states, S0, or S1. A read of this MSR in guest mode is affected by Core::X86::Msr::TscRateMsr. The value (TSC/TSCRatio) is the TSC P0 frequency based value (as if TSCRatio == 1.0) when (TSCRatio != 1.0)." />
    </register>
    <register name="APIC_BAR" type="msr" msr="0x0000001B" desc="APIC Base Address.">
      <!-- Bits 63:48 reserved. -->
      <field name="ApicBar[47:12]" bit="12" size="36" desc="APIC base address register. Read-write. Reset: 0_000F_EE00h. Specifies the base address, physical address [47:12], for the APICXX register set in xAPIC mode. See 2.1.11.2.1.2 [APIC Register Space]." />
      <field name="ApicEn" bit="11" size="1" desc="APIC enable. Read-write. Reset: 0. 0=Disable Local Apic. 1=Local APIC is enabled in xAPIC mode. See 2.1.11.2.1.2 [APIC Register Space]." />
      <!-- Bits 10:9 reserved. -->
      <field name="BSC" bit="8" size="1" desc="boot strap core. Read-write,Volatile. Reset: X. 0=The core is not the boot core of the BSP. 1=The core is the boot core of the BSP." />
      <!-- Bits 7:0 reserved. -->
    </register>

    <!-- page 91 -->

    <register name="EBL_CR_POWERON" type="msr" msr="0x0000002A" desc="Cluster ID. Writes to this register result in a GP fault with error code 0.">
      <!-- Bits 63:18 reserved. -->
      <field name="ClusterID" bit="16" size="2" desc="Read,Error-on-write. Reset: 0h. The field does not affect hardware." />
      <!-- Bits 15:0 reserved. -->
    </register>
    <register name="PATCH_LEVEL" type="msr" msr="0x0000008B" desc="Patch Level. Read,Error-on-write,Volatile. Reset: 0000_0000_0000_0000h.">
      <!-- Bits 63:32 reserved. -->
      <field name="PatchLevel" bit="0" size="32" desc="Read,Error-on-write,Volatile. Reset: 0000_0000h. This returns an identification number for the microcode patch that has been loaded. If no patch has been loaded, this returns 0." />
    </register>
    <register name="MPERF" type="msr" msr="0x000000E7" desc="Max Performance Frequency Clock Count. Read-write,Volatile. Reset: 0000_0000_0000_0000h.">
      <field name="MPERF" bit="0" size="64" desc="maximum core clocks counter. Read-write,Volatile. Reset: 0000_0000_0000_0000h. Incremented by hardware at the P0 frequency while the core is in C0. This register does not increment when the core is in the stop-grant state. In combination with Core::X86::Msr::APERF, this is used to determine the effective frequency of the core. A Read of this MSR in guest mode is affected by Core::X86::Msr::TscRateMsr. This field uses software P-state numbering. See Core::X86::Msr::HWCR[EffFreqCntMwait], 2.1.4 [Effective Frequency]." />
    </register>
    <register name="APERF" type="msr" msr="0x000000E8" desc="Actual Performance Frequency Clock Count. Read-write,Volatile. Reset: 0000_0000_0000_0000h.">
      <field name="APERF" bit="0" size="64" desc="actual core clocks counter. Read-write,Volatile. Reset: 0000_0000_0000_0000h. This register increments in proportion to the actual number of core clocks cycles while the core is in C0. The register does not increment when the core is in the stop-grant state. See Core::X86::Msr::MPERF." />
    </register>
    <register name="MTRRcap" type="msr" msr="0x000000FE" desc="MTRR Capabilities. Read,Error-on-write. Reset: 0000_0000_0000_0508h.">
      <!-- Bits 63:11 reserved. -->
      <field name="MtrrCapWc" bit="10" size="1" desc="write-combining memory type. Read,Error-on-write. Reset: 1. 1=The write combining memory type is supported." />
      <!-- Bit 9 reserved. -->
      <field name="MtrrCapFix" bit="8" size="1" desc="fixed range register. Read,Error-on-write. Reset: 1. 1=Fixed MTRRs are supported." />
      <field name="MtrrCapVCnt" bit="0" size="8" desc="variable range registers count. Read,Error-on-write. Reset: 08h. Specifies the number of variable MTRRs supported." />
    </register>
    <register name="SYSENTER_CS" type="msr" msr="0x00000174" desc="SYSENTER CS. Read-write. Reset: 0000_0000_0000_0000h.">
      <!-- Bits 63:16 reserved. -->
      <field name="SysEnterCS" bit="0" size="16" desc="SYSENTER target CS. Read-write. Reset: 0000h. Holds the called procedure code segment." />
    </register>

    <!-- page 92 -->

    <register name="SYSENTER_ESP" type="msr" msr="0x00000175" desc="SYSENTER ESP. Read-write. Reset: 0000_0000_0000_0000h.">
      <!-- Bits 63:32 reserved. -->
      <field name="SysEnterESP" bit="0" size="32" desc="SYSENTER target SP. Read-write. Reset: 0000_0000h. Holds the called procedure stack pointer." />
    </register>
    <register name="SYSENTER_EIP" type="msr" msr="0x00000176" desc="SYSENTER EIP. Read-write. Reset: 0000_0000_0000_0000h.">
      <!-- Bits 63:32 reserved. -->
      <field name="SysEnterEIP" bit="0" size="32" desc="SYSENTER target IP. Read-write. Reset: 0000_0000h. Holds the called procedure instruction pointer." />
    </register>
    <register name="MCG_CAP" type="msr" msr="0x00000179" desc="Global Machine Check Capabilities.">
      <!-- Bits 63:9 reserved. -->
      <field name="McgCtlP" bit="8" size="1" desc="MCG_CTL register present. Read-only,Error-on-write. Reset: Fixed,1. 1=The machine check control registers (MCi_CTL) are present. See 3.1 [Machine Check Architecture]." />
      <field name="Count" bit="0" size="8" desc="Read-only,Error-on-write,Volatile. Reset: XXh. Indicates the number of error reporting banks visible to each core." />
    </register>
    <register name="MCG_STAT" type="msr" msr="0x0000017A" desc="Global Machine Check Status. Read-write,Volatile. Reset: 0000_0000_0000_0000h. See 3.1 [Machine Check Architecture].">
      <!-- Bits 63:3 reserved. -->
      <field name="MCIP" bit="2" size="1" desc="machine check in progress. Read-write,Volatile. Reset: 0. 1=A machine check is in progress. Machine check progress." />
      <field name="EIPV" bit="1" size="1" desc="error instruction pointer valid. Read-write,Volatile. Reset: 0. 1=The instruction pointer that was pushed onto the stack by the machine check mechanism references the instruction that caused the machine check error." />
      <field name="RIPV" bit="0" size="1" desc="restart instruction pointer valid. Read-write,Volatile. Reset: 0. 0=The interrupt was not precise and/or the process (task) context may be corrupt; continued operation of this process may not be possible without intervention, however system processing or other processes may be able to continue with appropriate software clean up. 1=Program execution can be reliably restarted at the EIP address on the stack." />
    </register>
    <register name="MCG_CTL" type="msr" msr="0x0000017B" desc="Global Machine Check Exception Reporting Control. Read-write. Reset: 0000_0000_0000_0000h. This register controls enablement of the individual error reporting banks; see 3.1 [Machine Check Architecture]. When a machine check register bank is not enabled in MCG_CTL, errors for that bank are not logged or reported, and actions enabled through the MCA are not taken; each MCi_CTL register identifies which errors are still corrected when MCG_CTL[i] is disabled.">
      <!-- Bits 63:16 reserved. -->
      <field name="MCnEn" bit="0" size="16" desc="Read-write. Reset: 0000h. 1=The MC0 machine check register bank is enabled." />
    </register>

    <!-- page 93 -->

    <register name="DBG_CTL_MSR" type="msr" msr="0x000001D9" desc="Debug Control.">
      <!-- Bits 63:6 reserved. -->
      <field name="PB" bit="2" size="4" desc="performance monitor pin control. Read-write. Reset: 0h. This field does not control any hardware." />
      <field name="BTF" bit="1" size="1" desc="Read-write. Reset: 0. 1=Enable branch single step." />
      <field name="LBR" bit="0" size="1" desc="Read-write. Reset: 0. 1=Enable last branch record." />
    </register>
    <register name="BR_FROM" type="msr" msr="0x000001DB" desc="Last Branch From IP. Read,Error-on-write,Volatile. Reset: 0000_0000_0000_0000h.">
      <field name="LastBranchFromIP" bit="0" size="64" desc="Read,Error-on-write,Volatile. Reset: 0000_0000_0000_0000h. Loaded with the segment offset of the branch instruction." />
    </register>
    <register name="BR_TO" type="msr" msr="0x000001DC" desc="Last Branch To IP. Read,Error-on-write,Volatile. Reset: 0000_0000_0000_0000h.">
      <field name="LastBranchToIP" bit="0" size="64" desc="Read,Error-on-write,Volatile. Reset: 0000_0000_0000_0000h. Holds the target RIP of the last branch that occurred before an exception or interrupt." />
    </register>
    <register name="LastExcpFromIp" type="msr" msr="0x000001DD" desc="Last Exception From IP. Read,Error-on-write,Volatile. Reset: 0000_0000_0000_0000h.">
      <field name="LastIntFromIP" bit="0" size="64" desc="Read,Error-on-write,Volatile. Reset: 0000_0000_0000_0000h. Holds the source RIP of the last branch that occurred before the exception or interrupt." />
    </register>
    <register name="LastExcpToIp" type="msr" msr="0x000001DE" desc="Last Exception To IP. Read,Error-on-write,Volatile. Reset: 0000_0000_0000_0000h.">
      <field name="LastIntToIP" bit="0" size="64" desc="Read,Error-on-write,Volatile. Reset: 0000_0000_0000_0000h. Holds the target RIP of the last branch that occurred before the exception or interrupt." />
    </register>

    <!-- page 94 -->

    <!-- TODO Multiple MSR instances, skipping MSR0000_0202 -->
    <!-- TODO Multiple MSR instances, skipping MSR0000_0204 -->
    <!-- TODO Multiple MSR instances, skipping MSR0000_0206 -->
    <!-- TODO Multiple MSR instances, skipping MSR0000_0208 -->
    <!-- TODO Multiple MSR instances, skipping MSR0000_020A -->
    <!-- TODO Multiple MSR instances, skipping MSR0000_020C -->
    <!-- TODO Multiple MSR instances, skipping MSR0000_020E -->
    <register name="MtrrVarBase" type="msr" msr="0x00000200" desc="Variable-Size MTRRs Base. Each MTRR (Core::X86::Msr::MtrrVarBase, Core::X86::Msr::MtrrFix_64K through Core::X86::Msr::MtrrFix_4K_7, or Core::X86::Msr::MTRRdefType) specifies a physical address range and a corresponding memory type (MemType) associated with that range. Setting the memory type to an unsupported value results in a #GP. The variable-size MTRRs come in pairs of base and mask registers (MSR0000_0200 and MSR0000_0201 are the first pair, etc.). Variables MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeEn]. A core access--with address CPUAddr--is determined to be within the address range of a variable-size MTRR if the following equation is true: CPUAddr[47:12] &amp; PhyMask[47:12] == PhyBase[47:12] &amp; PhyMask[47:12]. For example, if the variable MTRR spans 256 KB and starts at the 1-MB address the PhyBase would be set to 0_0010_0000h and the PhyMask to F_FFFC_0000h (with zeros filling in for bits[11:0]). This results in a range from 0_0010_0000h to 0_0013_FFFFh.">
      <!-- Bits 63:48 reserved. -->
      <field name="PhyBase" bit="12" size="36" desc="base address. Read-write. Reset: X_XXXX_XXXXh." />
      <!-- Bits 11:3 reserved. -->
      <field name="MemType" bit="0" size="3" desc="memory type. Read-write. Reset: XXXb. Address range from 00000h to 0FFFFh." />
    </register>

    <!-- TODO Multiple MSR instances, skipping MSR0000_0203 -->
    <!-- TODO Multiple MSR instances, skipping MSR0000_0205 -->
    <!-- TODO Multiple MSR instances, skipping MSR0000_0207 -->
    <!-- TODO Multiple MSR instances, skipping MSR0000_0209 -->
    <!-- TODO Multiple MSR instances, skipping MSR0000_020B -->
    <!-- TODO Multiple MSR instances, skipping MSR0000_020D -->
    <!-- TODO Multiple MSR instances, skipping MSR0000_020F -->
    <register name="MtrrVarMask" type="msr" msr="0x00000201" desc="Variable-Size MTRRs Mask.">
      <!-- Bits 63:48 reserved. -->
      <field name="PhyMask" bit="12" size="36" desc="address mask. Read-write. Reset: X_XXXX_XXXXh." />
      <field name="Valid" bit="11" size="1" desc="valid. Read-write. Reset: X. 1=The variable-size MTRR pair is enabled." />
      <!-- Bits 10:0 reserved. -->
    </register>
    <register name="MtrrFix_64K" type="msr" msr="0x00000250" desc="Fixed-Size MTRRs. See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1-MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an Error-on-write.">
      <!-- Bits 63:61 reserved. -->
      <field name="RdDram_64K_70000" bit="60" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_64K_70000" bit="59" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_64K_70000" bit="56" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 55:53 reserved. -->
      <field name="RdDram_64K_60000" bit="52" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_64K_60000" bit="51" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_64K_60000" bit="48" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 47:45 reserved. -->
      <field name="RdDram_64K_50000" bit="44" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_64K_50000" bit="43" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_64K_50000" bit="40" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 39:37 reserved. -->
      <field name="RdDram_64K_40000" bit="36" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_64K_40000" bit="35" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_64K_40000" bit="32" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 31:29 reserved. -->
      <field name="RdDram_64K_30000" bit="28" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_64K_30000" bit="27" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_64K_30000" bit="24" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 23:21 reserved. -->
      <field name="RdDram_64K_20000" bit="20" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_64K_20000" bit="19" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_64K_20000" bit="16" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 15:13 reserved. -->
      <field name="RdDram_64K_10000" bit="12" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_64K_10000" bit="11" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_64K_10000" bit="8" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 7:5 reserved. -->
      <field name="RdDram_64K_00000" bit="4" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from 00000h to 0FFFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_64K_00000" bit="3" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from 00000h to 0FFFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_64K_00000" bit="0" size="3" desc="memory type. Read-write. Reset: XXXb. Address range from 00000h to 0FFFFh." />
    </register>

    <!-- page 98 -->

    <register name="MtrrFix_16K_0" type="msr" msr="0x00000258" desc="Fixed-Size MTRRs. See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1-MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an Error-on-write.">
      <!-- Bits 63:61 reserved. -->
      <field name="RdDram_16K_9C000" bit="60" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_16K_9C000" bit="59" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_16K_9C000" bit="56" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 55:53 reserved. -->
      <field name="RdDram_16K_98000" bit="52" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_16K_98000" bit="51" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_16K_98000" bit="48" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 47:45 reserved. -->
      <field name="RdDram_16K_94000" bit="44" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_16K_94000" bit="43" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_16K_94000" bit="40" size="3" desc="memory type. Read-write. Reset: XXXb.  " />
      <!-- Bits 39:37 reserved. -->
      <field name="RdDram_16K_90000" bit="36" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_16K_90000" bit="35" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_16K_90000" bit="32" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 31:29 reserved. -->
      <field name="RdDram_16K_8C000" bit="28" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_16K_8C000" bit="27" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_16K_8C000" bit="24" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 23:21 reserved. -->
      <field name="RdDram_16K_88000" bit="20" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to   the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_16K_88000" bit="19" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_16K_88000" bit="16" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 15:13 reserved. -->
      <field name="RdDram_16K_84000" bit="12" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_16K_84000" bit="11" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_16K_84000" bit="8" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 7:5 reserved. -->
      <field name="RdDram_16K_80000" bit="4" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from 80000h to 83FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_16K_80000" bit="3" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from 80000h to 83FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_16K_80000" bit="0" size="3" desc="memory type. Read-write. Reset: XXXb. Address range from 80000h to 83FFFh." />
    </register>

    <!-- page 101 -->

    <register name="MtrrFix_16K_1" type="msr" msr="0x00000259" desc="Fixed-Size MTRRs. See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1-MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an Error-on-write.">
      <!-- Bits 63:61 reserved. -->
      <field name="RdDram_16K_BC000" bit="60" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_16K_BC000" bit="59" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_16K_BC000" bit="56" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 55:53 reserved. -->
      <field name="RdDram_16K_B8000" bit="52" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_16K_B8000" bit="51" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_16K_B8000" bit="48" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 47:45 reserved. -->
      <field name="RdDram_16K_B4000" bit="44" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_16K_B4000" bit="43" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_16K_B4000" bit="40" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 39:37 reserved. -->
      <field name="RdDram_16K_B0000" bit="36" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_16K_B0000" bit="35" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_16K_B0000" bit="32" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 31:29 reserved. -->
      <field name="RdDram_16K_AC000" bit="28" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_16K_AC000" bit="27" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM.   AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_16K_AC000" bit="24" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 23:21 reserved. -->
      <field name="RdDram_16K_A8000" bit="20" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_16K_A8000" bit="19" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_16K_A8000" bit="16" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 15:13 reserved. -->
      <field name="RdDram_16K_A4000" bit="12" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_16K_A4000" bit="11" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_16K_A4000" bit="8" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 7:5 reserved. -->
      <field name="RdDram_16K_A0000" bit="4" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from A0000h to A3FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_16K_A0000" bit="3" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from A0000h to A3FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_16K_A0000" bit="0" size="3" desc="memory type. Read-write. Reset: XXXb. Address range from A0000h to A3FFFh." />
    </register>

    <!-- page 104 -->

    <register name="MtrrFix_4K_0" type="msr" msr="0x00000268" desc="Fixed-Size MTRRs. See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1-MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an Error-on-write.">
      <!-- Bits 63:61 reserved. -->
      <field name="RdDram_4K_C7000" bit="60" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_C7000" bit="59" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_C7000" bit="56" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 55:53 reserved. -->
      <field name="RdDram_4K_C6000" bit="52" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_C6000" bit="51" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_C6000" bit="48" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 47:45 reserved. -->
      <field name="RdDram_4K_C5000" bit="44" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_C5000" bit="43" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_C5000" bit="40" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 39:37 reserved. -->
      <field name="RdDram_4K_C4000" bit="36" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_C4000" bit="35" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_C4000" bit="32" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 31:29 reserved. -->
      <field name="RdDram_4K_C3000" bit="28" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_C3000" bit="27" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_C3000" bit="24" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 23:21 reserved. -->
      <field name="RdDram_4K_C2000" bit="20" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_C2000" bit="19" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_C2000" bit="16" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 15:13 reserved. -->
      <field name="RdDram_4K_C1000" bit="12" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset:   Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_C1000" bit="11" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_C1000" bit="8" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 7:5 reserved. -->
      <field name="RdDram_4K_C0000" bit="4" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from C0000h to C0FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_C0000" bit="3" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from C0000h to C0FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_C0000" bit="0" size="3" desc="memory type. Read-write. Reset: XXXb. Address range from C0000h to C0FFFh." />
    </register>

    <!-- page 107 -->

    <register name="MtrrFix_4K_1" type="msr" msr="0x00000269" desc="Fixed-Size MTRRs. See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1-MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an Error-on-write.">
      <!-- Bits 63:61 reserved. -->
      <field name="RdDram_4K_CF000" bit="60" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_CF000" bit="59" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to   the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_CF000" bit="56" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 55:53 reserved. -->
      <field name="RdDram_4K_CE000" bit="52" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_CE000" bit="51" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_CE000" bit="48" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 47:45 reserved. -->
      <field name="RdDram_4K_CD000" bit="44" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_CD000" bit="43" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_CD000" bit="40" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 39:37 reserved. -->
      <field name="RdDram_4K_CC000" bit="36" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_CC000" bit="35" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_CC000" bit="32" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 31:29 reserved. -->
      <field name="RdDram_4K_CB000" bit="28" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_CB000" bit="27" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_CB000" bit="24" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 23:21 reserved. -->
      <field name="RdDram_4K_CA000" bit="20" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_CA000" bit="19" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_CA000" bit="16" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 15:13 reserved. -->
      <field name="RdDram_4K_C9000" bit="12" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_C9000" bit="11" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_C9000" bit="8" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 7:5 reserved. -->
      <field name="RdDram_4K_C8000" bit="4" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from C8000 to C8FFF. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_C8000" bit="3" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from C8000 to C8FFF. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_C8000" bit="0" size="3" desc="memory type. Read-write. Reset: XXXb. Address range from C8000 to C8FFF." />
    </register>

    <!-- page 111 -->

    <register name="MtrrFix_4K_2" type="msr" msr="0x0000026A" desc="Fixed-Size MTRRs. See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1-MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an Error-on-write.">
      <!-- Bits 63:61 reserved. -->
      <field name="RdDram_4K_D7000" bit="60" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_D7000" bit="59" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_D7000" bit="56" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 55:53 reserved. -->
      <field name="RdDram_4K_D6000" bit="52" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_D6000" bit="51" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_D6000" bit="48" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 47:45 reserved. -->
      <field name="RdDram_4K_D5000" bit="44" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM.   AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_D5000" bit="43" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_D5000" bit="40" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 39:37 reserved. -->
      <field name="RdDram_4K_D4000" bit="36" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_D4000" bit="35" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_D4000" bit="32" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 31:29 reserved. -->
      <field name="RdDram_4K_D3000" bit="28" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_D3000" bit="27" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_D3000" bit="24" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 23:21 reserved. -->
      <field name="RdDram_4K_D2000" bit="20" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_D2000" bit="19" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_D2000" bit="16" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 15:13 reserved. -->
      <field name="RdDram_4K_D1000" bit="12" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_D1000" bit="11" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_D1000" bit="8" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 7:5 reserved. -->
      <field name="RdDram_4K_D0000" bit="4" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from D0000h to D0FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_D0000" bit="3" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from D0000h to D0FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_D0000" bit="0" size="3" desc="memory type. Read-write. Reset: XXXb. Address range from D0000h to D0FFFh." />
    </register>

    <!-- page 114 -->

    <register name="MtrrFix_4K_3" type="msr" msr="0x0000026B" desc="Fixed-Size MTRRs. See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1-MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an Error-on-write.">
      <!-- Bits 63:61 reserved. -->
      <field name="RdDram_4K_DF000" bit="60" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_DF000" bit="59" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_DF000" bit="56" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 55:53 reserved. -->
      <field name="RdDram_4K_DE000" bit="52" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_DE000" bit="51" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset:   Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_DE000" bit="48" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 47:45 reserved. -->
      <field name="RdDram_4K_DD000" bit="44" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_DD000" bit="43" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_DD000" bit="40" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 39:37 reserved. -->
      <field name="RdDram_4K_DC000" bit="36" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_DC000" bit="35" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_DC000" bit="32" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 31:29 reserved. -->
      <field name="RdDram_4K_DB000" bit="28" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_DB000" bit="27" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_DB000" bit="24" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 23:21 reserved. -->
      <field name="RdDram_4K_DA000" bit="20" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_DA000" bit="19" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_DA000" bit="16" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 15:13 reserved. -->
      <field name="RdDram_4K_D9000" bit="12" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_D9000" bit="11" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_D9000" bit="8" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 7:5 reserved. -->
      <field name="RdDram_4K_D8000" bit="4" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from D8000h to D8FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_D8000" bit="3" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from D8000h to D8FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_D8000" bit="0" size="3" desc="memory type. Read-write. Reset: XXXb. Address range from D8000h to D8FFFh." />
    </register>

    <!-- page 117 -->

    <register name="MtrrFix_4K_4" type="msr" msr="0x0000026C" desc="Fixed-Size MTRRs. See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1-MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an Error-on-write.">
      <!-- Bits 63:61 reserved. -->
      <field name="RdDram_4K_E7000" bit="60" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_E7000" bit="59" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_E7000" bit="56" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 55:53 reserved. -->
      <field name="RdDram_4K_E6000" bit="52" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_E6000" bit="51" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_E6000" bit="48" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 47:45 reserved. -->
      <field name="RdDram_4K_E5000" bit="44" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_E5000" bit="43" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_E5000" bit="40" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 39:37 reserved. -->
      <field name="RdDram_4K_E4000" bit="36" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_E4000" bit="35" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_E4000" bit="32" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 31:29 reserved. -->
      <field name="RdDram_4K_E3000" bit="28" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_E3000" bit="27" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_E3000" bit="24" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 23:21 reserved. -->
      <field name="RdDram_4K_E2000" bit="20" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_E2000" bit="19" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_E2000" bit="16" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 15:13 reserved. -->
      <field name="RdDram_4K_E1000" bit="12" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_E1000" bit="11" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_E1000" bit="8" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 7:5 reserved. -->
      <field name="RdDram_4K_E0000" bit="4" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from E0000h to E0FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_E0000" bit="3" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from E0000h to E0FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_E0000" bit="0" size="3" desc="memory type. Read-write. Reset: XXXb. Address range from E0000h to E0FFFh." />
    </register>

    <!-- page 121 -->

    <register name="MtrrFix_4K_5" type="msr" msr="0x0000026D" desc="Fixed-Size MTRRs. See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1-MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an Error-on-write.">
      <!-- Bits 63:61 reserved. -->
      <field name="RdDram_4K_EF000" bit="60" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_EF000" bit="59" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_EF000" bit="56" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 55:53 reserved. -->
      <field name="RdDram_4K_EE000" bit="52" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_EE000" bit="51" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_EE000" bit="48" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 47:45 reserved. -->
      <field name="RdDram_4K_ED000" bit="44" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_ED000" bit="43" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_ED000" bit="40" size="3" desc="memory type. Read-write. Reset: XXXb.  " />
      <!-- Bits 39:37 reserved. -->
      <field name="RdDram_4K_EC000" bit="36" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_EC000" bit="35" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_EC000" bit="32" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 31:29 reserved. -->
      <field name="RdDram_4K_EB000" bit="28" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_EB000" bit="27" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_EB000" bit="24" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 23:21 reserved. -->
      <field name="RdDram_4K_EA000" bit="20" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to   the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_EA000" bit="19" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_EA000" bit="16" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 15:13 reserved. -->
      <field name="RdDram_4K_E9000" bit="12" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_E9000" bit="11" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_E9000" bit="8" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 7:5 reserved. -->
      <field name="RdDram_4K_E8000" bit="4" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from E8000h to E8FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_E8000" bit="3" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from E8000h to E8FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_E8000" bit="0" size="3" desc="memory type. Read-write. Reset: XXXb. Address range from E8000h to E8FFFh." />
    </register>

    <!-- page 124 -->

    <register name="MtrrFix_4K_6" type="msr" msr="0x0000026E" desc="Fixed-Size MTRRs. See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1-MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an Error-on-write.">
      <!-- Bits 63:61 reserved. -->
      <field name="RdDram_4K_F7000" bit="60" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_F7000" bit="59" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_F7000" bit="56" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 55:53 reserved. -->
      <field name="RdDram_4K_F6000" bit="52" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_F6000" bit="51" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_F6000" bit="48" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 47:45 reserved. -->
      <field name="RdDram_4K_F5000" bit="44" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_F5000" bit="43" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_F5000" bit="40" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 39:37 reserved. -->
      <field name="RdDram_4K_F4000" bit="36" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_F4000" bit="35" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_F4000" bit="32" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 31:29 reserved. -->
      <field name="RdDram_4K_F3000" bit="28" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_F3000" bit="27" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM.   AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_F3000" bit="24" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 23:21 reserved. -->
      <field name="RdDram_4K_F2000" bit="20" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_F2000" bit="19" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_F2000" bit="16" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 15:13 reserved. -->
      <field name="RdDram_4K_F1000" bit="12" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_F1000" bit="11" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_F1000" bit="8" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 7:5 reserved. -->
      <field name="RdDram_4K_F0000" bit="4" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from F0000h to F0FFF. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_F0000" bit="3" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from F0000h to F0FFF. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_F0000" bit="0" size="3" desc="memory type. Read-write. Reset: XXXb. Address range from F0000h to F0FFFh." />
    </register>

    <!-- page 127 -->

    <register name="MtrrFix_4K_7" type="msr" msr="0x0000026F" desc="Fixed-Size MTRRs. See Core::X86::Msr::MtrrVarBase for general MTRR information. Fixed MTRRs are enabled through Core::X86::Msr::MTRRdefType[MtrrDefTypeFixEn,MtrrDefTypeEn]. For addresses below 1-MB, the appropriate Fixed MTRRs override the default access destination. Each fixed MTRR includes two bits, RdDram and WrDram, that determine the destination based on the access type. Writing Reserved MemType values causes an Error-on-write.">
      <!-- Bits 63:61 reserved. -->
      <field name="RdDram_4K_FF000" bit="60" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_FF000" bit="59" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_FF000" bit="56" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 55:53 reserved. -->
      <field name="RdDram_4K_FE000" bit="52" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_FE000" bit="51" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_FE000" bit="48" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 47:45 reserved. -->
      <field name="RdDram_4K_FD000" bit="44" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_FD000" bit="43" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_FD000" bit="40" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 39:37 reserved. -->
      <field name="RdDram_4K_FC000" bit="36" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_FC000" bit="35" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_FC000" bit="32" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 31:29 reserved. -->
      <field name="RdDram_4K_FB000" bit="28" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_FB000" bit="27" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_FB000" bit="24" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 23:21 reserved. -->
      <field name="RdDram_4K_FA000" bit="20" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_FA000" bit="19" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_FA000" bit="16" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 15:13 reserved. -->
      <field name="RdDram_4K_F9000" bit="12" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset:   Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_F9000" bit="11" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_F9000" bit="8" size="3" desc="memory type. Read-write. Reset: XXXb." />
      <!-- Bits 7:5 reserved. -->
      <field name="RdDram_4K_F8000" bit="4" size="1" desc="Read DRAM. 0=Read accesses to the range are marked as MMIO. 1=Read accesses to the range are marked as destined for DRAM. Address range from F8000h to F8FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="WrDram_4K_F8000" bit="3" size="1" desc="Write DRAM. 0=Write accesses to the range are marked as MMIO. 1=Write accesses to the range are marked as destined for DRAM. Address range from F8000h to F8FFFh. Core::X86::Msr::SYS_CFG[MtrrFixDramEn,MtrrFixDramModEn] masks Reads of the stored value. AccessType: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? Read-write : Read,Error-on-write-1. Reset: Core::X86::Msr::SYS_CFG[MtrrFixDramModEn] ? X : Fixed,0." />
      <field name="MemType_4K_F8000" bit="0" size="3" desc="memory type. Read-write. Reset: XXXb. Address range from F8000h to F8FFFh." />
    </register>

    <!-- page 130 -->

    <register name="PAT" type="msr" msr="0x00000277" desc="Page Attribute Table. This register specifies the memory type based on the PAT, PCD, and PWT bits in the virtual address page tables.">
      <!-- Bits 63:59 reserved. -->
      <field name="PA7MemType" bit="56" size="3" desc="Read-write. Reset: 0h. Default UC. MemType for {PAT, PCD, PWT} = 7h." />
      <!-- Bits 55:51 reserved. -->
      <field name="PA6MemType" bit="48" size="3" desc="Read-write. Reset: 7h. Default UC. MemType for {PAT, PCD, PWT} = 6h." />
      <!-- Bits 47:43 reserved. -->
      <field name="PA5MemType" bit="40" size="3" desc="Read-write. Reset: 4h. Default WT. MemType for {PAT, PCD, PWT} = 5h." />
      <!-- Bits 39:35 reserved. -->
      <field name="PA4MemType" bit="32" size="3" desc="Read-write. Reset: 6h. Default WB. MemType for {PAT, PCD, PWT} = 4h." />
      <!-- Bits 31:27 reserved. -->
      <field name="PA3MemType" bit="24" size="3" desc="Read-write. Reset: 0h. Default UC. MemType for {PAT, PCD, PWT} = 3h." />
      <!-- Bits 23:19 reserved. -->
      <field name="PA2MemType" bit="16" size="3" desc="Read-write. Reset: 7h. Default UC. MemType for {PAT, PCD, PWT} = 2h.  " />
      <!-- Bits 15:11 reserved. -->
      <field name="PA1MemType" bit="8" size="3" desc="Read-write. Reset: 4h. Default WT. MemType for {PAT, PCD, PWT} = 1h." />
      <!-- Bits 7:3 reserved. -->
      <field name="PA0MemType" bit="0" size="3" desc="Read-write. Reset: 6h. MemType for {PAT, PCD, PWT} = 0h." />
    </register>

    <!-- page 132 -->

    <register name="MTRRdefType" type="msr" msr="0x000002FF" desc="MTRR Default Memory Type. See Core::X86::Msr::MtrrVarBase for general MTRR information.">
      <!-- Bits 63:12 reserved. -->
      <field name="MtrrDefTypeEn" bit="11" size="1" desc="variable and fixed MTRR enable. Read-write. Reset: 0. 0=Fixed and variable MTRRs are not enabled. 1=Core::X86::Msr::MtrrVarBase, and Core::X86::Msr::MtrrFix_64K through Core::X86::Msr::MtrrFix_4K_7 are enabled." />
      <field name="MtrrDefTypeFixEn" bit="10" size="1" desc="fixed MTRR enable. Read-write. Reset: 0. 0=Core::X86::Msr::MtrrFix_64K through Core::X86::Msr::MtrrFix_4K_7 are not enabled. 1=Core::X86::Msr::MtrrFix_64K through Core::X86::Msr::MtrrFix_4K_7 are enabled. This field is ignored (and the fixed MTRRs are not enabled) if Core::X86::Msr::MTRRdefType[MtrrDefTypeEn] == 0." />
      <!-- Bits 9:8 reserved. -->
      <field name="MemType" bit="0" size="8" desc="memory type. Read-write. Reset: 00h. Description: If MtrrDefTypeEn == 1 then MemType specifies the memory type for memory space that is not specified by either the fixed or variable range MTRRs. If MtrrDefTypeEn == 0 then the default memory type for all of memory is UC. Valid encodings are {00000b, Core::X86::Msr::MtrrFix_64K through Core::X86::Msr::MtrrFix_4K_7[2:0]}.  Other write values cause a GP(0)." />
    </register>

    <!-- 2.1.13.2 MSRs - MSRC000_0xxx -->

    <!-- page 133 -->

    <register name="EFER" type="msr" msr="0xC0000080" desc="Extended Feature Enable. SKINIT Execution: 0000_0000_0000_0000h.">
      <!-- Bits 63:16 reserved. -->
      <field name="TCE" bit="15" size="1" desc="translation cache extension enable. Read-write. Reset: 0. 1=Translation cache extension is enabled. PDC entries related to the linear address of the INVLPG instruction are invalidated. If &lt;VALUE> == 0 all PDC entries are invalidated by the INVLPG instruction." />
      <field name="FFXSE" bit="14" size="1" desc="fast FXSAVE/FRSTOR enable. Read-write. Reset: 0. 1=Enables the fast FXSAVE/FRSTOR mechanism. A 64-bit operating system may enable the fast FXSAVE/FRSTOR mechanism if (Core::X86::Cpuid::FeatureExtIdEdx[FFXSR] == 1). This bit is set once by the operating system and its value is not changed afterwards." />
      <field name="LMSLE" bit="13" size="1" desc="long mode segment limit enable. Read-write. Reset: 0. 1=Enables the long mode segment limit check mechanism." />
      <field name="SVME" bit="12" size="1" desc="secure virtual machine (SVM) enable. Reset: Fixed,0. 1=SVM features are enabled. AccessType: Core::X86::Msr::VM_CR[SvmeDisable] ? Read-only,Error-on-write-1 : Read-write." />
      <field name="NXE" bit="11" size="1" desc="no-execute page enable. Read-write. Reset: 0. 1=The no-execute page protection feature is enabled." />
      <field name="LMA" bit="10" size="1" desc="long mode active. Read-only. Reset: 0. 1=Indicates that long mode is active. When writing the EFER register the value of this bit must be preserved. Software must read the EFER register to determine the value of LMA, change any other bits as required and then write the EFER register. An attempt to write a value that differs from the state determined by hardware results in a #GP fault." />
      <!-- Bit 9 reserved. -->
      <field name="LME" bit="8" size="1" desc="long mode enable. Read-write. Reset: 0. 1=Long mode is enabled." />
      <!-- Bits 7:1 reserved. -->
      <field name="SYSCALL" bit="0" size="1" desc="system call extension enable. Read-write. Reset: 0. 1=SYSCALL and SYSRET instructions are enabled. This adds the SYSCALL and SYSRET instructions which can be used in flat addressed operating systems as low latency system calls and returns." />
    </register>
    <register name="STAR" type="msr" msr="0xC0000081" desc="SYSCALL Target Address. Read-write. Reset: 0000_0000_0000_0000h. This register holds the target address used by the SYSCALL instruction and the code and stack segment selector bases used by the SYSCALL and SYSRET instructions.">
      <field name="SysRetSel" bit="48" size="16" desc="SYSRET CS and SS. Read-write. Reset: 0000h." />
      <field name="SysCallSel" bit="32" size="16" desc="SYSCALL CS and SS. Read-write. Reset: 0000h." />
      <field name="Target" bit="0" size="32" desc="SYSCALL target address. Read-write. Reset: 0000_0000h." />
    </register>

    <!-- page 134 -->

    <register name="STAR64" type="msr" msr="0xC0000082" desc="Long Mode SYSCALL Target Address. Read-write. Reset: 0000_0000_0000_0000h.">
      <field name="LSTAR" bit="0" size="64" desc="long mode target address. Read-write. Reset: 0000_0000_0000_0000h. Target address for 64-bit mode calling programs. The address stored in this register must be in canonical form (if not canonical, a #GP fault   occurs)." />
    </register>
    <register name="STARCOMPAT" type="msr" msr="0xC0000083" desc="Compatibility Mode SYSCALL Target Address. Read-write. Reset: 0000_0000_0000_0000h.">
      <field name="CSTAR" bit="0" size="64" desc="compatibility mode target address. Read-write. Reset: 0000_0000_0000_0000h. Target address for compatibility mode. The address stored in this register must be in canonical form (if not canonical, a #GP fault occurs)." />
    </register>
    <register name="SYSCALL_FLAG_MASK" type="msr" msr="0xC0000084" desc="SYSCALL Flag Mask.">
      <!-- Bits 63:32 reserved. -->
      <field name="Mask" bit="0" size="32" desc="SYSCALL flag mask. Read-write. Reset: 0000_0000h. This register holds the EFLAGS mask used by the SYSCALL instruction. 1=Clear the corresponding EFLAGS bit when executing the SYSCALL instruction." />
    </register>
    <register name="MPerfReadOnly" type="msr" msr="0xC00000E7" desc="Read-Only Max Performance Frequency Clock Count. Reset: 0000_0000_0000_0000h.">
      <field name="MPerfReadOnly" bit="0" size="64" desc="Read-only maximum core clocks counter. Reset: 0000_0000_0000_0000h. Incremented by hardware at the P0 frequency while the core is in C0. In combination with Core::X86::Msr::APerfReadOnly, this is used to determine the effective frequency of the core. A Read of this MSR in guest mode is affected by Core::X86::Msr::TscRateMsr. This field uses software P-state numbering. See Core::X86::Msr::HWCR[EffFreqCntMwait], 2.1.4 [Effective Frequency]. This register is not affected by writes to Core::X86::Msr::MPERF. AccessType: Core::X86::Msr::HWCR[EffFreqReadOnlyLock] ? Read-only,Volatile : Read-write,Volatile." />
    </register>
    <register name="APerfReadOnly" type="msr" msr="0xC00000E8" desc="Read-Only Actual Performance Frequency Clock Count. Reset: 0000_0000_0000_0000h.">
      <field name="APerfReadOnly" bit="0" size="64" desc="Read-only actual core clocks counter. Reset: 0000_0000_0000_0000h. This register increments in proportion to the actual number of core clocks cycles while the core is in C0. See Core::X86::Msr::MPerfReadOnly. This register is not affected by Writes to Core::X86::Msr::APERF. AccessType: Core::X86::Msr::HWCR[EffFreqReadOnlyLock] ? Read-only,Volatile : Read-write,Volatile." />
    </register>
    <register name="IRPerfCount" type="msr" msr="0xC00000E9" desc="Instructions Retired Performance Count. Reset: 0000_0000_0000_0000h.">
      <field name="IRPerfCount" bit="0" size="64" desc="instructions retired counter. Reset: 0000_0000_0000_0000h. Dedicated Instructions Retired register increments on once for every instruction retired. See Core::X86::Msr::HWCR[IRPerfEn]. AccessType: Core::X86::Msr::HWCR[EffFreqReadOnlyLock] ? Read-only,Volatile : Read-write,Volatile." />
    </register>

    <!-- page 135 -->

    <register name="FS_BASE" type="msr" msr="0xC0000100" desc="FS Base. Read-write. Reset: 0000_0000_0000_0000h.">
      <field name="FSBase" bit="0" size="64" desc="expanded FS segment base. Read-write. Reset: 0000_0000_0000_0000h. This register provides access to the expanded 64-bit FS segment base. The address stored in this register must be in canonical form (if not canonical, a #GP fault fill occurs)." />
    </register>
    <register name="GS_BASE" type="msr" msr="0xC0000101" desc="GS Base. Read-write. Reset: 0000_0000_0000_0000h.">
      <field name="GSBase" bit="0" size="64" desc="expanded GS segment base. Read-write. Reset: 0000_0000_0000_0000h. This register provides access to the expanded 64-bit GS segment base. The address stored in this register must be in canonical form (if not canonical, a #GP fault fill occurs)." />
    </register>
    <register name="KernelGSbase" type="msr" msr="0xC0000102" desc="Kernel GS Base. Read-write. Reset: 0000_0000_0000_0000h.">
      <field name="KernelGSBase" bit="0" size="64" desc="kernel data structure pointer. Read-write. Reset: 0000_0000_0000_0000h. This register holds the kernel data structure pointer which can be swapped with the GS_BASE register using the SwapGS instruction. The address stored in this register must be in canonical form (if not canonical, a #GP fault occurs)." />
    </register>
    <register name="TSC_AUX" type="msr" msr="0xC0000103" desc="Auxiliary Time Stamp Counter. Read-write,Volatile. Reset: 0000_0000_0000_0000h.">
      <!-- Bits 63:32 reserved. -->
      <field name="TscAux" bit="0" size="32" desc="auxiliary time stamp counter data. Read-write,Volatile. Reset: 0000_0000h. It is expected that this is initialized by privileged software to a meaningful value, such as a processor ID. This value is returned in the RDTSCP instruction." />
    </register>
    <register name="TscRateMsr" type="msr" msr="0xC0000104" desc="Time Stamp Counter Ratio. Core::X86::Msr::TscRateMsr allows the hypervisor to control the guest's view of the Time Stamp Counter. It provides a multiplier that scales the value returned when Core::X86::Msr::TSC[TSC], Core::X86::Msr::MPERF[MPERF], and Core::X86::Msr::MPerfReadOnly[MPerfReadOnly] are read by a guest running under virtualization. This allows the hypervisor to provide a consistent TSC, MPERF, and MPerfReadOnly rate for a guest process when moving that process between cores that have a differing P0 rate. The TSC Ratio MSR does not affect the value read from the TSC, MPERF, and MPerfReadOnly MSRs when read while in host mode or when virtualization is not being used or when accessed by code executed in system management mode (SMM) unless the SMM code is executed within a guest container. The TSC Ratio value does not affect the rate of the underlying TSC, MPERF, and MPerfReadOnly counters, or the value that gets written to the TSC, MPERF, and MPerfReadOnly MSRs counters on a Write by either the host or the guest. The TSC Ratio MSR contains a fixed-point number in 8.32 format, which is 8 bits of integer and 32 bits of fraction. This number is the ratio of the desired P0 frequency to the P0 frequency of the core. The reset value of the TSC Ratio MSR is 1.0, which results in a guest frequency matches the core P0 frequency.">
      <!-- Bits 63:40 reserved. -->
      <field name="TscRateMsrInt" bit="32" size="8" desc="time stamp counter rate integer. Read-write. Reset: 01h. Specifies the integer part of the MSR TSC ratio value." />
      <field name="TscRateMsrFrac" bit="0" size="32" desc="time stamp counter rate fraction. Read-write. Reset: 0000_0000h. Specifies the fractional part of the MSR TSC ratio value." />
    </register>
    <register name="McaIntrCfg" type="msr" msr="0xC0000410" desc="MCA Interrupt Configuration. Read-write. Reset: 0000_0000_0000_0000h. MSRC000_0410">
      <!-- Bits 63:16 reserved. -->
      <field name="ThresholdLvtOffset" bit="12" size="4" desc="Read-write. Reset: 0h. For error thresholding interrupts, specifies the address of the LVT entry in the APIC registers as follows: LVT address = (LvtOffset shifted left 4 bits) + 500h (see  Core::X86::Apic::ExtendedInterruptLvtEntries)." />
      <!-- Bits 11:8 reserved. -->
      <field name="DeferredLvtOffset" bit="4" size="4" desc="Read-write. Reset: 0h. Description: For deferred error interrupts, specifies the address of the LVT entry in the APIC registers as follows: LVT address = (LvtOffset shifted left 4 bits) + 500h (see APIC[530:500])." />
      <!-- Bits 3:0 reserved. -->
    </register>

    <!-- 2.1.13.3 MSRs - MSRC001_0xxx -->

    <!-- page 136 -->

    <!-- TODO Multiple MSR instances, skipping MSRC001_0001 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0002 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0003 -->
    <register name="PERF_LEGACY_CTL" type="msr" msr="0xC0010000" desc="Performance Event Select [3:0]. Read-write. Reset: 0000_0000_0000_0000h. The legacy alias of Core::X86::Msr::PERF_CTL. See Core::X86::Msr::PERF_CTL.">
      <!-- Bits 63:42 reserved. -->
      <field name="HostGuestOnly" bit="40" size="2" desc="count only host/guest events. Read-write. Reset: 0h." />
      <!-- Bits 39:36 reserved. -->
      <field name="EventSelect[11:8]" bit="32" size="4" desc="performance event select. Read-write. Reset: 0h." />
      <field name="CntMask" bit="24" size="8" desc="counter mask. Read-write. Reset: 00h. Controls the number of events counted per clock cycle." />
      <field name="Inv" bit="23" size="1" desc="invert counter mask. Read-write. Reset: 0." />
      <field name="En" bit="22" size="1" desc="enable performance counter. Read-write. Reset: 0." />
      <!-- Bit 21 reserved. -->
      <field name="Int" bit="20" size="1" desc="enable APIC interrupt. Read-write. Reset: 0." />
      <!-- Bit 19 reserved. -->
      <field name="Edge" bit="18" size="1" desc="edge detect. Read-write. Reset: 0." />
      <field name="OsUserMode" bit="16" size="2" desc="OS and user mode. Read-write. Reset: 0h." />
      <field name="UnitMask" bit="8" size="8" desc="event qualification. Read-write. Reset: 00h. When selecting an event for which not all UnitMask bits are defined, the undefined UnitMask bits should be set to zero." />
      <field name="EventSelect[7:0]" bit="0" size="8" desc="event select. Read-write. Reset: 00h." />
    </register>

    <!-- page 137 -->

    <!-- TODO Multiple MSR instances, skipping MSRC001_0005 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0006 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0007 -->
    <register name="PERF_LEGACY_CTR" type="msr" msr="0xC0010004" desc="Performance Event Counter [3:0]. Read-write,Volatile. Reset: 0000_0000_0000_0000h. Note: When counting events that capable of counting greater than 15 events per cycle (MergeEvent) the even and the corresponding odd PERF_LEGACY_CTR must be paired to appear as a single 64-bit counter. See 2.1.14.2 [Large Increment per Cycle Events]. The legacy alias of Core::X86::Msr::PERF_CTR. See Core::X86::Msr::PERF_CTR.">
      <!-- Bits 63:48 reserved. -->
      <field name="CTR" bit="0" size="48" desc="performance counter value. Read-write,Volatile. Reset: 0000_0000_0000h. In special cases (see 2.1.14.2 [Large Increment per Cycle Events]) CTR can appear as a 64-bit counter." />
    </register>
    <register name="SYS_CFG" type="msr" msr="0xC0010010" desc="System Configuration. Reset: 0000_0000_0000_0000h.">
      <!-- Bits 63:24 reserved. -->
      <field name="SMEE" bit="23" size="1" desc="secure memory encryption enable. Reset: 0. 0=Memory encryption features are disabled. 1=Memory encryption features are enabled. Once Core::X86::Msr::HWCR[SmmLock] is set, this bit cannot be cleared until a reset. For enabling secure memory encryption see 2.1.3 [Memory Encryption]. AccessType: Core::X86::Msr::HWCR_thread0[SmmLock] ? Read,Write-1-only : Read-write." />
      <field name="Tom2ForceMemTypeWB" bit="22" size="1" desc="top of memory 2 memory type write back. Read-write. Reset: 0. 1=The default memory type of memory between 4-GB and Core::X86::Msr::TOM2 is Write-back instead of the memory type defined by Core::X86::Msr::MTRRdefType[MemType]. For this bit to have any effect, Core::X86::Msr::MTRRdefType[MtrrDefTypeEn] must be 1. MTRRs and PAT can be used to override this memory type." />
      <field name="MtrrTom2En" bit="21" size="1" desc="MTRR top of memory 2 enable. Read-write. Reset: 0. 0=Core::X86::Msr::TOM2 is disabled. 1= Core::X86::Msr::TOM2 is enabled." />
      <field name="MtrrVarDramEn" bit="20" size="1" desc="MTRR variable DRAM enable. Read-write. Reset: 0. Init: BIOS,1. 0=Core::X86::Msr::TOP_MEM and IORRs are disabled. 1=These registers are enabled." />
      <field name="MtrrFixDramModEn" bit="19" size="1" desc="MTRR fixed RdDram and WrDram modification enable. Read-write. Reset: 0. 0=Core::X86::Msr::MtrrFix_64K through Core::X86::Msr::MtrrFix_4K_7 [RdDram,WrDram] read values is masked 00b; writing does not change the hidden value. 1=Core::X86::Msr::MtrrFix_64K through Core::X86::Msr::MtrrFix_4K_7 [RdDram,WrDram] access type is Read-write. Not shared between threads. Controls access to Core::X86::Msr::MtrrFix_64K through Core::X86::Msr::MtrrFix_4K_7 [RdDram ,WrDram]. This bit should be set to 1 during BIOS initialization of the fixed MTRRs, then cleared to 0 for operation." />
      <field name="MtrrFixDramEn" bit="18" size="1" desc="MTRR fixed RdDram and WrDram attributes enable. Read-write. Reset: 0. Init: BIOS,1. 1=Enables the RdDram and WrDram attributes in Core::X86::Msr::MtrrFix_64K through Core::X86::Msr::MtrrFix_4K_7." />
      <!-- Bits 17:0 reserved. -->
    </register>

    <!-- page 138 -->

    <register name="HWCR" type="msr" msr="0xC0010015" desc="Hardware Configuration. Reset: 0000_0000_0100_0010h.">
      <!-- Bits 63:31 reserved. -->
      <field name="IRPerfEn" bit="30" size="1" desc="enable instructions retired counter. Read-write. Reset: 0. 1=Enable Core::X86::Msr::IRPerfCount." />
      <!-- Bits 29:28 reserved. -->
      <field name="EffFreqReadOnlyLock" bit="27" size="1" desc="read-only effective frequency counter lock. Write-1-only. Reset: 0. Init: BIOS,1. 1=Core::X86::Msr::MPerfReadOnly, Core::X86::Msr::APerfReadOnly and Core::X86::Msr::IRPerfCount are Read-only." />
      <field name="EffFreqCntMwait" bit="26" size="1" desc="effective frequency counting during mwait. Read-write. Reset: 0. 0=The registers do not increment. 1=The registers increment. Specifies whether Core::X86::Msr::MPERF and Core::X86::Msr::APERF increment while the core is in the monitor event pending state. See 2.1.4 [Effective Frequency]." />
      <field name="CpbDis" bit="25" size="1" desc="core performance boost disable. Read-write. Reset: 0. 0=CPB is requested to be enabled. 1=CPB is disabled. Specifies whether core performance boost is requested to be enabled or disabled. If core performance boost is disabled while a core is in a boosted P-state, the core automatically transitions to the highest performance non-boosted P-state." />
      <field name="TscFreqSel" bit="24" size="1" desc="TSC frequency select. Read-only. Reset: 1. 1=The TSC increments at the P0 frequency." />
      <!-- Bits 23:22 reserved. -->
      <field name="LockTscToCurrentP0" bit="21" size="1" desc="lock the TSC to the current P0 frequency. Read-write. Reset: 0. 0=The TSC will count at the P0 frequency. 1=The TSC frequency is locked to the current P0 frequency at the time this bit is set and remains fixed regardless of future changes to the P0 frequency." />
      <field name="IoCfgGpFault" bit="20" size="1" desc="IO-space configuration causes a GP fault. Read-write. Reset: 0. 1=IO-space accesses to configuration space cause a GP fault. The fault is triggered if any part of the IO Read/Write address range is between CF8h and CFFh, inclusive. These faults only result from single IO instructions, not to string and REP IO instructions. This fault takes priority over the IO trap mechanism described by Core::X86::Msr::SMI_ON_IO_TRAP_CTL_STS." />
      <!-- Bit 19 reserved. -->
      <field name="McStatusWrEn" bit="18" size="1" desc="machine check status write enable. Read-write. Reset: 0. 0=MCi_STATUS registers are Readable; Writing a non-zero pattern to these registers causes a general protection fault. 1=MCi_STATUS registers are Read-write, including Reserved fields; do not cause general protection faults; such Writes update all implemented bits in these registers; All fields of all threshold registers are Read-write when accessed from MSR space, including Locked, except BlkPtr which is always Read-only; McStatusWrEn does not change the access type for the thresholding registers accessed via configuration space. Description: McStatusWrEn can be used to debug machine check exception and interrupt handlers. See 3.1 [Machine Check Architecture]." />
      <field name="Wrap32Dis" bit="17" size="1" desc="32-bit address wrap disable. Read-write. Reset: 0. 1=Disable 32-bit address wrapping. Software can use Wrap32Dis to access physical memory above 4 Gbytes without switching into 64-bit mode. To do so, software should write a greater-than 4-Gbyte address to Core::X86::Msr::FS_BASE and Core::X86::Msr::GS_BASE. Then it would address ±2 Gbytes from one of those bases using normal memory reference instructions with a FS or GS override prefix. However, the INVLPG, FST, and SSE store instructions generate 32-bit addresses in legacy mode, regardless of the state of Wrap32Dis." />
      <!-- Bits 16:15 reserved. -->
      <field name="RsmSpCycDis" bit="14" size="1" desc="RSM special bus cycle disable. Reset: 0. 0=A link special bus cycle, SMIACK, is generated on a resume from SMI. AccessType: Core::X86::Msr::HWCR[SmmLock] ? Read-only : Read-write." />
      <field name="SmiSpCycDis" bit="13" size="1" desc="SMI special bus cycle disable. Reset: 0. 0=A link special bus cycle, SMIACK, is generated when an SMI interrupt is taken. AccessType: Core::X86::Msr::HWCR[SmmLock] ? Read-only : Read-write." />
      <!-- Bits 12:11 reserved. -->
      <field name="MonMwaitUserEn" bit="10" size="1" desc="MONITOR/MWAIT user mode enable. Read-write. Reset: 0. 0=The MONITOR and MWAIT instructions are supported only in privilege level 0; these instructions in privilege levels 1 to 3 cause a #UD exception. 1=The MONITOR and MWAIT instructions are supported in all privilege levels. The state of this bit is ignored if MonMwaitDis is set." />
      <field name="MonMwaitDis" bit="9" size="1" desc="MONITOR and MWAIT disable. Read-write. Reset: 0. 1=The MONITOR and MWAIT opcodes become invalid. This affects what is reported back through Core::X86::Cpuid::FeatureIdEcx[Monitor]." />
      <field name="IgnneEm" bit="8" size="1" desc="IGNNE port emulation enable. Read-write. Reset: 0. 1=Enable emulation of IGNNE port." />
      <field name="AllowFerrOnNe" bit="7" size="1" desc="allow FERR on NE. Read-write. Reset: 0. 0=Disable legacy FERR signaling and generate FERR exception directly. 1=Legacy FERR signaling." />
      <!-- Bits 6:5 reserved. -->
      <field name="INVDWBINVD" bit="4" size="1" desc="INVD to WBINVD conversion. Read-write. Reset: 1. 1=Convert INVD to WBINVD." />
      <field name="TlbCacheDis" bit="3" size="1" desc="cacheable memory disable. Read-write. Reset: 0. 1=Disable performance improvement that assumes that the PML4, PDP, PDE and PTE entries are in cacheable WB DRAM. Description: Operating systems that maintain page tables in any other memory type must set the TlbCacheDis bit to insure proper operation. • TlbCacheDis does not override the memory type specified by the SMM ASeg and TSeg memory regions controlled by Core::X86::Msr::SMMAddr Core::X86::Msr::SMMMask." />
      <!-- Bits 2:1 reserved. -->
      <field name="SmmLock" bit="0" size="1" desc="SMM code lock. Read,Write-1-only. Reset: 0. Init: BIOS,1. 1=SMM code in the ASeg and TSeg range and the SMM registers are Read-only and SMI interrupts are not intercepted in SVM. See 2.1.11.1.10 [Locking SMM]." />
    </register>

    <!-- page 139 -->

    <!-- TODO Multiple MSR instances, skipping MSRC001_0018 -->
    <register name="IORR_BASE" type="msr" msr="0xC0010016" desc="IO Range Base. Read-write. Core::X86::Msr::IORR_BASE and Core::X86::Msr::IORR_MASK combine to specify the two sets of base and mask pairs for two IORR ranges. A core access, with address CPUAddr, is determined to be within IORR address range if the following equation is true: CPUAddr[47:12] &amp; PhyMask[47:12] == PhyBase[47:12] &amp; PhyMask[47:12]. BIOS can use the IORRs to create an IO hole within a range of addresses that would normally be mapped to DRAM. It can also use the IORRs to re-assert a DRAM destination for a range of addresses that fall within a bigger IO hole that overlays DRAM.">
      <!-- Bits 63:48 reserved. -->
      <field name="PhyBase" bit="12" size="36" desc="physical base address. Read-write. Reset: X_XXXX_XXXXh." />
      <!-- Bits 11:5 reserved. -->
      <field name="RdMem" bit="4" size="1" desc="read from memory. Read-write. Reset: X. 0=Read accesses to the range are directed to IO. 1=Read accesses to the range are directed to system memory." />
      <field name="WrMem" bit="3" size="1" desc="write to memory. Read-write. Reset: X. 0=Write accesses to the range are directed to IO. 1=Write accesses to the range are directed to system memory." />
      <!-- Bits 2:0 reserved. -->
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC001_0019 -->
    <register name="IORR_MASK" type="msr" msr="0xC0010017" desc="IO Range Mask. Read-write. Reset: 0000_0000_0000_0000h. See Core::X86::Msr::IORR_BASE.">
      <!-- Bits 63:48 reserved. -->
      <field name="PhyMask" bit="12" size="36" desc="physical address mask. Read-write. Reset: 0_0000_0000h." />
      <field name="Valid" bit="11" size="1" desc="Read-write. Reset: 0. 1=The pair of registers that specifies an IORR range is valid." />
      <!-- Bits 10:0 reserved. -->
    </register>

    <!-- page 140 -->

    <register name="TOP_MEM" type="msr" msr="0xC001001A" desc="Top Of Memory. Read-write.">
      <!-- Bits 63:48 reserved. -->
      <field name="TOM[47:23]" bit="23" size="25" desc="top of memory. Read-write. Reset: XXX_XXXXh. Specifies the address that divides between MMIO and DRAM. This value is normally placed below 4-GB. From TOM to (4-GB - 1) is MMIO; below TOM is DRAM. See 2.1.5.3 [System Address Map]." />
      <!-- Bits 22:0 reserved. -->
    </register>
    <register name="TOM2" type="msr" msr="0xC001001D" desc="Top Of Memory 2. Read-write.">
      <!-- Bits 63:48 reserved. -->
      <field name="TOM2[47:23]" bit="23" size="25" desc="second top of memory. Read-write. Reset: XXX_XXXXh. Specifies the address divides between MMIO and DRAM. This value is normally placed above 4 GBs. From 4-GB to (TOM2 - 1) is DRAM; TOM2 and above is MMIO. See 2.1.5.3 [System Address Map]. This register is enabled by Core::X86::Msr::SYS_CFG[MtrrTom2En]." />
      <!-- Bits 22:0 reserved. -->
    </register>
    <register name="McExcepRedir" type="msr" msr="0xC0010022" desc="Machine Check Exception Redirection. Read-write. Reset: 0000_0000_0000_0000h. This register can be used to redirect machine check exceptions (MCEs) to SMIs or vectored interrupts. If both RedirSmiEn and RedirVecEn are set, then undefined behavior results.">
      <!-- Bits 63:10 reserved. -->
      <field name="RedirSmiEn" bit="9" size="1" desc="Read-write. Reset: 0. 1=Redirect MCEs (that are directed to this core) to generate an SMI-trigger IO cycle via Core::X86::Msr::SmiTrigIoCycle. The status is stored in Core::X86::Smm::LocalSmiStatus[MceRedirSts]." />
      <field name="RedirVecEn" bit="8" size="1" desc="Read-write. Reset: 0. 1=Redirect MCEs (that are directed to this core) to generate a vectored interrupt, using the interrupt vector specified in RedirVector." />
      <field name="RedirVector" bit="0" size="8" desc="Read-write. Reset: 00h. See RedirVecEn." />
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC001_0031 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0032 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0033 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0034 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0035 -->
    <register name="ProcNameString" type="msr" msr="0xC0010030" desc="Processor Name String. Read-write. These 6 registers hold the CPUID name string in ASCII. The state of these registers are returned by CPUID instructions, Core::X86::Cpuid::ProcNameStr0Eax through Core::X86::Cpuid::ProcNameStr2Edx. BIOS should set these registers to the product name for the processor as provided by AMD. Each register contains a block of 8 ASCII characters; the least byte corresponds to the first ASCII character of the block; the most-significant byte corresponds to the last character of the block. MSRC001_0030 contains the first block of the name string; MSRC001_0035 contains the last block of the name string.">
      <field name="CpuNameString7" bit="56" size="8" desc="Read-write. Reset: XXh." />
      <field name="CpuNameString6" bit="48" size="8" desc="Read-write. Reset: XXh." />
      <field name="CpuNameString5" bit="40" size="8" desc="Read-write. Reset: XXh." />
      <field name="CpuNameString4" bit="32" size="8" desc="Read-write. Reset: XXh." />
      <field name="CpuNameString3" bit="24" size="8" desc="Read-write. Reset: XXh." />
      <field name="CpuNameString2" bit="16" size="8" desc="Read-write. Reset: XXh." />
      <field name="CpuNameString1" bit="8" size="8" desc="Read-write. Reset: XXh." />
      <field name="CpuNameString0" bit="0" size="8" desc="Read-write. Reset: XXh." />
    </register>

    <!-- page 141 -->

    <!-- TODO Multiple MSR instances, skipping MSRC001_0051 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0052 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0053 -->
    <register name="SMI_ON_IO_TRAP" type="msr" msr="0xC0010050" desc="IO Trap. Read-write. Reset: 0000_0000_0000_0000h. Core::X86::Msr::SMI_ON_IO_TRAP and Core::X86::Msr::SMI_ON_IO_TRAP_CTL_STS provide a mechanism for executing the SMI handler if a an access to one of the specified addresses is detected. Access address and access type checking is performed before IO instruction execution. If the access address and access type match one of the specified IO address and access types, then: (1) the IO instruction is not executed; (2) any breakpoint, other than the single-step breakpoint, set on the IO instruction is not taken (the single-step breakpoint is taken after resuming from SMM); and (3) issue the SMI-trigger IO cycle specified by Core::X86::Msr::SmiTrigIoCycle if enabled. The status is stored in Core::X86::Smm::LocalSmiStatus[IoTrapSts]. IO-space configuration accesses are special IO accesses. An IO access is defined as an IO-space configuration access when IO instruction address bits[31:0] are CFCh, CFDh, CFEh, or CFFh when IO-space configuration is enabled (IO::IoCfgAddr[ConfigEn]). The access address for a configuration space access is the current value of IO::IoCfgAddr[BusNo,Device,Function,RegNo]. The access address for an IO access that is not a configuration access is equivalent to the IO instruction address, bits[31:0]. The access address is compared with SmiAddr, and the instruction access type is compared with the enabled access types defined by ConfigSMI, SmiOnRdEn, and SmiOnWrEn. Access address bits[23:0] can be masked with SmiMask. IO and configuration space trapping to SMI applies only to single IO instructions; it does not apply to string and REP IO instructions. The conditional GP fault described by Core::X86::Msr::HWCR[IoCfgGpFault] takes priority over this trap.">
      <field name="SmiOnRdEn" bit="63" size="1" desc="enable SMI on IO read. Read-write. Reset: 0. 1=Enables SMI generation on a Read access." />
      <field name="SmiOnWrEn" bit="62" size="1" desc="enable SMI on IO write. Read-write. Reset: 0. 1=Enables SMI generation on a Write access." />
      <field name="ConfigSmi" bit="61" size="1" desc="configuration space SMI. Read-write. Reset: 0. 0=IO access (that is not an IO-space configuration access). 1=Configuration access." />
      <!-- Bits 60:56 reserved. -->
      <field name="SmiMask[23:0]" bit="32" size="24" desc="Read-write. Reset: 00_0000h. 1=Do not mask address bit. 0=Mask address bit. SMI IO trap mask." />
      <field name="SmiAddr[31:0]" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. SMI IO trap address." />
    </register>
    <register name="SMI_ON_IO_TRAP_CTL_STS" type="msr" msr="0xC0010054" desc="IO Trap Control.">
      <!-- Bits 63:16 reserved. -->
      <field name="IoTrapEn" bit="15" size="1" desc="IO trap enable. Read-write. Reset: 0. 1=Enable IO and configuration space trapping specified by Core::X86::Msr::SMI_ON_IO_TRAP and Core::X86::Msr::SMI_ON_IO_TRAP_CTL_STS." />
      <!-- Bits 14:8 reserved. -->
      <field name="SmiEn3" bit="7" size="1" desc="Read-write. Reset: 0. 1=The trap Core::X86::Msr::SMI_ON_IO_TRAP_n[3] is enabled." />
      <!-- Bit 6 reserved. -->
      <field name="SmiEn2" bit="5" size="1" desc="Read-write. Reset: 0. 1=The trap Core::X86::Msr::SMI_ON_IO_TRAP_n[2] is enabled." />
      <!-- Bit 4 reserved. -->
      <field name="SmiEn1" bit="3" size="1" desc="Read-write. Reset: 0. 1=The trap Core::X86::Msr::SMI_ON_IO_TRAP_n[1] is enabled." />
      <!-- Bit 2 reserved. -->
      <field name="SmiEn0" bit="1" size="1" desc="Read-write. Reset: 0. 1=The trap Core::X86::Msr::SMI_ON_IO_TRAP_n[0] is enabled." />
      <!-- Bit 0 reserved. -->
    </register>

    <!-- page 142 -->

    <register name="IntPend" type="msr" msr="0xC0010055" desc="Reserved.. Read-only. Reset: Fixed,0000_0000_0000_0000h.">
      <!-- Bits 63:0 reserved. -->
    </register>
    <register name="SmiTrigIoCycle" type="msr" msr="0xC0010056" desc="SMI Trigger IO Cycle. Read-write. Reset: 0000_0000_0000_0000h. See 2.1.11.1.3 [SMI Sources And Delivery]. This register specifies an IO cycle that may be generated when a local SMI trigger event occurs. If IoCycleEn is set and there is a local SMI trigger event, then the IO cycle generated is a byte Read or Write, based on IoRd, to address IoPortAddress. If the cycle is a Write, then IoData contains the data written. If the cycle is a Read, the value read is discarded. If IoCycleEn is clear and a local SMI trigger event occurs, then undefined behavior results.">
      <!-- Bits 63:27 reserved. -->
      <field name="IoRd" bit="26" size="1" desc="IO Read. Read-write. Reset: 0. 0=IO Write. 1=IO Read." />
      <field name="IoCycleEn" bit="25" size="1" desc="IO cycle enable. Read-write. Reset: 0. 1=The SMI trigger IO cycle is enabled to be generated." />
      <!-- Bit 24 reserved. -->
      <field name="IoData" bit="16" size="8" desc="Read-write. Reset: 00h." />
      <field name="IoPortAddress" bit="0" size="16" desc="Read-write. Reset: 0000h." />
    </register>
    <register name="MmioCfgBaseAddr" type="msr" msr="0xC0010058" desc="MMIO Configuration Base Address. See 2.1.6 [Configuration Space] for a description of MMIO configuration space.">
      <!-- Bits 63:48 reserved. -->
      <field name="MmioCfgBaseAddr[47:20]" bit="20" size="28" desc="MMIO configuration base address bits[47:20]. Read-write. Reset: XXX_XXXXh. Specifies the base address of the MMIO configuration range." />
      <!-- Bits 19:6 reserved. -->
      <field name="BusRange" bit="2" size="4" desc="bus range identifier. Read-write. Reset: 0h. Specifies the number of buses in the MMIO configuration space range. The size of the MMIO configuration space is 1-MB times the number of buses." />
      <!-- Bit 1 reserved. -->
      <field name="Enable" bit="0" size="1" desc="Read-write. Reset: 0. 1=MMIO configuration space is enabled." />
    </register>

    <!-- page 143 -->

    <register name="PStateCurLim" type="msr" msr="0xC0010061" desc="P-state Current Limit.">
      <!-- Bits 63:7 reserved. -->
      <field name="PstateMaxVal" bit="4" size="3" desc="P-state maximum value. Read,Error-on-write,Volatile. Reset: XXXb. Specifies the lowest- performance non-boosted P-state (highest non-boosted value) allowed. Attempts to change Core::X86::Msr::PStateCtl[PstateCmd] to a lower-performance P-state (higher value) are clipped to the value of this field." />
      <!-- Bit 3 reserved. -->
      <field name="CurPstateLimit" bit="0" size="3" desc="current P-state limit. Read,Error-on-write,Volatile. Reset: XXXb. Specifies the highest- performance P-state (lowest value) allowed. CurPstateLimit is always bounded by Core::X86::Msr::PStateCurLim[PstateMaxVal]. Attempts to change the CurPstateLimit to a value greater (lower performance) than Core::X86::Msr::PStateCurLim[PstateMaxVal] leaves CurPstateLimit unchanged." />
    </register>
    <register name="PStateCtl" type="msr" msr="0xC0010062" desc="P-state Control.">
      <!-- Bits 63:3 reserved. -->
      <field name="PstateCmd" bit="0" size="3" desc="P-state change command. Read-write. Reset: XXXb. Cold reset value varies by product; after a warm reset, value initializes to the P-state the core was in prior to the reset. Writes to this field cause the core to change to the indicated non-boosted P-state number, specified by Core::X86::Msr::PStateDef. 0=P0, 1=P1, etc. P- state limits are applied to any P-state requests made through this register. Reads from this field return the last written value, regardless of whether any limits are applied." />
    </register>
    <register name="PStateStat" type="msr" msr="0xC0010063" desc="P-state Status. Read,Error-on-write,Volatile.">
      <!-- Bits 63:3 reserved. -->
      <field name="CurPstate" bit="0" size="3" desc="current P-state. Read,Error-on-write,Volatile. Reset: XXXb. This field provides the frequency component of the current non-boosted P-state of the core (regardless of the source of the P-state change, including Core::X86::Msr::PStateCtl[PstateCmd]. 0=P0, 1=P1, etc. The value of this field is updated when the COF transitions to a new value associated with a P-state." />
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC001_0065 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0066 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0067 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0068 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0069 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_006A -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_006B -->
    <register name="PStateDef" type="msr" msr="0xC0010064" desc="P-state [7:0]. Read-write. Each of these registers specify the frequency and voltage associated with each of the core P-states. The CpuVid field in these registers is required to be programmed to the same value in all cores of a processor, but are allowed to be different between processors in a multi-processor system. All other fields in these registers are required to be programmed to the same value in each core of the coherent fabric.">
      <field name="PstateEn" bit="63" size="1" desc="Read-write. Reset: X. 0=The P-state specified by this MSR is not valid. 1=The P-state specified by this MSR is valid. The purpose of this register is to indicate if the rest of the P-state information in the register is valid after a reset; it controls no hardware." />
      <!-- Bits 62:32 reserved. -->
      <field name="IddDiv" bit="30" size="2" desc="current divisor. Read-write. Reset: XXb. See IddValue." />
      <field name="IddValue" bit="22" size="8" desc="current value. Read-write. Reset: XXXXXXXXb. After a reset, IddDiv and IddValue combine to  specify the expected maximum current dissipation of a single core that is in the P-state corresponding to the MSR number. These values are intended to be used to create ACPI-defined _PSS objects. The values are expressed in amps; they are not intended to convey final product power levels; they may not match the power levels specified in the Power and Thermal Datasheets." />
      <field name="CpuVid[7:0]" bit="14" size="8" desc="core VID. Read-write. Reset: XXXXXXXXb." />
      <field name="CpuDfsId" bit="8" size="6" desc="core divisor ID. Read-write. Reset: XXXXXXb. Specifies the core frequency divisor; see CpuFid. For values [1Ah:08h], 1/8th integer divide steps supported down to VCO/3.25 (Note, L3/L2 FIFO logic related to 4-cycle data heads-up requires core to be 1/3 of L3 frequency or higher). For values [30h:1Ch], 1/4th integer divide steps supported down to VCO/6 (DID[0] should zero if DID[5:0] > 1Ah). (Note, core and L3 frequencies below 400MHz are not supported by the architecture). Core supports DID up to 30h, but L3 must be 2Ch (VCO/5.5) or less." />
      <field name="CpuFid[7:0]" bit="0" size="8" desc="core frequency ID. Read-write. Reset: XXh. Specifies the core frequency multiplier. The core COF is a function of CpuFid and CpuDid, and defined by CoreCOF." />
    </register>

    <!-- page 145 -->

    <register name="CStateBaseAddr" type="msr" msr="0xC0010073" desc="C-state Base Address. Read-write. Reset: 0000_0000_0000_0000h.">
      <!-- Bits 63:16 reserved. -->
      <field name="CstateAddr" bit="0" size="16" desc="C-state address. Read-write. Reset: 0000h. Specifies the IO addresses trapped by the core for C- state entry requests. A value of 0 in this field specifies that the core does not trap any IO addresses for C-state entry. Writing values greater than FFF8h into this field result in undefined behavior. All other values cause the core to trap IO addresses CstateAddr through CstateAddr + 7." />
    </register>
    <register name="CpuWdtCfg" type="msr" msr="0xC0010074" desc="CPU Watchdog Timer. Read-write. Reset: 0000_0000_0000_0000h.">
      <!-- Bits 63:7 reserved. -->
      <field name="CpuWdtCountSel" bit="3" size="4" desc="CPU watchdog timer count select. Read-write. Reset: 0h. CpuWdtCountSel and CpuWdtTimeBase together specify the time period required for the WDT to expire. The time period is ((the multiplier specified by CpuWdtCountSel) * (the time base specified by CpuWdtTimeBase)). The actual timeout period may be anywhere from zero to one increment less than the values specified, due to non-deterministic behavior." />
      <field name="CpuWdtTimeBase" bit="1" size="2" desc="CPU watchdog timer time base. Read-write. Reset: 0h. Specifies the time base for the timeout period specified in CpuWdtCountSel." />
      <field name="CpuWdtEn" bit="0" size="1" desc="CPU watchdog timer enable. Read-write. Reset: 0. Init: BIOS,1. 1=The WDT is enabled." />
    </register>

    <!-- page 146 -->

    <register name="SMM_BASE" type="msr" msr="0xC0010111" desc="SMM Base Address. Reset: 0000_0000_0003_0000h. This holds the base of the SMM memory region. The value of this register is stored in the save state on entry into SMM (see 2.1.11.1.5 [SMM Save State]) and it is restored on returning from SMM. The 16-bit CS (code segment) selector is loaded with SmmBase[19:4] on entering SMM. SmmBase[3:0] is required to be 0. The SMM base address can be changed in two ways: • The SMM base address, at offset FF00h in the SMM state save area, may be changed by the SMI handler. The RSM instruction updates SmmBase with the new value. • Normal WRMSR access to this register.">
      <!-- Bits 63:32 reserved. -->
      <field name="SmmBase" bit="0" size="32" desc="Reset: 0003_0000h. AccessType: Core::X86::Msr::HWCR[SmmLock] ? Read-only : Read-write." />
    </register>
    <register name="SMMAddr" type="msr" msr="0xC0010112" desc="SMM TSeg Base Address. Configurable. Reset: 0000_0000_0000_0000h. See 2.1.11.1 [System Management Mode (SMM)] and 2.1.5.3.1 [Memory Access to the Physical Address Space]. See Core::X86::Msr::SMMMask for more information about the ASeg and TSeg address ranges. Each CPU access, directed at CPUAddr, is determined to be in the TSeg range if the following is true: CPUAddr[47:17] &amp; TSegMask[47:17] == TSegBase[47:17] &amp; TSegMask[47:17]. For example, if TSeg spans 256 KBs and starts at the 1-MB address. The Core::X86::Msr::SMMAddr[TSegBase[47:17]] would be set to 0010_0000h and the Core::X86::Msr::SMMMask[TSegMask[47:17]] to FFFC_0000h (with zeros filling in for bits[16:0]). This results in a TSeg range from 0010_0000 to 0013_FFFFh.">
      <!-- Bits 63:48 reserved. -->
      <field name="TSegBase[47:17]" bit="17" size="31" desc="TSeg address range base. Configurable. Reset: 0000_0000h. AccessType: (Core::X86::Msr::HWCR[SmmLock]) ? Read-only : Read-write." />
      <!-- Bits 16:0 reserved. -->
    </register>
    <register name="SMMMask" type="msr" msr="0xC0010113" desc="SMM TSeg Mask. Configurable. Reset: 0000_0000_0000_0000h. See 2.1.11.1 [System Management Mode (SMM)]. The ASeg address range is located at a fixed address from A0000h–BFFFFh. The TSeg range is located at a variable base (specified by Core::X86::Msr::SMMAddr[TSegBase[47:17]]) with a variable size (specified by Core::X86::Msr::SMMMask[TSegMask[47:17]]). These ranges provide a safe location for SMM code and data that is not readily accessible by non-SMM applications. The SMI handler can be located in one of these two ranges, or it can be located outside these ranges. These ranges must never overlap each other. This register specifies how accesses to the ASeg and TSeg address ranges are controlled as follows: • If [A,T]Valid == 1, then: • If in SMM, then: • If [A, T]Close == 0, then the accesses are directed to DRAM with memory type as specified in [A, T]MTypeDram. • If [A, T]Close == 1, then instruction accesses are directed to DRAM with memory type as specified in [A, T]MTypeDram and data accesses are directed at MMIO space and with attributes based on [A, T]MTypeIoWc. • If not in SMM, then the accesses are directed at MMIO space with attributes based on [A,T]MTypeIoWc. • See 2.1.5.3.1.1 [Determining Memory Type].">
      <!-- Bits 63:48 reserved. -->
      <field name="TSegMask[47:17]" bit="17" size="31" desc="TSeg address range mask. Configurable. Reset: 0000_0000h. See Core::X86::Msr::SMMAddr. AccessType: (Core::X86::Msr::HWCR[SmmLock]) ? Read-only : Read-write." />
      <!-- Bits 16:15 reserved. -->
      <field name="TMTypeDram" bit="12" size="3" desc="TSeg address range memory type. Configurable. Reset: 0h. Specifies the memory type for SMM accesses to the TSeg range that are directed to DRAM. AccessType: (Core::X86::Msr::HWCR[SmmLock]) ? Read-only : Read-write.  " />
      <!-- Bit 11 reserved. -->
      <field name="AMTypeDram" bit="8" size="3" desc="ASeg Range Memory Type. Configurable. Reset: 0h. Specifies the memory type for SMM accesses to the ASeg range that are directed to DRAM. AccessType: (Core::X86::Msr::HWCR[SmmLock]) ? Read-only : Read-write." />
      <!-- Bits 7:6 reserved. -->
      <field name="TMTypeIoWc" bit="5" size="1" desc="non-SMM TSeg address range memory type. Configurable. Reset: 0. 0=UC (uncacheable). 1=WC (write combining). Specifies the attribute of TSeg accesses that are directed to MMIO space. AccessType: (Core::X86::Msr::HWCR[SmmLock]) ? Read-only : Read-write." />
      <field name="AMTypeIoWc" bit="4" size="1" desc="non-SMM ASeg address range memory type. Configurable. Reset: 0. 0=UC (uncacheable). 1=WC (write combining). Specifies the attribute of ASeg accesses that are directed to MMIO space. AccessType: (Core::X86::Msr::HWCR[SmmLock]) ? Read-only : Read-write." />
      <field name="TClose" bit="3" size="1" desc="send TSeg address range data accesses to MMIO. Configurable. Reset: 0. 1=When in SMM, direct data accesses in the TSeg address range to MMIO space. See AClose. AccessType: (Core::X86::Msr::HWCR[SmmLock]) ? Read-only : Read-write." />
      <field name="AClose" bit="2" size="1" desc="send ASeg address range data accesses to MMIO. Configurable. Reset: 0. 1=When in SMM, direct data accesses in the ASeg address range to MMIO space. [A,T]Close allows the SMI handler to access the MMIO space located in the same address region as the [A,T]Seg. When the SMI handler is finished accessing the MMIO space, it must clear the bit. Failure to do so before resuming from SMM causes the CPU to erroneously read the save state from MMIO space. AccessType: (Core::X86::Msr::HWCR[SmmLock]) ? Read-only : Read-write." />
      <field name="TValid" bit="1" size="1" desc="enable TSeg SMM address range. Configurable. Reset: 0. 1=The TSeg address range SMM enabled. AccessType: (Core::X86::Msr::HWCR[SmmLock]) ? Read-only : Read-write." />
      <field name="AValid" bit="0" size="1" desc="enable ASeg SMM address range. Configurable. Reset: 0. 1=The ASeg address range SMM enabled. AccessType: (Core::X86::Msr::HWCR[SmmLock]) ? Read-only : Read-write." />
    </register>

    <!-- page 147 -->

    <register name="VM_CR" type="msr" msr="0xC0010114" desc="Virtual Machine Control. Reset: 0000_0000_0000_0000h.">
      <!-- Bits 63:5 reserved. -->
      <field name="SvmeDisable" bit="4" size="1" desc="SVME disable. Configurable. Reset: 0. 0=Core::X86::Msr::EFER[SVME] is Read-write. 1=Core::X86::Msr::EFER[SVME] is Read-only,Error-on-write-1. See Lock for the access type of this field. Attempting to set this field when (Core::X86::Msr::EFER[SVME] == 1) causes a #GP fault, regardless of the   state of Lock. See the docAPM2 section titled &quot;Enabling SVM&quot; for software use of this field." />
      <field name="Lock" bit="3" size="1" desc="SVM lock. Read-only,Volatile. Reset: 0. 0=SvmeDisable is Read-write. 1=SvmeDisable is Read-only. See Core::X86::Msr::SvmLockKey[SvmLockKey] for the condition that causes hardware to clear this field." />
      <!-- Bit 2 reserved. -->
      <field name="InterceptInit" bit="1" size="1" desc="intercept INIT. Read-write,Volatile. Reset: 0. 0=INIT delivered normally. 1=INIT translated into a SX interrupt. This bit controls how INIT is delivered in host mode. This bit is set by hardware when the SKINIT instruction is executed." />
      <!-- Bit 0 reserved. -->
    </register>

    <!-- page 148 -->

    <register name="IGNNE" type="msr" msr="0xC0010115" desc="IGNNE. Reset: 0000_0000_0000_0000h.">
      <!-- Bits 63:1 reserved. -->
      <field name="IGNNE" bit="0" size="1" desc="current IGNNE state. Read-write. Reset: 0. This bit controls the current state of the processor internal IGNNE signal." />
    </register>
    <register name="SMM_CTL" type="msr" msr="0xC0010116" desc="SMM Control. Reset: 0000_0000_0000_0000h. The bits in this register are processed in the order of: SmmEnter, SmiCycle, SmmDismiss, RsmCycle and SmmExit. However, only the following combination of bits may be set in a single Write (all other combinations result in undefined behavior): • SmmEnter and SmiCycle. • SmmEnter and SmmDismiss. • SmmEnter, SmiCycle and SmmDismiss. • SmmExit and RsmCycle. Software is responsible for ensuring that SmmEnter and SmmExit operations are properly matched and are not nested.">
      <!-- Bits 63:5 reserved. -->
      <field name="RsmCycle" bit="4" size="1" desc="send RSM special cycle. Reset: 0. 1=Send a RSM special cycle. AccessType: Core::X86::Msr::HWCR[SmmLock] ? Error-on-read,Error-on-write : Write-only,Error-on-read." />
      <field name="SmmExit" bit="3" size="1" desc="exit SMM. Reset: 0. 1=Exit SMM. AccessType: Core::X86::Msr::HWCR[SmmLock] ? Error-on-read,Error-on-write : Write-only,Error-on-read." />
      <field name="SmiCycle" bit="2" size="1" desc="send SMI special cycle. Reset: 0. 1=Send a SMI special cycle. AccessType: Core::X86::Msr::HWCR[SmmLock] ? Error-on-read,Error-on-write : Write-only,Error-on-read." />
      <field name="SmmEnter" bit="1" size="1" desc="enter SMM. Reset: 0. 1=Enter SMM. AccessType: Core::X86::Msr::HWCR[SmmLock] ? Error-on-read,Error-on-write : Write-only,Error-on-read." />
      <field name="SmmDismiss" bit="0" size="1" desc="clear SMI. Reset: 0. 1=Clear the SMI pending flag. AccessType: Core::X86::Msr::HWCR[SmmLock] ? Error-on-read,Error-on-write : Write-only,Error-on-read." />
    </register>
    <register name="VM_HSAVE_PA" type="msr" msr="0xC0010117" desc="Virtual Machine Host Save Physical Address. Reset: 0000_0000_0000_0000h.">
      <!-- Bits 63:48 reserved. -->
      <field name="VM_HSAVE_PA" bit="12" size="36" desc="physical address of host save area. Read-write. Reset: 0_0000_0000h. This register contains the physical address of a 4-KB region where VMRUN saves host state and where vm-exit restores host state from. Writing this register causes a #GP if (FFFF_FFFF_Fh >= VM_HSAVE_PA >= FFFD_0000_0h) or if either the TSEG or ASEG regions overlap with the range defined by this register." />
      <!-- Bits 11:0 reserved. -->
    </register>

    <!-- page 149 -->

    <register name="SvmLockKey" type="msr" msr="0xC0010118" desc="SVM Lock Key. Read-write. Reset: Fixed,0000_0000_0000_0000h.">
      <field name="SvmLockKey" bit="0" size="64" desc="SVM lock key. Read-write. Reset: Fixed,0000_0000_0000_0000h. Writes to this register when (Core::X86::Msr::VM_CR[Lock] == 0) modify SvmLockKey. If ((Core::X86::Msr::VM_CR[Lock] == 1) &amp;&amp; (SvmLockKey != 0) &amp;&amp; (The Write value == The value stored in SvmLockKey)) for a Write to this register then hardware updates Core::X86::Msr::VM_CR[Lock] = 0." />
    </register>
    <register name="LocalSmiStatus" type="msr" msr="0xC001011A" desc="Local SMI Status. Read-write. Reset: 0000_0000_0000_0000h. This register returns the same information that is returned in Core::X86::Smm::LocalSmiStatus portion of the SMM save state. The information in this register is only updated when Core::X86::Msr::SMM_CTL[SmmDismiss] is set by software.">
      <!-- Bits 63:32 reserved. -->
      <field name="LocalSmiStatus" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. See Core::X86::Smm::LocalSmiStatus." />
    </register>
    <register name="AvicDoorbell" type="msr" msr="0xC001011B" desc="AVIC Doorbell. Reset: 0000_0000_0000_0000h. The ApicId is a physical APIC Id; not valid for logical APIC ID. See Core::X86::Cpuid::SvmRevFeatIdEdx[AVIC].">
      <!-- Bits 63:8 reserved. -->
      <field name="ApicId" bit="0" size="8" desc="APIC ID [7:0]. Write-only,Error-on-read. Reset: 00h." />
    </register>
    <register name="VMPAGE_FLUSH" type="msr" msr="0xC001011E" desc="VM Page Flush. Writes to this MSR cause 4 KBs of encrypted, guest-tagged data to be flushed from caches if present.">
      <field name="VirtualAddr" bit="12" size="52" desc="Reset: X_XXXX_XXXX_XXXXh. Guest physical address of page to flush. AccessType: Core::X86::Msr::SYS_CFG[SMEE] ? Write-only,Error-on-read : Error-on-read,Error-on-write." />
      <field name="ASID" bit="0" size="12" desc="Reset: XXXh. ASID to use for flush. Writing reserved values generates #GP. AccessType: Core::X86::Msr::SYS_CFG[SMEE] ? Write-only,Error-on-read : Error-on-read,Error-on-write." />
    </register>
    <register name="GHCB" type="msr" msr="0xC0010130" desc="Guest Host Communication Block. Read-write. Reset: 0000_0000_0000_0000h. If Core::X86::Msr::GHCB is accessed in hypervisor mode, #GP is generated.">
      <field name="GHCBPA" bit="0" size="64" desc="Read-write. Reset: 0000_0000_0000_0000h. Guest physical address of GHCB." />
    </register>
    <register name="SEV_Status" type="msr" msr="0xC0010131" desc="SEV Status. Read,Error-on-write. Reset: 0000_0000_0000_0000h.">
      <!-- Bits 63:2 reserved. -->
      <field name="SevEsEnabled" bit="1" size="1" desc="Read,Error-on-write. Reset: 0. 1=The guest was launched with the Sev-ES feature enabled in VMCB offset 90h." />
      <field name="SevEnabled" bit="0" size="1" desc="Read,Error-on-write. Reset: 0. 1=The guest was launched with SEV feature enabled in VMCB   offset 90h." />
    </register>

    <!-- page 150 -->

    <register name="OSVW_ID_Length" type="msr" msr="0xC0010140" desc="OS Visible Work-around Length. Read-write. Reset: 0000_0000_0000_0000h.">
      <!-- Bits 63:16 reserved. -->
      <field name="OSVWIdLength" bit="0" size="16" desc="OS visible work-around ID length. Read-write. Reset: 0000h. See the Revision Guide for the definition of this field; see 1.2 [Reference Documents]." />
    </register>
    <register name="OSVW_Status" type="msr" msr="0xC0010141" desc="OS Visible Work-around Status. Read-write. Reset: 0000_0000_0000_0000h.">
      <field name="OsvwStatusBits" bit="0" size="64" desc="OS visible work-around status bits. Read-write. Reset: 0000_0000_0000_0000h. See the Revision Guide for the definition of this field; see 1.2 [Reference Documents]." />
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC001_0202 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0204 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0206 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0208 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_020A -->
    <register name="PERF_CTL" type="msr" msr="0xC0010200" desc="Performance Event Select [5:0]. Read-write. Reset: 0000_0000_0000_0000h. See 2.1.14 [Performance Monitor Counters]. Core::X86::Msr::PERF_LEGACY_CTL is an alias of MSRC001_020[6,4,2,0].">
      <!-- Bits 63:42 reserved. -->
      <field name="HostGuestOnly" bit="40" size="2" desc="count only host/guest events. Read-write. Reset: 0h." />
      <!-- Bits 39:36 reserved. -->
      <field name="EventSelect[11:8]" bit="32" size="4" desc="performance event select. Read-write. Reset: 0h." />
      <field name="CntMask" bit="24" size="8" desc="counter mask. Read-write. Reset: 00h. Controls the number of events counted per clock cycle." />
      <field name="Inv" bit="23" size="1" desc="invert counter mask. Read-write. Reset: 0. See CntMask." />
      <field name="En" bit="22" size="1" desc="enable performance counter. Read-write. Reset: 0. 1=Performance event counter is enabled." />
      <!-- Bit 21 reserved. -->
      <field name="Int" bit="20" size="1" desc="enable APIC interrupt. Read-write. Reset: 0. 1=APIC performance counter LVT interrupt is enabled to generate an interrupt via Core::X86::Apic::PerformanceCounterLvtEntry when the performance counter overflows." />
      <!-- Bit 19 reserved. -->
      <field name="Edge" bit="18" size="1" desc="edge detect. Read-write. Reset: 0. 0=Level detect. 1=Zero-to-one Edge detect. Read-write. The edge count mode increments the counter when a transition happens on the monitored event. If the event selected is changed without disabling the counter, an extra edge is falsely detected when the first event is a static 0 and the second event is a static one. To avoid this false edge detection, disable the counter when changing the event and then enable the counter with a second MSR write." />
      <field name="OsUserMode" bit="16" size="2" desc="OS and user mode. Read-write. Reset: 0h." />
      <field name="UnitMask" bit="8" size="8" desc="event qualification. Read-write. Reset: 00h. Each UnitMask bit further specifies or qualifies the event specified by EventSelect. All events selected by UnitMask are simultaneously monitored. Unless otherwise stated, the UnitMask values shown may be combined (logically ORed) to select any desired combination of the sub-events for a given event. In some cases, certain combinations can result in misleading counts, or the UnitMask value is an ordinal rather than a bit mask. These situations are described where applicable, or should be obvious from the event descriptions. For events where no UnitMask table is shown, the UnitMask is Unused. When selecting an event for which not all UnitMask bits are defined, the undefined UnitMask bits should be set to zero." />
      <field name="EventSelect[7:0]" bit="0" size="8" desc="event select. Read-write. Reset: 00h. EventSelect[11:0] = {EventSelect[11:8], EventSelect[7:0]}. EventSelect specifies the event or event duration in a processor unit to be counted by the corresponding PERF_CTR[5:0] register. The events are specified in 2.1.14.3 [Core Performance Monitor Counters]. Some events are Reserved; when a Reserved event is selected, the results are undefined." />
    </register>

    <!-- page 151 -->

    <!-- TODO Multiple MSR instances, skipping MSRC001_0203 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0205 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0207 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0209 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_020B -->
    <register name="PERF_CTR" type="msr" msr="0xC0010201" desc="Performance Event Counter [5:0]. Note: When counting events that capable of counting greater than 15 events per cycle (MergeEvent) the even and the corresponding odd PERF_CTR must be paired to appear as a single 64 bit counter. See 2.1.14.2 [Large Increment per Cycle Events]. Core::X86::Msr::PERF_CTL. Core::X86::Msr::PERF_LEGACY_CTR is an alias of MSRC001_020[7,5,3,1]. Also can be read via x86 instructions RDPMC ECX = [05:00].">
      <!-- Bits 63:48 reserved. -->
      <field name="CTR" bit="0" size="48" desc="performance counter value. Read-write,Volatile. Reset: 0000_0000_0000h." />
    </register>

    <!-- page 152 -->

    <!-- TODO Multiple MSR instances, skipping MSRC001_0232 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0234 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0236 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0238 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_023A -->
    <register name="ChL3PmcCfg" type="msr" msr="0xC0010230" desc="L3 Performance Event Select [5:0]. Read-write. Reset: 0000_0000_0000_0000h. See 2.1.14.4 [L3 Cache Performance Monitor Counters].">
      <field name="ThreadMask" bit="56" size="8" desc="Read-write. Reset: 00h. Controls which of the up to 8 threads in the complex are being counted (Dependent upon number of cores). In non-SMT mode, thread 0 must be selected. One or more threads must be selected unless otherwise specified by the specific L3PMC event." />
      <!-- Bits 55:52 reserved. -->
      <field name="SliceMask" bit="48" size="4" desc="Read-write. Reset: 0h. Controls which L3 slices are counting this event. One or more Slices must be selected unless otherwise specified by the specific L3PMC event." />
      <!-- Bits 47:23 reserved. -->
      <field name="Enable" bit="22" size="1" desc="Enable L3 performance counter. Read-write. Reset: 0. 1=Enable." />
      <!-- Bits 21:16 reserved. -->
      <field name="UnitMask" bit="8" size="8" desc="event qualification. Read-write. Reset: 00h. Each UnitMask bit further specifies or qualifies the event specified by EventSelect. All events selected by UnitMask are simultaneously monitored. Unless otherwise stated, the UnitMask values shown may be combined (logically ORed) to select any desired combination of the sub-events for a given event. In some cases, certain combinations can result in misleading counts, or the UnitMask value is an ordinal rather than a bit mask. These situations are described where applicable, or should be obvious from the event descriptions. For events where no UnitMask table is shown, the UnitMask is Unused. When selecting an event for which not all UnitMask bits are defined, the undefined UnitMask bits should be set to zero." />
      <field name="EventSel" bit="0" size="8" desc="event select. Read-write. Reset: 00h." />
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC001_0233 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0235 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0237 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0239 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_023B -->
    <register name="ChL3Pmc" type="msr" msr="0xC0010231" desc="L3 Performance Event Counter [5:0]. Reset: 0000_0000_0000_0000h. Also can be read via x86 instructions RDPMC ECX = [0F:0A].">
      <!-- Bits 63:49 reserved. -->
      <field name="Overflow" bit="48" size="1" desc="Read-write. Reset: 0." />
      <field name="CountHi" bit="32" size="16" desc="Read-write,Volatile. Reset: 0000h." />
      <field name="CountLo" bit="0" size="32" desc="Read-write,Volatile. Reset: 0000_0000h." />
    </register>

    <!-- page 153 -->

    <!-- TODO Multiple MSR instances, skipping MSRC001_0242 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0244 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0246 -->
    <register name="DF_PERF_CTL" type="msr" msr="0xC0010240" desc="Data Fabric Performance Event Select [3:0]. Read-write. Reset: 0000_0000_0000_0000h. See 2.1.14 [Performance Monitor Counters].">
      <!-- Bits 63:61 reserved. -->
      <field name="EventSelect[13:12]" bit="59" size="2" desc="performance event select. Read-write. Reset: 0h." />
      <!-- Bits 58:36 reserved. -->
      <field name="EventSelect[11:8]" bit="32" size="4" desc="performance event select. Read-write. Reset: 0h. See EventSelect[7:0]." />
      <!-- Bits 31:23 reserved. -->
      <field name="En" bit="22" size="1" desc="enable performance counter. Read-write. Reset: 0. 1=Performance event counter is enabled." />
      <!-- Bits 21:16 reserved. -->
      <field name="UnitMask" bit="8" size="8" desc="event qualification. Read-write. Reset: 00h. Each UnitMask bit further specifies or qualifies the event specified by EventSelect. All events selected by UnitMask are simultaneously monitored." />
      <field name="EventSelect[7:0]" bit="0" size="8" desc="event select. Read-write. Reset: 00h. This field, along with EventSelect[13:12] and EventSelect[11:8] above, combine to form the 14-bit event select field, EventSelect[13:0]. EventSelect specifies the event or event duration in a processor unit to be counted by the corresponding DF_PERF_CTR[3:0] register. Some events are reserved; when a reserved event is selected, the results are undefined." />
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC001_0243 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0245 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0247 -->
    <register name="DF_PERF_CTR" type="msr" msr="0xC0010241" desc="Data Fabric Performance Event Counter [3:0]. See Core::X86::Msr::DF_PERF_CTL. Also can be read via x86 instructions RDPMC ECX = [09:06].">
      <!-- Bits 63:48 reserved. -->
      <field name="CTR[47:0]" bit="0" size="48" desc="performance counter value[47:0]. Read-write,Volatile. Reset: 0000_0000_0000h. The current value of the event counter." />
    </register>
    <register name="RAPL_PWR_UNIT" type="msr" msr="0xC0010299" desc="RAPL Power Unit. Read-only,Volatile. Reset: 0000_0000_000A_1003h.">
      <!-- Bits 63:20 reserved. -->
      <field name="TU" bit="16" size="4" desc="Time Units in seconds. Read-only,Volatile. Reset: Ah. Time information (in Seconds) is based on the multiplier, 1/ 2^TU; where TU is an unsigned integer. Default value is 1010b, indicating time unit is in 976 microseconds increment." />
      <!-- Bits 15:13 reserved. -->
      <field name="ESU" bit="8" size="5" desc="Energy Status Units. Read-only,Volatile. Reset: 10h. Energy information (in Joules) is based on the multiplier, 1/2^ESU; where ESU is an unsigned integer. Default value is 10000b, indicating energy status unit is in 15.3 micro-Joules increment." />
      <!-- Bits 7:4 reserved. -->
      <field name="PU" bit="0" size="4" desc="Power Units. Read-only,Volatile. Reset: 3h. Power information (in Watts) is based on the multiplier, 1/ 2^PU; where PU is an unsigned integer. Default value is 0011b, indicating power unit is in 1/8 Watts increment." />
    </register>

    <!-- page 154 -->

    <register name="CORE_ENERGY_STAT" type="msr" msr="0xC001029A" desc="Core Energy Status. Read-only,Volatile. Reset: 0000_0000_0000_0000h.">
      <!-- Bits 63:32 reserved. -->
      <field name="TotalEnergyConsumed" bit="0" size="32" desc="Read-only,Volatile. Reset: 0000_0000h." />
    </register>
    <register name="PKG_ENERGY_STAT" type="msr" msr="0xC001029B" desc="Package Energy Status. Read-only,Volatile. Reset: 0000_0000_0000_0000h. MSRC001_029B">
      <!-- Bits 63:32 reserved. -->
      <field name="TotalEnergyConsumed" bit="0" size="32" desc="Read-only,Volatile. Reset: 0000_0000h." />
    </register>

    <!-- 2.1.13.4 MSRs - MSRC001_1xxx -->

    <register name="CPUID_7_Features" type="msr" msr="0xC0011002" desc="CPUID Features for CPUID Fn00000007_E[A,B]X. Read-write. Core::X86::Msr::CPUID_7_Features[63:32] provides control over values read from Core::X86::Cpuid::StructExtFeatIdEax0; Core::X86::Msr::CPUID_7_Features[31:0] provides control over values read from Core::X86::Cpuid::StructExtFeatIdEbx0.">
      <!-- Bits 63:30 reserved. -->
      <field name="SHA" bit="29" size="1" desc="Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[SHA]." />
      <!-- Bits 28:24 reserved. -->
      <field name="CLFSHOPT" bit="23" size="1" desc="Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[CLFSHOPT]." />
      <!-- Bits 22:21 reserved. -->
      <field name="SMAP" bit="20" size="1" desc="Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[SMAP]." />
      <field name="ADX" bit="19" size="1" desc="Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[ADX]." />
      <field name="RDSEED" bit="18" size="1" desc="Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[RDSEED]." />
      <!-- Bits 17:9 reserved. -->
      <field name="BMI2" bit="8" size="1" desc="Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[BMI2]." />
      <field name="SMEP" bit="7" size="1" desc="Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[SMEP]." />
      <!-- Bit 6 reserved. -->
      <field name="AVX2" bit="5" size="1" desc="Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[AVX2]." />
      <!-- Bit 4 reserved. -->
      <field name="BMI1" bit="3" size="1" desc="Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[BMI1]." />
      <!-- Bits 2:1 reserved. -->
      <field name="FSGSBASE" bit="0" size="1" desc="Read-write. Reset: Core::X86::Cpuid::StructExtFeatIdEbx0[FSGSBASE]." />
    </register>

    <!-- page 155 -->

    <register name="CPUID_PWR_THERM" type="msr" msr="0xC0011003" desc="Thermal and Power Management CPUID Features. Read-write. Core::X86::Msr::CPUID_PWR_THERM provides control over values read from Core::X86::Cpuid::ThermalPwrMgmtEcx.">
      <!-- Bits 63:1 reserved. -->
      <field name="EffFreq" bit="0" size="1" desc="Read-write. Reset: Core::X86::Cpuid::ThermalPwrMgmtEcx[EffFreq]." />
    </register>
    <register name="CPUID_Features" type="msr" msr="0xC0011004" desc="CPUID Features for CPUID Fn00000001_E[C,D]X. Read-write. Core::X86::Msr::CPUID_Features[63:32] provides control over values read from Core::X86::Cpuid::FeatureIdEcx; Core::X86::Msr::CPUID_Features[31:0] provides control over values read from Core::X86::Cpuid::FeatureIdEdx.">
      <!-- Bit 63 reserved. -->
      <field name="RDRAND" bit="62" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[RDRAND]." />
      <field name="F16C" bit="61" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[F16C]." />
      <field name="AVX" bit="60" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[AVX]." />
      <field name="OSXSAVE" bit="59" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[OSXSAVE]. Modifies Core::X86::Cpuid::FeatureIdEcx[OSXSAVE] only if CR4[OSXSAVE]." />
      <field name="XSAVE" bit="58" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[XSAVE]." />
      <field name="AES" bit="57" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[AES]. Modifies Core::X86::Cpuid::FeatureIdEcx[AES] only if the reset value is 1." />
      <!-- Bit 56 reserved. -->
      <field name="POPCNT" bit="55" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[POPCNT]." />
      <field name="MOVBE" bit="54" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[MOVBE]." />
      <!-- Bit 53 reserved. -->
      <field name="SSE42" bit="52" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[SSE42]." />
      <field name="SSE41" bit="51" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[SSE41]." />
      <!-- Bits 50:46 reserved. -->
      <field name="CMPXCHG16B" bit="45" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[CMPXCHG16B]." />
      <field name="FMA" bit="44" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[FMA]." />
      <!-- Bits 43:42 reserved. -->
      <field name="SSSE3" bit="41" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[SSSE3]." />
      <!-- Bits 40:36 reserved. -->
      <field name="Monitor" bit="35" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[Monitor]. Modifies Core::X86::Cpuid::FeatureIdEcx[Monitor] only if ~Core::X86::Msr::HWCR[MonMwaitDis]." />
      <!-- Bit 34 reserved. -->
      <field name="PCLMULQDQ" bit="33" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[PCLMULQDQ]. Modifies Core::X86::Cpuid::FeatureIdEcx[PCLMULQDQ] only if the reset value is 1." />
      <field name="SSE3" bit="32" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEcx[SSE3]." />
      <!-- Bits 31:29 reserved. -->
      <field name="HTT" bit="28" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[HTT]." />
      <!-- Bit 27 reserved. -->
      <field name="SSE2" bit="26" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[SSE2]." />
      <field name="SSE" bit="25" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[SSE]." />
      <field name="FXSR" bit="24" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[FXSR]." />
      <field name="MMX" bit="23" size="1" desc="MMX instructions. Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[MMX]." />
      <!-- Bits 22:20 reserved. -->
      <field name="CLFSH" bit="19" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[CLFSH]." />
      <!-- Bit 18 reserved. -->
      <field name="PSE36" bit="17" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[PSE36]." />
      <field name="PAT" bit="16" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[PAT]." />
      <field name="CMOV" bit="15" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[CMOV]." />
      <field name="MCA" bit="14" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[MCA]." />
      <field name="PGE" bit="13" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[PGE]." />
      <field name="MTRR" bit="12" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[MTRR]." />
      <field name="SysEnterSysExit" bit="11" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[SysEnterSysExit]." />
      <!-- Bit 10 reserved. -->
      <field name="APIC" bit="9" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[APIC]. Modifies Core::X86::Cpuid::FeatureIdEdx[APIC] only if Core::X86::Msr::APIC_BAR[ApicEn]." />
      <field name="CMPXCHG8B" bit="8" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[CMPXCHG8B]." />
      <field name="MCE" bit="7" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[MCE]." />
      <field name="PAE" bit="6" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[PAE]." />
      <field name="MSR" bit="5" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[MSR]." />
      <field name="TSC" bit="4" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[TSC]." />
      <field name="PSE" bit="3" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[PSE]." />
      <field name="DE" bit="2" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[DE]." />
      <field name="VME" bit="1" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[VME]." />
      <field name="FPU" bit="0" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureIdEdx[FPU]." />
    </register>

    <!-- page 156 -->

    <register name="CPUID_ExtFeatures" type="msr" msr="0xC0011005" desc="CPUID Features for CPUID Fn80000001_E[C,D]X. Read-write. Core::X86::Msr::CPUID_ExtFeatures[63:32] provides control over values read from Core::X86::Cpuid::FeatureExtIdEcx; Core::X86::Msr::CPUID_ExtFeatures[31:0] provides control over values read from Core::X86::Cpuid::FeatureExtIdEdx.">
      <!-- Bits 63:62 reserved. -->
      <field name="MwaitExtended" bit="61" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[MwaitExtended]." />
      <field name="PerfCtrExtLLC" bit="60" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[PerfCtrExtLLC]." />
      <field name="PerfTsc" bit="59" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[PerfTsc]." />
      <field name="DataBreakpointExtension" bit="58" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[DataBreakpointExtension]." />
      <!-- Bit 57 reserved. -->
      <field name="PerfCtrExtDF" bit="56" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[PerfCtrExtDF]." />
      <field name="PerfCtrExtCore" bit="55" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[PerfCtrExtCore]." />
      <field name="TopologyExtensions" bit="54" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[TopologyExtensions]." />
      <!-- Bits 53:50 reserved. -->
      <field name="TCE" bit="49" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[TCE]." />
      <field name="FMA4" bit="48" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[FMA4]. Init: 0." />
      <field name="LWP" bit="47" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[LWP]." />
      <!-- Bit 46 reserved. -->
      <field name="WDT" bit="45" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[WDT]." />
      <field name="SKINIT" bit="44" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[SKINIT]." />
      <field name="XOP" bit="43" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[XOP]." />
      <field name="IBS" bit="42" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[IBS]. Init: BIOS,0. To enable the IBS feature, use   BIOS setup option." />
      <field name="OSVW" bit="41" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[OSVW]." />
      <field name="ThreeDNowPrefetch" bit="40" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[ThreeDNowPrefetch]." />
      <field name="MisAlignSse" bit="39" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[MisAlignSse]." />
      <field name="SSE4A" bit="38" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[SSE4A]." />
      <field name="ABM" bit="37" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[ABM]." />
      <field name="AltMovCr8" bit="36" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[AltMovCr8]." />
      <field name="ExtApicSpace" bit="35" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[ExtApicSpace]." />
      <field name="SVM" bit="34" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[SVM]." />
      <field name="CmpLegacy" bit="33" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[CmpLegacy]." />
      <field name="LahfSahf" bit="32" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEcx[LahfSahf]." />
      <field name="ThreeDNow" bit="31" size="1" desc="3DNow! instructions. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[ThreeDNow]." />
      <field name="ThreeDNowExt" bit="30" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[ThreeDNowExt]." />
      <field name="LM" bit="29" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[LM]." />
      <!-- Bit 28 reserved. -->
      <field name="RDTSCP" bit="27" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[RDTSCP]." />
      <field name="Page1GB" bit="26" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[Page1GB]." />
      <field name="FFXSR" bit="25" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[FFXSR]." />
      <field name="FXSR" bit="24" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[FXSR]." />
      <field name="MMX" bit="23" size="1" desc="MMX instructions. Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[MMX]." />
      <field name="MmxExt" bit="22" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[MmxExt]." />
      <!-- Bit 21 reserved. -->
      <field name="NX" bit="20" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[NX]." />
      <!-- Bits 19:18 reserved. -->
      <field name="PSE36" bit="17" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[PSE36]." />
      <field name="PAT" bit="16" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[PAT]." />
      <field name="CMOV" bit="15" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[CMOV]." />
      <field name="MCA" bit="14" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[MCA]." />
      <field name="PGE" bit="13" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[PGE]." />
      <field name="MTRR" bit="12" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[MTRR]." />
      <field name="SysCallSysRet" bit="11" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[SysCallSysRet]." />
      <!-- Bit 10 reserved. -->
      <field name="APIC" bit="9" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[APIC]." />
      <field name="CMPXCHG8B" bit="8" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[CMPXCHG8B]." />
      <field name="MCE" bit="7" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[MCE]." />
      <field name="PAE" bit="6" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[PAE]." />
      <field name="MSR" bit="5" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[MSR]." />
      <field name="TSC" bit="4" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[TSC]." />
      <field name="PSE" bit="3" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[PSE]." />
      <field name="DE" bit="2" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[DE]." />
      <field name="VME" bit="1" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[VME]." />
      <field name="FPU" bit="0" size="1" desc="Read-write. Reset: Core::X86::Cpuid::FeatureExtIdEdx[FPU]." />
    </register>

    <!-- page 158 -->

    <register name="DR1_ADDR_MASK" type="msr" msr="0xC0011019" desc="Address Mask For DR1 Breakpoint. Read-write. Reset: 0000_0000_0000_0000h. Support indicated by Core::X86::Cpuid::FeatureExtIdEcx[DataBreakpointExtension].">
      <!-- Bits 63:32 reserved. -->
      <field name="AddrMask" bit="0" size="32" desc="mask for DR linear address data breakpoint DR1. Read-write. Reset: 0000_0000h. 1=Exclude bit into address compare. 0=Include bit into address compare. See Core::X86::Msr::DR1_ADDR_MASK. AddrMask[11:0] qualifies the DR1 linear address instruction breakpoint, allowing the DR1 instruction breakpoint on a range of addresses in memory." />
    </register>
    <register name="DR2_ADDR_MASK" type="msr" msr="0xC001101A" desc="Address Mask For DR2 Breakpoint. Read-write. Reset: 0000_0000_0000_0000h. Support indicated by Core::X86::Cpuid::FeatureExtIdEcx[DataBreakpointExtension].">
      <!-- Bits 63:32 reserved. -->
      <field name="AddrMask" bit="0" size="32" desc="mask for DR linear address data breakpoint DR2. Read-write. Reset: 0000_0000h. 1=Exclude bit into address compare. 0=Include bit into address compare. See Core::X86::Msr::DR0_ADDR_MASK. AddrMask[11:0] qualifies the DR2 linear address instruction breakpoint, allowing the DR2 instruction breakpoint on a range of addresses in memory." />
    </register>
    <register name="DR3_ADDR_MASK" type="msr" msr="0xC001101B" desc="Address Mask For DR3 Breakpoint. Read-write. Reset: 0000_0000_0000_0000h. Support indicated by Core::X86::Cpuid::FeatureExtIdEcx[DataBreakpointExtension].">
      <!-- Bits 63:32 reserved. -->
      <field name="AddrMask" bit="0" size="32" desc="mask for DR linear address data breakpoint DR3. Read-write. Reset: 0000_0000h. 1=Exclude bit into address compare. 0=Include bit into address compare. See Core::X86::Msr::DR0_ADDR_MASK. AddrMask[11:0] qualifies the DR3 linear address instruction breakpoint, allowing the DR3 instruction breakpoint on a range of addresses in memory." />
    </register>
    <register name="TW_CFG" type="msr" msr="0xC0011023" desc="Table Walker Configuration. Read-write. Reset: 0000_0000_0000_0000h.">
      <!-- Bits 63:50 reserved. -->
      <field name="TwCfgCombineCr0Cd" bit="49" size="1" desc="combine CR0_CD for both threads of a core. Read-write. Reset: 0. Init: BIOS,1. 1=The host Cr0_Cd values from the two threads are OR'd together and used by both threads." />
      <!-- Bits 48:0 reserved. -->
    </register>
    <register name="DR0_ADDR_MASK" type="msr" msr="0xC0011027" desc="Address Mask For DR0 Breakpoints. Read-write. Reset: 0000_0000_0000_0000h. Support for DR0[31:12] is indicated by Core::X86::Cpuid::FeatureExtIdEcx[DataBreakpointExtension]. See Core::X86::Msr::DR1_ADDR_MASK.">
      <!-- Bits 63:32 reserved. -->
      <field name="DR0" bit="0" size="32" desc="mask for DR0 linear address data breakpoint. Read-write. Reset: 0000_0000h. 1=Exclude bit into address compare. 0=Include bit into address compare. See Core::X86::Msr::DR1_ADDR_MASK. This field qualifies the DR0 linear address data breakpoint, allowing the DR0 data breakpoint on a range of addresses in memory. AddrMask[11:0] qualifies the DR0 linear address instruction breakpoint, allowing the DR0 instruction breakpoint on a range of addresses in memory. DR0[31:12] is only valid for data breakpoints. The legacy DR0 breakpoint function is provided by DR0[31:0] == 0000_0000h. The mask bits are active high. DR0 is always used, and it can be used in conjunction with any debug function that uses DR0." />
    </register>

    <!-- page 159 -->

    <register name="IBS_FETCH_CTL" type="msr" msr="0xC0011030" desc="IBS Fetch Control. Reset: 0000_0000_0000_0000h. See 2.1.15 [Instruction Based Sampling (IBS)]. The IBS fetch sampling engine is described as follows: • The periodic fetch counter is an internal 20-bit counter: • The periodic fetch counter [19:4] is set to IbsFetchCnt[19:4] and the periodic fetch counter [3:0] is set according to IbsRandEn when IbsFetchEn is changed from 0 to 1. • It increments for every fetch cycle that completes when IbsFetchEn == 1 and IbsFetchVal == 0. • The periodic fetch counter is undefined when IbsFetchEn == 0 or IbsFetchVal == 1. • When IbsFetchCnt[19:4] is read it returns the current value of the periodic fetch counter [19:4]. • When the periodic fetch counter reaches {IbsFetchMaxCnt[19:4],0h} and the selected instruction fetch completes or is aborted: • IbsFetchVal is set to 1. • Drivers can't assume that IbsFetchCnt[19:4] is 0 when IbsFetchVal == 1. • The status of the operation is written to the IBS fetch registers (this register, Core::X86::Msr::IBS_FETCH_LINADDR and Core::X86::Msr::IBS_FETCH_PHYSADDR). • An interrupt is generated as specified by Core::X86::Msr::IBS_CTL. The interrupt service routine associated with this interrupt is responsible for saving the performance information stored in IBS execution registers.">
      <!-- Bits 63:59 reserved. -->
      <field name="IbsFetchL2Miss" bit="58" size="1" desc="L2 cache miss for the sampled fetch. Read-only,Volatile. Reset: 0. 1=The instruction fetch missed in the L2 Cache. Qualified by (IbsFetchComp == 1)." />
      <field name="IbsRandEn" bit="57" size="1" desc="random instruction fetch tagging enable. Read-write. Reset: 0. 0=Bits[3:0] of the fetch counter are set to 0h when IbsFetchEn is set to start the fetch counter. 1=Bits[3:0] of the fetch counter are randomized when IbsFetchEn is set to start the fetch counter." />
      <field name="IbsL2TlbMiss" bit="56" size="1" desc="instruction cache L2TLB miss. Read-only,Volatile. Reset: 0. 1=The instruction fetch missed in the L2 TLB." />
      <field name="IbsL1TlbMiss" bit="55" size="1" desc="instruction cache L1TLB miss. Read-only,Volatile. Reset: 0. 1=The instruction fetch missed in the L1 TLB." />
      <field name="IbsL1TlbPgSz" bit="53" size="2" desc="instruction cache L1TLB page size. Read-only,Volatile. Reset: 0h. Indicates the page size of the translation in the L1 TLB. This field is only valid if IbsPhyAddrValid == 1." />
      <field name="IbsPhyAddrValid" bit="52" size="1" desc="instruction fetch physical address valid. Read-only,Volatile. Reset: 0. 1=The physical address in Core::X86::Msr::IBS_FETCH_PHYSADDR and the IbsL1TlbPgSz field are valid for the instruction fetch." />
      <field name="IbsIcMiss" bit="51" size="1" desc="instruction cache miss. Read-only,Volatile. Reset: 0. 1=The instruction fetch missed in the instruction cache." />
      <field name="IbsFetchComp" bit="50" size="1" desc="instruction fetch complete. Read-only,Volatile. Reset: 0. 1=The instruction fetch completed and the data is available for use by the instruction decoder." />
      <field name="IbsFetchVal" bit="49" size="1" desc="instruction fetch valid. Read-only,Volatile. Reset: 0. 1=New instruction fetch data available. When this bit is set, the fetch counter stops counting and an interrupt is generated as specified by Core::X86::Msr::IBS_CTL. This bit must be cleared for the fetch counter to start counting. When clearing this bit, software can write 0000h to IbsFetchCnt[19:4] to start the fetch counter at IbsFetchMaxCnt[19:4]." />
      <field name="IbsFetchEn" bit="48" size="1" desc="instruction fetch enable. Read-write. Reset: 0. 1=Instruction fetch sampling is enabled." />
      <field name="IbsFetchLat" bit="32" size="16" desc="instruction fetch latency. Read-only,Volatile. Reset: 0000h. Indicates the number of clock cycles from when the instruction fetch was initiated to when the data was delivered to the core. If the instruction fetch is abandoned before the fetch completes, this field returns the number of clock cycles from when the instruction   fetch was initiated to when the fetch was abandoned." />
      <field name="IbsFetchCnt[19:4]" bit="16" size="16" desc="Read-write,Volatile. Reset: 0000h. Provides Read/Write access to bits[19:4] of the periodic fetch counter. Programming this field to a value greater than or equal to IbsFetchMaxCnt[19:4] results in undefined behavior." />
      <field name="IbsFetchMaxCnt[19:4]" bit="0" size="16" desc="Read-write. Reset: 0000h. Specifies bits[19:4] of the maximum count value of the periodic fetch counter. Programming this field to 0000h and setting IbsFetchEn results in undefined behavior. Bits[3:0] of the maximum count are always 0000b." />
    </register>

    <!-- page 160 -->

    <register name="IBS_FETCH_LINADDR" type="msr" msr="0xC0011031" desc="IBS Fetch Linear Address. Read-write,Volatile. Reset: 0000_0000_0000_0000h. Reset: 0000_0000_0000_0000h.">
      <field name="IbsFetchLinAd" bit="0" size="64" desc="instruction fetch linear address. Read-write,Volatile. Reset: 0000_0000_0000_0000h. Provides the linear address in canonical form for the tagged instruction fetch." />
    </register>
    <register name="IBS_FETCH_PHYSADDR" type="msr" msr="0xC0011032" desc="IBS Fetch Physical Address.">
      <!-- Bits 63:48 reserved. -->
      <field name="IbsFetchPhysAd" bit="0" size="48" desc="instruction fetch physical address. Read-write,Volatile. Reset: 0000_0000_0000h. Provides the physical address for the tagged instruction fetch. The lower 12 bits are not modified by address translation, so they are always the same as the linear address. This field contains valid data only if Core::X86::Msr::IBS_FETCH_CTL[IbsPhyAddrValid] is asserted." />
    </register>
    <register name="IBS_OP_CTL" type="msr" msr="0xC0011033" desc="IBS Execution Control. Reset: 0000_0000_0000_0000h. See 2.1.15 [Instruction Based Sampling (IBS)]. The IBS execution sampling engine is described as follows for IbsOpCntCtl == 1. If IbsOpCntCtl == 1n then references to &quot;periodic op counter&quot; mean &quot;periodic cycle counter&quot;. • The periodic op counter is an internal 27-bit counter: • It is set to IbsOpCurCnt[26:0] when IbsOpEn is changed from 0 to 1. • It increments every dispatched op when IbsOpEn == 1 and IbsOpVal == 0. • The periodic op counter is undefined when IbsOpEn == 0 or IbsOpVal == 1. • When IbsOpCurCnt[26:0] is read then it returns the current value of the periodic micro-op counter [26:0]. • When the periodic micro-op counter reaches IbsOpMaxCnt: • The next dispatched micro-op is tagged if IbsOpCntCtl == 1. A valid op in the next dispatched line is tagged if IbsOpCntCtl == 0. See IbsOpCntCtl. • The periodic micro-op counter [26:7] = 0; [6:0] is randomized by hardware. • The periodic micro-op counter is not modified when a tagged micro-op is flushed. • When a tagged micro-op is retired: • IbsOpVal is set to 1. • Drivers can't assume that IbsOpCurCnt == 0 when IbsOpVal == 1. • The status of the operation is written to the IBS execution registers (this register, Core::X86::Msr::IBS_OP_RIP, Core::X86::Msr::IBS_OP_DATA, Core::X86::Msr::IBS_OP_DATA2, Core::X86::Msr::IBS_OP_DATA3, Core::X86::Msr::IBS_DC_LINADDR and Core::X86::Msr::IBS_DC_PHYSADDR). • An interrupt is generated as specified by Core::X86::Msr::IBS_CTL. The interrupt service routine associated with this interrupt is responsible for saving the performance information stored in IBS execution registers.">
      <!-- Bits 63:59 reserved. -->
      <field name="IbsOpCurCnt[26:0]" bit="32" size="27" desc="periodic op counter current count. Read-write,Volatile. Reset: 000_0000h. Returns the  current value of the periodic op counter." />
      <!-- Bits 31:27 reserved. -->
      <field name="IbsOpMaxCnt[26:20]" bit="20" size="7" desc="periodic op counter maximum count. Read-write. Reset: 00h. See IbsOpMaxCnt[19:4]." />
      <field name="IbsOpCntCtl" bit="19" size="1" desc="periodic op counter count control. Read-write. Reset: 0. 0=Count clock cycles; a 1-of-4 round- robin counter selects an op in the next dispatch line; if the op pointed to by the round-robin counter is invalid, then the next younger valid op is selected. 1=Count dispatched Micro-Ops; when a roll-over occurs, the counter is preloaded with a pseudorandom 7-bit value between 1 and 127." />
      <field name="IbsOpVal" bit="18" size="1" desc="micro-op sample valid. Read-write,Volatile. Reset: 0. 1=New instruction execution data available; the periodic op counter is disabled from counting. An interrupt may be generated when this bit is set as specified by Core::X86::Msr::IBS_CTL[LvtOffset]." />
      <field name="IbsOpEn" bit="17" size="1" desc="micro-op sampling enable. Read-write. Reset: 0. 1=Instruction execution sampling enabled." />
      <!-- Bit 16 reserved. -->
      <field name="IbsOpMaxCnt[19:4]" bit="0" size="16" desc="periodic op counter maximum count. Read-write. Reset: 0000h. IbsOpMaxCnt[26:0] = {IbsOpMaxCnt[26:20], IbsOpMaxCnt[19:4], 0000b}. Specifies maximum count value of the periodic op counter. Bits[3:0] of the maximum count are always 0000b." />
    </register>

    <!-- page 161 -->

    <register name="IBS_OP_RIP" type="msr" msr="0xC0011034" desc="IBS Op Logical Address. Read-write,Volatile. Reset: 0000_0000_0000_0000h.">
      <field name="IbsOpRip" bit="0" size="64" desc="micro-op linear address. Read-write,Volatile. Reset: 0000_0000_0000_0000h. Linear address in canonical form for the instruction that contains the tagged micro-op." />
    </register>
    <register name="IBS_OP_DATA" type="msr" msr="0xC0011035" desc="IBS Op Data. Read-write,Volatile. Reset: 0000_0000_0000_0000h.">
      <!-- Bits 63:41 reserved. -->
      <field name="IbsOpMicrocode" bit="40" size="1" desc="Read-write,Volatile. Reset: 0. 1=Tagged operation from microcode." />
      <field name="IbsOpBrnFuse" bit="39" size="1" desc="fused branch micro-op. Read-write,Volatile. Reset: 0. 1=Tagged operation was a fused branch micro-op. Support indicated by Core::X86::Cpuid::IbsIdEax[OpBrnFuse]." />
      <field name="IbsRipInvalid" bit="38" size="1" desc="RIP is invalid. Read-write,Volatile. Reset: 0. 1=Tagged operation RIP is invalid. Support indicated by Core::X86::Cpuid::IbsIdEax[RipInvalidChk]." />
      <field name="IbsOpBrnRet" bit="37" size="1" desc="branch micro-op retired. Read-write,Volatile. Reset: 0. 1=Tagged operation was a branch micro- op that retired." />
      <field name="IbsOpBrnMisp" bit="36" size="1" desc="mispredicted branch micro-op. Read-write,Volatile. Reset: 0. 1=Tagged operation was a branch micro-op that was mispredicted. Qualified by IbsOpBrnRet == 1." />
      <field name="IbsOpBrnTaken" bit="35" size="1" desc="taken branch micro-op. Read-write,Volatile. Reset: 0. 1=Tagged operation was a branch micro-op that was taken. Qualified by IbsOpBrnRet == 1." />
      <field name="IbsOpReturn" bit="34" size="1" desc="return micro-op. Read-write,Volatile. Reset: 0. 1=Tagged operation was return micro-op. Qualified by (IbsOpBrnRet == 1)." />
      <!-- Bits 33:32 reserved. -->
      <field name="IbsTagToRetCtr" bit="16" size="16" desc="micro-op tag to retire count. Read-write,Volatile. Reset: 0000h. This field returns the number of cycles from when the micro-op was tagged to when the micro-op was retired. This field is equal to IbsCompToRetCtr when the tagged micro-op is a NOP." />
      <field name="IbsCompToRetCtr" bit="0" size="16" desc="micro-op completion to retire count. Read-write,Volatile. Reset: 0000h. This field returns the number of cycles from when the micro-op was completed to when the micro-op was retired." />
    </register>

    <!-- page 162 -->

    <register name="IBS_OP_DATA2" type="msr" msr="0xC0011036" desc="IBS Op Data 2. Reset: 0000_0000_0000_0000h. Data is only valid for load operations that miss both the L1 data cache and the L2 cache. If a load operation crosses a cache line boundary, the data returned in this register is the data for the access to the lower cache line.">
      <!-- Bits 63:6 reserved. -->
      <field name="CacheHitSt" bit="5" size="1" desc="IBS cache hit state. Read-write,Volatile. Reset: 0. 0=M State. 1=O State. Valid when the data source type is Cache(2h)." />
      <field name="RmtNode" bit="4" size="1" desc="IBS request destination node. Read-write,Volatile. Reset: 0. 0=The request is serviced by the NB in the same node as the core. 1=The request is serviced by the NB in a different node than the core. Valid when NbIbsReqSrc is non-zero." />
      <!-- Bit 3 reserved. -->
      <field name="DataSrc" bit="0" size="3" desc="northbridge IBS request data source. Read-write. Reset: 0h." />
    </register>
    <register name="IBS_OP_DATA3" type="msr" msr="0xC0011037" desc="IBS Op Data 3. Read-write,Volatile. Reset: 0000_0000_0000_0000h. If a load or store operation crosses a 256-bit boundary, the data returned in this register is the data for the access to the data below the 256-bit boundary.">
      <field name="IbsTlbRefillLat" bit="48" size="16" desc="L1 DTLB refill latency. Read-write,Volatile. Reset: 0000h. The number of cycles from when a L1 DTLB refill is triggered by a tagged op to when the L1 DTLB fill has been completed." />
      <field name="IbsDcMissLat" bit="32" size="16" desc="data cache miss latency. Read-write,Volatile. Reset: 0000h. Indicates the number of clock cycles from when a miss is detected in the data cache to when the data was delivered to the core. The value returned by this counter is not valid for data cache writes or prefetch instructions." />
      <field name="IbsOpDcMissOpenMemReqs" bit="26" size="6" desc="outstanding memory requests on DC fill. Read-write,Volatile. Reset: 00h. The number of allocated, valid DC MABs when the MAB corresponding to a tagged DC miss op is deallocated. Includes the MAB allocated by the sampled op. 00000b=No information provided." />
      <field name="IbsOpMemWidth" bit="22" size="4" desc="load/store size in bytes. Read-write,Volatile. Reset: 0h. Report the number of bytes the load or store is attempting to access." />
      <field name="IbsSwPf" bit="21" size="1" desc="software prefetch. Read-write,Volatile. Reset: 0. 1=The op is a software prefetch." />
      <field name="IbsL2Miss" bit="20" size="1" desc="L2 cache miss for the sampled operation. Read-write,Volatile. Reset: 0. 1=The operation missed in the L2, regardless of whether the op initiated the request to the L2." />
      <field name="IbsDcL2TlbHit1G" bit="19" size="1" desc="data cache L2TLB hit in 1G page. Read-write,Volatile. Reset: 0. 1=The physical address for the tagged load or store operation was present in a 1G page table entry in the data cache L2TLB." />
      <field name="IbsDcPhyAddrValid" bit="18" size="1" desc="data cache physical address valid. Read-write,Volatile. Reset: 0. 1=The physical address in Core::X86::Msr::IBS_DC_PHYSADDR is valid for the load or store operation." />
      <field name="IbsDcLinAddrValid" bit="17" size="1" desc="data cache linear address valid. Read-write,Volatile. Reset: 0. 1=The linear address in Core::X86::Msr::IBS_DC_LINADDR is valid for the load or store operation." />
      <field name="DcMissNoMabAlloc" bit="16" size="1" desc="DC miss with no MAB allocated. Read-write,Volatile. Reset: 0. 1=The tagged load or store operation hit on an already allocated MAB." />
      <field name="IbsDcLockedOp" bit="15" size="1" desc="locked operation. Read-write,Volatile. Reset: 0. 1=Tagged load or store operation is a locked operation." />
      <field name="IbsDcUcMemAcc" bit="14" size="1" desc="UC memory access. Read-write,Volatile. Reset: 0. 1=Tagged load or store operation accessed uncacheable memory." />
      <field name="IbsDcWcMemAcc" bit="13" size="1" desc="WC memory access. Read-write,Volatile. Reset: 0. 1=Tagged load or store operation accessed write combining memory." />
      <!-- Bits 12:9 reserved. -->
      <field name="IbsDcMisAcc" bit="8" size="1" desc="misaligned access. Read-write,Volatile. Reset: 0. 1=The tagged load or store operation crosses a 256-bit address boundary." />
      <field name="IbsDcMiss" bit="7" size="1" desc="data cache miss. Read-write,Volatile. Reset: 0. 1=The cache line used by the tagged load or store was not present in the data cache." />
      <field name="IbsDcL2tlbHit2M" bit="6" size="1" desc="data cache L2TLB hit in 2M page. Read-write,Volatile. Reset: 0. 1=The physical address for the tagged load or store operation was present in a 2M page table entry in the data cache L2TLB." />
      <field name="IbsDcL1TlbHit1G" bit="5" size="1" desc="data cache L1TLB hit in 1G page. Read-write,Volatile. Reset: 0. 1=The physical address for the tagged load or store operation was present in a 1G page table entry in the data cache L1TLB." />
      <field name="IbsDcL1TlbHit2M" bit="4" size="1" desc="data cache L1TLB hit in 2M page. Read-write,Volatile. Reset: 0. 1=The physical address for the tagged load or store operation was present in a 2M page table entry in the data cache L1TLB." />
      <field name="IbsDcL2TlbMiss" bit="3" size="1" desc="data cache L2TLB miss. Read-write,Volatile. Reset: 0. 1=The physical address for the tagged load or store operation was not present in the data cache L2TLB." />
      <field name="IbsDcL1tlbMiss" bit="2" size="1" desc="data cache L1TLB miss. Read-write,Volatile. Reset: 0. 1=The physical address for the tagged load or store operation was not present in the data cache L1TLB." />
      <field name="IbsStOp" bit="1" size="1" desc="store op. Read-write,Volatile. Reset: 0. 1=Tagged operation is a store operation." />
      <field name="IbsLdOp" bit="0" size="1" desc="load op. Read-write,Volatile. Reset: 0. 1=Tagged operation is a load operation." />
    </register>

    <!-- page 163 -->

    <register name="IBS_DC_LINADDR" type="msr" msr="0xC0011038" desc="IBS DC Linear Address. Read-write,Volatile. Reset: 0000_0000_0000_0000h.">
      <field name="IbsDcLinAd" bit="0" size="64" desc="Read-write,Volatile. Reset: 0000_0000_0000_0000h. Provides the linear address in canonical form for the tagged load or store operation. This field contains valid data only if Core::X86::Msr::IBS_OP_DATA3[IbsDcLinAddrValid] is asserted." />
    </register>
    <register name="IBS_DC_PHYSADDR" type="msr" msr="0xC0011039" desc="IBS DC Physical Address. Read-write,Volatile. Reset: 0000_0000_0000_0000h.">
      <!-- Bits 63:48 reserved. -->
      <field name="IbsDcPhysAd" bit="0" size="48" desc="load or store physical address. Read-write,Volatile. Reset: 0000_0000_0000h. Provides the physical address for the tagged load or store operation. The lower 12 bits are not modified by address translation,   so they are always the same as the linear address. This field contains valid data only if Core::X86::Msr::IBS_OP_DATA3[IbsDcPhyAddrValid] is asserted." />
    </register>

    <!-- page 164 -->

    <register name="IBS_CTL" type="msr" msr="0xC001103A" desc="IBS Control. Read,Error-on-write.">
      <!-- Bits 63:9 reserved. -->
      <field name="LvtOffsetVal" bit="8" size="1" desc="local vector table offset valid. Read,Error-on-write. Reset: X." />
      <!-- Bits 7:4 reserved. -->
      <field name="LvtOffset" bit="0" size="4" desc="local vector table offset. Read,Error-on-write. Reset: Xh." />
    </register>
    <register name="BP_IBSTGT_RIP" type="msr" msr="0xC001103B" desc="IBS Branch Target Address. Read-write,Volatile. Reset: 0000_0000_0000_0000h. Support for this register indicated by Core::X86::Cpuid::IbsIdEax[BrnTrgt].">
      <field name="IbsBrTarget" bit="0" size="64" desc="Read-write,Volatile. Reset: 0000_0000_0000_0000h. The logical address in canonical form for the branch target. Contains a valid target if != 0. Qualified by Core::X86::Msr::IBS_OP_DATA[IbsOpBrnRet] == 1." />
    </register>
    <register name="IC_IBS_EXTD_CTL" type="msr" msr="0xC001103C" desc="IBS Fetch Control Extended. Read-only,Volatile. Reset: 0000_0000_0000_0000h. Support for this register indicated by Core::X86::Cpuid::IbsIdEax[IbsFetchCtlExtd].">
      <!-- Bits 63:16 reserved. -->
      <field name="IbsItlbRefillLat" bit="0" size="16" desc="ITLB Refill Latency for the sampled fetch, if there is a reload. Read-only,Volatile. Reset: 0000h. The number of cycles when the fetch engine is stalled for an ITLB reload for the sampled fetch. If there is no reload, the latency == 0." />
    </register>

    <!-- 3.2.5.1 LS -->

    <!-- page 194 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2000 -->
    <register name="MCA_CTL_LS" type="msr" msr="0x00000400" desc="LS Machine Check Control. Read-write. Reset: 0000_0000_0000_0000h. 0=Disables error reporting for the corresponding error. 1=Enables error reporting via machine check exception for the corresponding error. The MCA::LS::MCA_CTL_LS register must be enabled by the corresponding enable bit in Core::X86::Msr::MCG_CTL. Does not affect error detection, correction, or logging.">
      <!-- Bits 63:21 reserved. -->
      <field name="L2DataErr" bit="20" size="1" desc="Read-write. Reset: 0. L2 Fill Data error." />
      <field name="DcTagErr5" bit="19" size="1" desc="Read-write. Reset: 0. DC Tag error type 5." />
      <field name="DcTagErr3" bit="18" size="1" desc="Read-write. Reset: 0. DC Tag error type 3." />
      <field name="PDC" bit="17" size="1" desc="Read-write. Reset: 0. PDC parity error. MCA_ADDR_LS logs a virtual address." />
      <field name="L2DTLB" bit="16" size="1" desc="Read-write. Reset: 0. Level 2 TLB parity error. MCA_ADDR_LS logs a virtual address." />
      <field name="DcTagErr4" bit="15" size="1" desc="Read-write. Reset: 0. DC Tag error type 4." />
      <field name="DcDataErr3" bit="14" size="1" desc="Read-write. Reset: 0. DC Data error type 3." />
      <field name="DcDataErr2" bit="13" size="1" desc="Read-write. Reset: 0. DC Data error type 2." />
      <field name="DcDataErr1" bit="12" size="1" desc="Read-write. Reset: 0. DC Data error type 1 and poison consumption. MCA_STATUS[Poison] is set on poison consumption from L2/L3." />
      <field name="DcTagErr2" bit="11" size="1" desc="Read-write. Reset: 0. DC Tag error type 2." />
      <field name="SystemReadDataErrorT1" bit="10" size="1" desc="Read-write. Reset: 0. System Read Data Error Thread 1. An error in a read of a line from the data fabric. Possible reasons include master abort and target abort." />
      <field name="SystemReadDataErrorT0" bit="9" size="1" desc="Read-write. Reset: 0. System Read Data Error Thread 0. An error in a read of a line from the data fabric. Possible reasons include master abort and target abort." />
      <field name="IntErrTyp2" bit="8" size="1" desc="Read-write. Reset: 0. Internal error type 2." />
      <field name="IntErrTyp1" bit="7" size="1" desc="Read-write. Reset: 0. Internal error type 1." />
      <field name="DcTagErr1" bit="6" size="1" desc="Read-write. Reset: 0. DC Tag error type 1." />
      <field name="DcTagErr6" bit="5" size="1" desc="Read-write. Reset: 0. DC Tag error type 6." />
      <!-- Bit 4 reserved. -->
      <field name="L1DTLB" bit="3" size="1" desc="Read-write. Reset: 0. Level 1 TLB parity error." />
      <field name="MAB" bit="2" size="1" desc="Read-write. Reset: 0. Miss address buffer payload parity error." />
      <field name="STQ" bit="1" size="1" desc="Read-write. Reset: 0. Store queue parity error." />
      <field name="LDQ" bit="0" size="1" desc="Read-write. Reset: 0. Load queue parity error." />
    </register>

    <!-- page 195 -->

    <!-- TODO Multiple MSR instances, skipping MSR0000_0401 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2001 -->
    <register name="MCA_STATUS_LS" type="msr" msr="0x00000001" desc="LS Machine Check Status Thread 0. Reset: Cold,0000_0000_0000_0000h. Logs information associated with errors.">
      <field name="Val" bit="63" size="1" desc="Reset: Cold,0. 1=A valid error has been detected. This bit should be cleared by software after the register has been read. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Overflow" bit="62" size="1" desc="Reset: Cold,0. 1=An error was detected while the valid bit (Val) was set; at least one error was not logged. Overflow is set independently of whether the existing error is overwritten. See 3.1.3 [Machine Check Errors]. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="UC" bit="61" size="1" desc="Reset: Cold,0. 1=The error was not corrected by hardware. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="En" bit="60" size="1" desc="Reset: Cold,0. 1=MCA error reporting is enabled for this error, as indicated by the corresponding bit in MCA::LS::MCA_CTL_LS. This bit is a copy of bit in MCA::LS::MCA_CTL_LS for this error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="MiscV" bit="59" size="1" desc="Reset: Cold,0. 1=Valid thresholding in MCA::LS::MCA_MISC0_LS. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="AddrV" bit="58" size="1" desc="Reset: Cold,0. 1=MCA::LS::MCA_ADDR_LS contains address information associated with the error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="PCC" bit="57" size="1" desc="Reset: Cold,0. 1=Hardware context held by the processor may have been corrupted. Continued operation of the system may have unpredictable results. The error is not recoverable or survivable, and the system should be reinitialized. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="ErrCoreIdVal" bit="56" size="1" desc="Reset: Cold,0. 1=The ErrCoreId field is valid. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="TCC" bit="55" size="1" desc="Reset: Cold,0. 0=The thread which consumed the error can be restarted reliably at the instruction pointer address pushed onto the exception handler stack if any uncorrected error has been corrected by software. 1=The thread which consumed the error is not restartable and must be terminated. Only meaningful when MCA::LS::MCA_STATUS_LS[PCC]=0. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bit 54 reserved. -->
      <field name="SyndV" bit="53" size="1" desc="Reset: Cold,0. 1=This error logged information in MCA::LS::MCA_SYND_LS. If MCA::LS::MCA_SYND_LS[ErrorPriority] is the same as the priority of the error in MCA::LS::MCA_STATUS_LS, then the information in MCA::LS::MCA_SYND_LS is associated with the error in MCA::LS::MCA_STATUS_LS. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 52:47 reserved. -->
      <field name="CECC" bit="46" size="1" desc="Reset: Cold,0. 1=The error was a correctable ECC error according to the restrictions of the ECC algorithm. UC indicates whether the error was actually corrected by the processor. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="UECC" bit="45" size="1" desc="Reset: Cold,0. 1=The error was an uncorrectable ECC error according to the restrictions of the ECC algorithm. UC indicates whether the error was actually corrected by the processor. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Deferred" bit="44" size="1" desc="Reset: Cold,0. 1=A deferred error was created. A deferred error is the result of an uncorrectable data error which did not immediately cause a processor exception; an exception is deferred until the erroneous data is consumed.   AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Poison" bit="43" size="1" desc="Reset: Cold,0. 1=The error was the result of attempting to consume poisoned data. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 42:38 reserved. -->
      <field name="ErrCoreId" bit="32" size="6" desc="Reset: Cold,00h. When ErrCoreIdVal=1 this field indicates which core within the processor is associated with the error; Otherwise this field is reserved. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 31:22 reserved. -->
      <field name="ErrorCodeExt" bit="16" size="6" desc="Reset: Cold,00h. Extended Error Code. This field is used to identify the error type for root cause analysis. This field indicates which bit position in MCA::LS::MCA_CTL_LS enables error reporting for the logged error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="ErrorCode" bit="0" size="16" desc="Reset: Cold,0000h. Error code for this error. See 3.1.3.3 [Error Codes] for details on decoding this field. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
    </register>

    <!-- page 197 -->

    <!-- TODO Multiple MSR instances, skipping MSR0000_0402 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2002 -->
    <register name="MCA_ADDR_LS" type="msr" msr="0x00000000" desc="LS Machine Check Address Thread 0. Reset: Cold,0000_0000_0000_0000h. MCA::LS::MCA_ADDR_LS stores an address and other information associated with the error in MCA::LS::MCA_STATUS_LS. The register is only meaningful if MCA::LS::MCA_STATUS_LS[Val]=1 and MCA::LS::MCA_STATUS_LS[AddrV]=1.">
      <!-- Bits 63:62 reserved. -->
      <field name="LSB" bit="56" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the least significant valid bit of the address contained in MCA::LS::MCA_ADDR_LS[ErrorAddr]. A value of 0 indicates that MCA::LS::MCA_ADDR_LS[55:0] contains a valid byte address. A value of 6 indicates that MCA::LS::MCA_ADDR_LS[55:6] contains a valid cache line address and that MCA::LS::MCA_ADDR_LS[5:0] are not part of the address and should be ignored by error handling software. A value of 12 indicates that MCA::LS::MCA_ADDR_LS[55:12] contain a valid 4KB memory page and that MCA::LS::MCA_ADDR_LS[11:0] should be ignored by error handling software." />
      <field name="ErrorAddr" bit="0" size="56" desc="Read-write,Volatile. Reset: Cold,00_0000_0000_0000h. Unless otherwise specified by an error, contains the address associated with the error logged in MCA::LS::MCA_STATUS_LS. For physical addresses, the most significant bit is given by Core::X86::Cpuid::LongModeInfo[PhysAddrSize]." />
    </register>

    <!-- page 198 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2003 -->
    <register name="MCA_MISC0_LS" type="msr" msr="0x00000403" desc="LS Machine Check Miscellaneous 0 Thread 0. Log miscellaneous information associated with errors.">
      <field name="Valid" bit="63" size="1" desc="Reset: 1. 1=A valid CntP field is present in this register. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="CntP" bit="62" size="1" desc="Reset: 1. 1=A valid threshold counter is present. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="Locked" bit="61" size="1" desc="Reset: 0. 1=Writes to this register are ignored. This bit is set by BIOS to indicate that this register is not available for OS use. BIOS should set this bit if ThresholdIntType is set to SMI. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="IntP" bit="60" size="1" desc="Reset: 1. 1=ThresholdIntType can be used to generate interrupts. 0=ThresholdIntType and interrupt generation are not supported. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::LS::MCA_MISC0_LS[Locked]) ? Read-write : Read-only." />
      <!-- Bits 59:56 reserved. -->
      <field name="LvtOffset" bit="52" size="4" desc="Reset: 0h. One per die. For error thresholding interrupts, specifies the address of the LVT entry in the APIC registers as follows: LVT address = (LvtOffset shifted left 4 bits) + 500h (see Core::X86::Apic::ExtendedInterruptLvtEntries). AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::LS::MCA_MISC0_LS[Locked]) ? Read-write : Read-only." />
      <field name="CntEn" bit="51" size="1" desc="Reset: 0. 1=Count thresholding errors. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::LS::MCA_MISC0_LS[Locked]) ? Read-write : Read-only." />
      <field name="ThresholdIntType" bit="49" size="2" desc="Reset: Cold,0h. Specifies the type of interrupt signaled when Ovrflw is set and IntP==1. 00b = No interrupt. 01b = APIC based interrupt (see Core::X86::Msr::McaIntrCfg[ThresholdLvtOffset]). 10b = SMI trigger event. 11b = Reserved. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::LS::MCA_MISC0_LS[Locked]) ? Read-write : Read-only." />
      <field name="Ovrflw" bit="48" size="1" desc="Reset: Cold,0. Set by hardware when ErrCnt transitions from FFEh to FFFh. When this field is set, ErrCnt no longer increments. When this bit is set, the interrupt selected by the ThresholdIntType field is generated. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::LS::MCA_MISC0_LS[Locked]) ? Read-write : Read-only." />
      <!-- Bits 47:44 reserved. -->
      <field name="ErrCnt" bit="32" size="12" desc="Reset: Cold,000h. This is written by software to set the starting value of the error counter. This is incremented by hardware when errors are logged. When this counter overflows, it stays at FFFh (no rollover). The threshold value, written by software, is (FFFh - the desired error count (the number of errors necessary in order for an interrupt to be taken)); the desired error count of 0 (a write value of FFFh) is not supported. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::LS::MCA_MISC0_LS[Locked]) ? Read-write : Read-only." />
      <field name="BlkPtr" bit="24" size="8" desc="Read-write. Reset: 01h. 00h=Extended MISC MSR block is not valid. 01h=Extended MSR block is valid." />
      <!-- Bits 23:0 reserved. -->
    </register>
    <register name="MCA_CONFIG_LS" type="msr" msr="0xC0002004" desc="LS Machine Check Configuration. Reset: 0000_0002_0000_0025h. Controls configuration of the associated machine check bank.">
      <!-- Bits 63:39 reserved. -->
      <field name="DeferredIntType" bit="37" size="2" desc="Read-write. Reset: 0h. Specifies the type of interrupt signaled when a deferred error is logged.   00b = No interrupt. 01b = APIC based interrupt (see Core::X86::Msr::McaIntrCfg[DeferredLvtOffset]). 10b = SMI trigger event. 11b = Reserved." />
      <!-- Bits 36:35 reserved. -->
      <field name="LogDeferredInMcaStat" bit="34" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. 1=Log deferred errors in MCA::LS::MCA_STATUS_LS and MCA::LS::MCA_ADDR_LS in addition to MCA::LS::MCA_DESTAT_LS and MCA::LS::MCA_DEADDR_LS. 0=Only log deferred errors in MCA::LS::MCA_DESTAT_LS and MCA::LS::MCA_DEADDR_LS. This bit does not affect logging of deferred errors in MCA::LS::MCA_SYND_LS, MCA::LS::MCA_MISC0_LS." />
      <!-- Bit 33 reserved. -->
      <field name="McaXEnable" bit="32" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. Check: 1. 1=Software has acknowledged support for the MCAX feature set. 0=Software has not acknowledged support for the MCAX feature set. All uncorrected and fatal errors will cause an ErrorEvent packet to be generated. Deferred error interrupts are configured via Core::X86::Msr::McaIntrCfg." />
      <!-- Bits 31:6 reserved. -->
      <field name="DeferredIntTypeSupported" bit="5" size="1" desc="Read-only. Reset: 1. 1=MCA::LS::MCA_CONFIG_LS[DeferredIntType] controls the type of interrupt generated on a deferred error. Deferred errors are supported in this bank only if MCA::LS::MCA_CONFIG_LS[DeferredErrorLoggingSupported]=1." />
      <!-- Bits 4:3 reserved. -->
      <field name="DeferredErrorLoggingSupported" bit="2" size="1" desc="Read-only. Reset: 1. 1=Deferred errors are supported in this MCA bank, and MCA::LS::MCA_CONFIG_LS[LogDeferredInMcaStat] controls the logging behavior of these errors. MCA::LS::MCA_DESTAT_LS and MCA::LS::MCA_DEADDR_LS are supported in this MCA bank. 0=Deferred errors are not supported in this bank." />
      <!-- Bit 1 reserved. -->
      <field name="McaX" bit="0" size="1" desc="Read-only. Reset: 1. 1=This bank provides Machine Check Architecture Extensions. Up to 4 additional MISC registers (MISC1-MISC4) are supported. MCA::LS::MCA_MISC0_LS[BlkPtr] indicates the presence of the additional MISC registers, but is not used to determine their MSR numbers. Deferred error interrupt type is specifiable by MCA bank. MCA::LS::MCA_STATUS_LS[TCC] is present." />
    </register>

    <!-- page 199 -->

    <register name="MCA_IPID_LS" type="msr" msr="0xC0002005" desc="LS IP Identification. Reset: 0000_00B0_0000_0000h. The MCA::LS::MCA_IPID_LS register is used by software to determine what IP type and revision is associated with the MCA bank.">
      <field name="McaType" bit="48" size="16" desc="Read-only. Reset: 0000h. The McaType of the MCA bank within this IP." />
      <!-- Bits 47:44 reserved. -->
      <field name="HardwareID" bit="32" size="12" desc="Read-only. Reset: 0B0h. The Hardware ID of the IP associated with this MCA bank." />
      <field name="InstanceId" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. The instance ID of this IP. This is initialized to a unique ID per instance of this register." />
    </register>
    <register name="MCA_SYND_LS" type="msr" msr="0xC0002006" desc="LS Machine Check Syndrome Thread 0. Read-write,Volatile. Reset: Cold,0000_0000_0000_0000h. Logs physical location information associated with error in MCA::LS::MCA_STATUS_LS Thread 0">
      <!-- Bits 63:39 reserved. -->
      <field name="Syndrome" bit="32" size="7" desc="Read-write,Volatile. Reset: Cold,00h. Contains the syndrome, if any, associated with the error logged in MCA::LS::MCA_STATUS_LS. The low-order bit of the syndrome is stored in bit 0, and the syndrome has a length specified by MCA::LS::MCA_SYND_LS[Length]. The Syndrome field is only valid when MCA::LS::MCA_SYND_LS[Length] is not 0." />
      <!-- Bits 31:27 reserved. -->
      <field name="ErrorPriority" bit="24" size="3" desc="Read-write,Volatile. Reset: Cold,0h. Encodes the priority of the error logged in MCA::LS::MCA_SYND_LS. 3'b000 = No error; 3'b001 = Reserved; 3'b010 = Corrected Error; 3'b011 = Deferred Error; 3'b100 = Uncorrected Error; 3'b101 = Fatal Error; all others reserved." />
      <field name="Length" bit="18" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the length in bits of the syndrome contained in MCA::LS::MCA_SYND_LS[Syndrome]. A value of 0 indicates that there is no valid syndrome in MCA::LS::MCA_SYND_LS. For example, a syndrome length of 9 means that MCA::LS::MCA_SYND_LS[Syndrome] bits [8:0] contains a valid syndrome." />
      <field name="ErrorInformation" bit="0" size="18" desc="Read-write,Volatile. Reset: Cold,0_0000h. Contains error-specific information about the location of the error. Decoding is available in Table 35 [MCA_SYND_LS Register]." />
    </register>

    <!-- page 201 -->

    <register name="MCA_DESTAT_LS" type="msr" msr="0xC0002008" desc="LS Machine Check Deferred Error Status Thread 0. Read-write,Volatile. Reset: Cold,0000_0000_0000_0000h. Holds status information for the first deferred error seen in this bank.">
      <field name="Val" bit="63" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=A valid error has been detected (whether it is enabled or not)." />
      <field name="Overflow" bit="62" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=An error was detected while the valid bit (Val) was set; at least one error was not logged. Overflow is set independently of whether the existing error is overwritten. (See the section on overwrite priorities.)" />
      <!-- Bits 61:59 reserved. -->
      <field name="AddrV" bit="58" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=MCA::LS::MCA_DEADDR_LS contains address information associated with the error." />
      <!-- Bits 57:54 reserved. -->
      <field name="SyndV" bit="53" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=This error logged information in MCA::LS::MCA_SYND_LS. If MCA::LS::MCA_SYND_LS[ErrorPriority] is the same as the priority of the error in MCA::LS::MCA_STATUS_LS, then the information in MCA::LS::MCA_SYND_LS is associated with the error in MCA::LS::MCA_DESTAT_LS." />
      <!-- Bits 52:45 reserved. -->
      <field name="Deferred" bit="44" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=A deferred error was created. A deferred error is the result of an uncorrectable data error which did not immediately cause a processor exception; poison is created and an exception is deferred until the poison data is consumed." />
      <!-- Bits 43:0 reserved. -->
    </register>
    <register name="MCA_DEADDR_LS" type="msr" msr="0xC0002009" desc="LS Deferred Error Address Thread 0. Reset: Cold,0000_0000_0000_0000h. The MCA::LS::MCA_DEADDR_LS register stores the address associated with the error in MCA::LS::MCA_DESTAT_LS. The register is only meaningful if MCA::LS::MCA_DESTAT_LS[Val]=1 and MCA::LS::MCA_DESTAT_LS[AddrV]=1. The lowest valid bit of the address is defined by MCA::LS::MCA_DEADDR_LS[LSB].">
      <!-- Bits 63:62 reserved. -->
      <field name="LSB" bit="56" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the least significant valid bit of the address contained in   MCA::LS::MCA_DEADDR_LS[ErrorAddr]. A value of 0 indicates that MCA::LS::MCA_DEADDR_LS[55:0] contains a valid byte address. A value of 6 indicates that MCA::LS::MCA_DEADDR_LS[55:6] contains a valid cache line address and that MCA::LS::MCA_DEADDR_LS[5:0] are not part of the address and should be ignored by error handling software. A value of 12 indicates that MCA::LS::MCA_DEADDR_LS[55:12] contain a valid 4KB memory page and that MCA::LS::MCA_DEADDR_LS[11:0] should be ignored by error handling software." />
      <field name="ErrorAddr" bit="0" size="56" desc="Read-write,Volatile. Reset: Cold,00_0000_0000_0000h. Contains the address, if any, associated with the error logged in MCA::LS::MCA_DESTAT_LS. The lowest-order valid bit of the address is specified in MCA::LS::MCA_DEADDR_LS[LSB]." />
    </register>

    <!-- page 202 -->

    <register name="MCA_CTL_MASK_LS" type="msr" msr="0xC0010400" desc="LS Machine Check Control Mask. Read-write. Reset: 0000_0000_0000_0000h. Inhibit detection of an error source.">
      <!-- Bits 63:21 reserved. -->
      <field name="L2DataErr" bit="20" size="1" desc="Read-write. Reset: 0. L2 Fill Data error." />
      <field name="DcTagErr5" bit="19" size="1" desc="Read-write. Reset: 0. DC Tag error type 5." />
      <field name="DcTagErr3" bit="18" size="1" desc="Read-write. Reset: 0. DC Tag error type 3." />
      <field name="PDC" bit="17" size="1" desc="Read-write. Reset: 0. PDC parity error. MCA_ADDR_LS logs a virtual address." />
      <field name="L2DTLB" bit="16" size="1" desc="Read-write. Reset: 0. Level 2 TLB parity error. MCA_ADDR_LS logs a virtual address." />
      <field name="DcTagErr4" bit="15" size="1" desc="Read-write. Reset: 0. DC Tag error type 4." />
      <field name="DcDataErr3" bit="14" size="1" desc="Read-write. Reset: 0. DC Data error type 3." />
      <field name="DcDataErr2" bit="13" size="1" desc="Read-write. Reset: 0. DC Data error type 2." />
      <field name="DcDataErr1" bit="12" size="1" desc="Read-write. Reset: 0. DC Data error type 1 and poison consumption. MCA_STATUS[Poison] is set on poison consumption from L2/L3." />
      <field name="DcTagErr2" bit="11" size="1" desc="Read-write. Reset: 0. DC Tag error type 2." />
      <field name="SystemReadDataErrorT1" bit="10" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. System Read Data Error Thread 1. An error in a read of a line from the data fabric. Possible reasons include master abort and target abort." />
      <field name="SystemReadDataErrorT0" bit="9" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. System Read Data Error Thread 0. An error in a read of a line from the data fabric. Possible reasons include master abort and target abort." />
      <field name="IntErrTyp2" bit="8" size="1" desc="Read-write. Reset: 0. Internal error type 2." />
      <field name="IntErrTyp1" bit="7" size="1" desc="Read-write. Reset: 0. Internal error type 1." />
      <field name="DcTagErr1" bit="6" size="1" desc="Read-write. Reset: 0. DC Tag error type 1." />
      <field name="DcTagErr6" bit="5" size="1" desc="Read-write. Reset: 0. DC Tag error type 6." />
      <!-- Bit 4 reserved. -->
      <field name="L1DTLB" bit="3" size="1" desc="Read-write. Reset: 0. Level 1 TLB parity error." />
      <field name="MAB" bit="2" size="1" desc="Read-write. Reset: 0. Miss address buffer payload parity error." />
      <field name="STQ" bit="1" size="1" desc="Read-write. Reset: 0. Store queue parity error." />
      <field name="LDQ" bit="0" size="1" desc="Read-write. Reset: 0. Load queue parity error." />
    </register>

    <!-- 3.2.5.2 IF -->

    <!-- page 203 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2010 -->
    <register name="MCA_CTL_IF" type="msr" msr="0x00000404" desc="IF Machine Check Control. Read-write. Reset: 0000_0000_0000_0000h. 0=Disables error reporting for the corresponding error. 1=Enables error reporting via machine check exception for the corresponding error. The MCA::IF::MCA_CTL_IF register must be enabled by the corresponding enable bit in Core::X86::Msr::MCG_CTL. Does not affect error detection, correction, or logging.">
      <!-- Bits 63:14 reserved. -->
      <field name="SystemReadDataError" bit="13" size="1" desc="Read-write. Reset: 0. System Read Data Error. An error in a demand fetch of a line. Possible reasons include master abort and target abort." />
      <field name="L2RespPoison" bit="12" size="1" desc="Read-write. Reset: 0. L2 Cache Response Poison Error. Error is the result of consuming poison data." />
      <field name="L2BtbMultiHit" bit="11" size="1" desc="Read-write. Reset: 0. L2 BTB Multi-Match Error." />
      <field name="L1BtbMultiHit" bit="10" size="1" desc="Read-write. Reset: 0. L1 BTB Multi-Match Error." />
      <field name="BpqSnpParT1" bit="9" size="1" desc="Read-write. Reset: 0. BPQ Thread 1 Snoop Parity Error." />
      <field name="BpqSnpParT0" bit="8" size="1" desc="Read-write. Reset: 0. BPQ Thread 0 Snoop Parity Error." />
      <field name="L2ItlbParity" bit="7" size="1" desc="Read-write. Reset: 0. L2 ITLB Parity Error." />
      <field name="L1ItlbParity" bit="6" size="1" desc="Read-write. Reset: 0. L1 ITLB Parity Error." />
      <field name="L0ItlbParity" bit="5" size="1" desc="Read-write. Reset: 0. L0 ITLB Parity Error." />
      <field name="DqParity" bit="4" size="1" desc="Read-write. Reset: 0. Decoupling Queue PhysAddr Parity Error." />
      <field name="DataParity" bit="3" size="1" desc="Read-write. Reset: 0. IC Data Array Parity Error." />
      <field name="TagParity" bit="2" size="1" desc="Read-write. Reset: 0. IC Full Tag Parity Error." />
      <field name="TagMultiHit" bit="1" size="1" desc="Read-write. Reset: 0. IC Microtag or Full Tag Multi-hit Error." />
      <field name="OcUtagParity" bit="0" size="1" desc="Read-write. Reset: 0. Op Cache Microtag Probe Port Parity Error." />
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC000_2011 -->
    <register name="MCA_STATUS_IF" type="msr" msr="0x00000405" desc="IF Machine Check Status Thread 0. Reset: Cold,0000_0000_0000_0000h. Logs information associated with errors.">
      <field name="Val" bit="63" size="1" desc="Reset: Cold,0. 1=A valid error has been detected. This bit should be cleared by software after the register has been read. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Overflow" bit="62" size="1" desc="Reset: Cold,0. 1=An error was detected while the valid bit (Val) was set; at least one error was not logged. Overflow is set independently of whether the existing error is overwritten. See 3.1.3 [Machine Check Errors]. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="UC" bit="61" size="1" desc="Reset: Cold,0. 1=The error was not corrected by hardware. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="En" bit="60" size="1" desc="Reset: Cold,0. 1=MCA error reporting is enabled for this error, as indicated by the corresponding bit in MCA::IF::MCA_CTL_IF. This bit is a copy of bit in MCA::IF::MCA_CTL_IF for this error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="MiscV" bit="59" size="1" desc="Reset: Cold,0. 1=Valid thresholding in MCA::IF::MCA_MISC0_IF. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="AddrV" bit="58" size="1" desc="Reset: Cold,0. 1=MCA::IF::MCA_ADDR_IF contains address information associated with the error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="PCC" bit="57" size="1" desc="Reset: Cold,0. 1=Hardware context held by the processor may have been corrupted. Continued operation of the system may have unpredictable results. The error is not recoverable or survivable, and the system should be reinitialized. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="ErrCoreIdVal" bit="56" size="1" desc="Reset: Cold,0. 1=The ErrCoreId field is valid. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="TCC" bit="55" size="1" desc="Reset: Cold,0. 0=The thread which consumed the error can be restarted reliably at the instruction pointer address pushed onto the exception handler stack if any uncorrected error has been corrected by software. 1=The thread which consumed the error is not restartable and must be terminated. Only meaningful when   MCA::IF::MCA_STATUS_IF[PCC]=0. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bit 54 reserved. -->
      <field name="SyndV" bit="53" size="1" desc="Reset: Cold,0. 1=This error logged information in MCA::IF::MCA_SYND_IF. If MCA::IF::MCA_SYND_IF[ErrorPriority] is the same as the priority of the error in MCA::IF::MCA_STATUS_IF, then the information in MCA::IF::MCA_SYND_IF is associated with the error in MCA::IF::MCA_STATUS_IF. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 52:47 reserved. -->
      <field name="CECC" bit="46" size="1" desc="Reset: Cold,0. 1=The error was a correctable ECC error according to the restrictions of the ECC algorithm. UC indicates whether the error was actually corrected by the processor. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="UECC" bit="45" size="1" desc="Reset: Cold,0. 1=The error was an uncorrectable ECC error according to the restrictions of the ECC algorithm. UC indicates whether the error was actually corrected by the processor. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Deferred" bit="44" size="1" desc="Reset: Cold,0. 1=A deferred error was created. A deferred error is the result of an uncorrectable data error which did not immediately cause a processor exception; an exception is deferred until the erroneous data is consumed. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Poison" bit="43" size="1" desc="Reset: Cold,0. 1=The error was the result of attempting to consume poisoned data. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 42:38 reserved. -->
      <field name="ErrCoreId" bit="32" size="6" desc="Reset: Cold,00h. When ErrCoreIdVal=1 this field indicates which core within the processor is associated with the error; Otherwise this field is reserved. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 31:22 reserved. -->
      <field name="ErrorCodeExt" bit="16" size="6" desc="Reset: Cold,00h. Extended Error Code. This field is used to identify the error type for root cause analysis. This field indicates which bit position in MCA::IF::MCA_CTL_IF enables error reporting for the logged error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="ErrorCode" bit="0" size="16" desc="Reset: Cold,0000h. Error code for this error. See 3.1.3.3 [Error Codes] for details on decoding this field. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
    </register>

    <!-- page 205 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2012 -->
    <register name="MCA_ADDR_IF" type="msr" msr="0x00000406" desc="IF Machine Check Address Thread 0. Reset: Cold,0000_0000_0000_0000h. MCA::IF::MCA_ADDR_IF stores an address and other information associated with the error in MCA::IF::MCA_STATUS_IF. The register is only meaningful if MCA::IF::MCA_STATUS_IF[Val]=1 and MCA::IF::MCA_STATUS_IF[AddrV]=1.">
      <!-- Bits 63:62 reserved. -->
      <field name="LSB" bit="56" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the least significant valid bit of the address contained in MCA::IF::MCA_ADDR_IF[ErrorAddr]. A value of 0 indicates that MCA::IF::MCA_ADDR_IF[55:0] contains a valid byte address. A value of 6 indicates that MCA::IF::MCA_ADDR_IF[55:6] contains a valid cache line address and that MCA::IF::MCA_ADDR_IF[5:0] are not part of the address and should be ignored by error handling software. A value of 12 indicates that MCA::IF::MCA_ADDR_IF[55:12] contain a valid 4KB memory page and that MCA::IF::MCA_ADDR_IF[11:0] should be ignored by error handling software." />
      <field name="ErrorAddr" bit="0" size="56" desc="Read-write,Volatile. Reset: Cold,00_0000_0000_0000h. Unless otherwise specified by an error, contains the address associated with the error logged in MCA::IF::MCA_STATUS_IF. For physical addresses, the most significant bit is given by Core::X86::Cpuid::LongModeInfo[PhysAddrSize]." />
    </register>

    <!-- page 206 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2013 -->
    <register name="MCA_MISC0_IF" type="msr" msr="0x00000407" desc="IF Machine Check Miscellaneous 0 Thread 0. Log miscellaneous information associated with errors.">
      <field name="Valid" bit="63" size="1" desc="Reset: 1. 1=A valid CntP field is present in this register. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="CntP" bit="62" size="1" desc="Reset: 1. 1=A valid threshold counter is present. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="Locked" bit="61" size="1" desc="Reset: 0. 1=Writes to this register are ignored. This bit is set by BIOS to indicate that this register is not available for OS use. BIOS should set this bit if ThresholdIntType is set to SMI. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="IntP" bit="60" size="1" desc="Reset: 1. 1=ThresholdIntType can be used to generate interrupts. 0=ThresholdIntType and interrupt generation are not supported. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::IF::MCA_MISC0_IF[Locked]) ? Read-write : Read-only." />
      <!-- Bits 59:56 reserved. -->
      <field name="LvtOffset" bit="52" size="4" desc="Reset: 0h. One per die. For error thresholding interrupts, specifies the address of the LVT entry in the APIC registers as follows: LVT address = (LvtOffset shifted left 4 bits) + 500h (see Core::X86::Apic::ExtendedInterruptLvtEntries). AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::IF::MCA_MISC0_IF[Locked]) ? Read-write : Read-only." />
      <field name="CntEn" bit="51" size="1" desc="Reset: 0. 1=Count thresholding errors. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::IF::MCA_MISC0_IF[Locked]) ? Read-write : Read-only." />
      <field name="ThresholdIntType" bit="49" size="2" desc="Reset: Cold,0h. Specifies the type of interrupt signaled when Ovrflw is set and IntP==1. 00b = No interrupt. 01b = APIC based interrupt (see Core::X86::Msr::McaIntrCfg[ThresholdLvtOffset]). 10b = SMI trigger event. 11b = Reserved. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::IF::MCA_MISC0_IF[Locked]) ? Read-write : Read-only." />
      <field name="Ovrflw" bit="48" size="1" desc="Reset: Cold,0. Set by hardware when ErrCnt transitions from FFEh to FFFh. When this field is set, ErrCnt no longer increments. When this bit is set, the interrupt selected by the ThresholdIntType field is generated. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::IF::MCA_MISC0_IF[Locked]) ? Read-write : Read-only." />
      <!-- Bits 47:44 reserved. -->
      <field name="ErrCnt" bit="32" size="12" desc="Reset: Cold,000h. This is written by software to set the starting value of the error counter. This is incremented by hardware when errors are logged. When this counter overflows, it stays at FFFh (no rollover). The threshold value, written by software, is (FFFh - the desired error count (the number of errors necessary in order for an interrupt to be taken)); the desired error count of 0 (a write value of FFFh) is not supported. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::IF::MCA_MISC0_IF[Locked]) ? Read-write : Read-only." />
      <field name="BlkPtr" bit="24" size="8" desc="Read-write. Reset: 01h. 00h=Extended MISC MSR block is not valid. 01h=Extended MSR block is valid." />
      <!-- Bits 23:0 reserved. -->
    </register>

    <!-- page 207 -->

    <register name="MCA_CONFIG_IF" type="msr" msr="0xC0002014" desc="IF Machine Check Configuration. Reset: 0000_0002_0000_0021h. Controls configuration of the associated machine check bank.">
      <!-- Bits 63:39 reserved. -->
      <field name="DeferredIntType" bit="37" size="2" desc="Read-write. Reset: 0h. Specifies the type of interrupt signaled when a deferred error is logged. 00b = No interrupt. 01b = APIC based interrupt (see Core::X86::Msr::McaIntrCfg[DeferredLvtOffset]). 10b = SMI trigger event. 11b = Reserved." />
      <!-- Bits 36:33 reserved. -->
      <field name="McaXEnable" bit="32" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. Check: 1. 1=Software has acknowledged support for the MCAX feature set. 0=Software has not acknowledged support for the MCAX feature set. All uncorrected and fatal errors will cause an ErrorEvent packet to be generated. Deferred error interrupts are configured via Core::X86::Msr::McaIntrCfg." />
      <!-- Bits 31:6 reserved. -->
      <field name="DeferredIntTypeSupported" bit="5" size="1" desc="Read-only. Reset: 1. 1=MCA::IF::MCA_CONFIG_IF[DeferredIntType] controls the type of interrupt generated on a deferred error. Deferred errors are supported in this bank only if MCA::IF::MCA_CONFIG_IF[DeferredErrorLoggingSupported]=1." />
      <!-- Bits 4:3 reserved. -->
      <field name="DeferredErrorLoggingSupported" bit="2" size="1" desc="Read-only. Reset: 0. 1=Deferred errors are supported in this MCA bank, and the LogDeferredInMcaStat field in this register controls the logging behavior of these errors. MCA_DESTAT and MCA_DEADDR are supported in this MCA bank. 0=Deferred errors are not supported in this bank." />
      <!-- Bit 1 reserved. -->
      <field name="McaX" bit="0" size="1" desc="Read-only. Reset: 1. 1=This bank provides Machine Check Architecture Extensions. Up to 4 additional MISC registers (MISC1-MISC4) are supported. MCA::IF::MCA_MISC0_IF[BlkPtr] indicates the presence of the additional MISC registers, but is not used to determine their MSR numbers. Deferred error interrupt type is specifiable by MCA bank. MCA::IF::MCA_STATUS_IF[TCC] is present." />
    </register>
    <register name="MCA_IPID_IF" type="msr" msr="0xC0002015" desc="IF IP Identification. Reset: 0001_00B0_0000_0000h. The MCA::IF::MCA_IPID_IF register is used by software to determine what IP type and revision is associated with the MCA bank.">
      <field name="McaType" bit="48" size="16" desc="Read-only. Reset: 0001h. The McaType of the MCA bank within this IP." />
      <!-- Bits 47:44 reserved. -->
      <field name="HardwareID" bit="32" size="12" desc="Read-only. Reset: 0B0h. The Hardware ID of the IP associated with this MCA bank." />
      <field name="InstanceId" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. The instance ID of this IP. This is initialized to a unique ID per instance of this register." />
    </register>
    <register name="MCA_SYND_IF" type="msr" msr="0xC0002016" desc="IF Machine Check Syndrome Thread 0. Read-write,Volatile. Reset: Cold,0000_0000_0000_0000h. Logs physical location information associated with error in MCA::IF::MCA_STATUS_IF Thread 0">
      <!-- Bits 63:33 reserved. -->
      <field name="Syndrome" bit="32" size="1" desc="Read-write,Volatile. Reset: Cold,0. Contains the syndrome, if any, associated with the error logged in MCA::IF::MCA_STATUS_IF. The low-order bit of the syndrome is stored in bit 0, and the syndrome has a length specified by MCA::IF::MCA_SYND_IF[Length]. The Syndrome field is only valid when MCA::IF::MCA_SYND_IF[Length] is not 0." />
      <!-- Bits 31:27 reserved. -->
      <field name="ErrorPriority" bit="24" size="3" desc="Read-write,Volatile. Reset: Cold,0h. Encodes the priority of the error logged in MCA::IF::MCA_SYND_IF. 3'b000 = No error; 3'b001 = Reserved; 3'b010 = Corrected Error; 3'b011 = Deferred Error; 3'b100 = Uncorrected Error; 3'b101 = Fatal Error; all others reserved." />
      <field name="Length" bit="18" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the length in bits of the syndrome contained in MCA::IF::MCA_SYND_IF[Syndrome]. A value of 0 indicates that there is no valid syndrome in MCA::IF::MCA_SYND_IF. For example, a syndrome length of 9 means that MCA::IF::MCA_SYND_IF[Syndrome] bits [8:0] contains a valid syndrome." />
      <field name="ErrorInformation" bit="0" size="18" desc="Read-write,Volatile. Reset: Cold,0_0000h. Contains error-specific information about the location of the error. Decoding is available in Table 38 [MCA_SYND_IF Register]." />
    </register>

    <!-- page 208 -->

    <register name="MCA_CTL_MASK_IF" type="msr" msr="0xC0010401" desc="IF Machine Check Control Mask. Read-write. Reset: 0000_0000_0000_0000h. Inhibit detection of an error source.">
      <!-- Bits 63:14 reserved. -->
      <field name="SystemReadDataError" bit="13" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. System Read Data Error. An error in a demand fetch of a line. Possible reasons include master abort and target abort." />
      <field name="L2RespPoison" bit="12" size="1" desc="Read-write. Reset: 0. L2 Cache Response Poison Error. Error is the result of consuming poison data." />
      <field name="L2BtbMultiHit" bit="11" size="1" desc="Read-write. Reset: 0. L2 BTB Multi-Match Error." />
      <field name="L1BtbMultiHit" bit="10" size="1" desc="Read-write. Reset: 0. L1 BTB Multi-Match Error." />
      <field name="BpqSnpParT1" bit="9" size="1" desc="Read-write. Reset: 0. BPQ Thread 1 Snoop Parity Error." />
      <field name="BpqSnpParT0" bit="8" size="1" desc="Read-write. Reset: 0. BPQ Thread 0 Snoop Parity Error." />
      <field name="L2ItlbParity" bit="7" size="1" desc="Read-write. Reset: 0. L2 ITLB Parity Error." />
      <field name="L1ItlbParity" bit="6" size="1" desc="Read-write. Reset: 0. L1 ITLB Parity Error." />
      <field name="L0ItlbParity" bit="5" size="1" desc="Read-write. Reset: 0. L0 ITLB Parity Error." />
      <field name="DqParity" bit="4" size="1" desc="Read-write. Reset: 0. Decoupling Queue PhysAddr Parity Error." />
      <field name="DataParity" bit="3" size="1" desc="Read-write. Reset: 0. IC Data Array Parity Error." />
      <field name="TagParity" bit="2" size="1" desc="Read-write. Reset: 0. IC Full Tag Parity Error." />
      <field name="TagMultiHit" bit="1" size="1" desc="Read-write. Reset: 0. IC Microtag or Full Tag Multi-hit Error." />
      <field name="OcUtagParity" bit="0" size="1" desc="Read-write. Reset: 0. Op Cache Microtag Probe Port Parity Error." />
    </register>

    <!-- 3.2.5.3 L2 -->

    <!-- page 209 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2020 -->
    <register name="MCA_CTL_L2" type="msr" msr="0x00000408" desc="L2 Machine Check Control. Read-write. Reset: 0000_0000_0000_0000h. 0=Disables error reporting for the corresponding error. 1=Enables error reporting via machine check exception for the corresponding error. The MCA::L2::MCA_CTL_L2 register must be enabled by the corresponding enable bit in Core::X86::Msr::MCG_CTL. Does not affect error detection, correction, or logging.">
      <!-- Bits 63:4 reserved. -->
      <field name="Hwa" bit="3" size="1" desc="Read-write. Reset: 0. Hardware Assert Error." />
      <field name="Data" bit="2" size="1" desc="Read-write. Reset: 0. L2M Data Array ECC Error." />
      <field name="Tag" bit="1" size="1" desc="Read-write. Reset: 0. L2M Tag or State Array ECC Error." />
      <field name="MultiHit" bit="0" size="1" desc="Read-write. Reset: 0. L2M Tag Multiple-Way-Hit error." />
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC000_2021 -->
    <register name="MCA_STATUS_L2" type="msr" msr="0x00000409" desc="L2 Machine Check Status Thread 0. Reset: Cold,0000_0000_0000_0000h. Logs information associated with errors.">
      <field name="Val" bit="63" size="1" desc="Reset: Cold,0. 1=A valid error has been detected. This bit should be cleared by software after the register has been read. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Overflow" bit="62" size="1" desc="Reset: Cold,0. 1=An error was detected while the valid bit (Val) was set; at least one error was not logged. Overflow is set independently of whether the existing error is overwritten. See 3.1.3 [Machine Check Errors]. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="UC" bit="61" size="1" desc="Reset: Cold,0. 1=The error was not corrected by hardware. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="En" bit="60" size="1" desc="Reset: Cold,0. 1=MCA error reporting is enabled for this error, as indicated by the corresponding bit in MCA::L2::MCA_CTL_L2. This bit is a copy of bit in MCA::L2::MCA_CTL_L2 for this error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="MiscV" bit="59" size="1" desc="Reset: Cold,0. 1=Valid thresholding in MCA::L2::MCA_MISC0_L2. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="AddrV" bit="58" size="1" desc="Reset: Cold,0. 1=MCA::L2::MCA_ADDR_L2 contains address information associated with the error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="PCC" bit="57" size="1" desc="Reset: Cold,0. 1=Hardware context held by the processor may have been corrupted. Continued operation of the system may have unpredictable results. The error is not recoverable or survivable, and the system should be reinitialized.  AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="ErrCoreIdVal" bit="56" size="1" desc="Reset: Cold,0. 1=The ErrCoreId field is valid. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="TCC" bit="55" size="1" desc="Reset: Cold,0. 0=The thread which consumed the error can be restarted reliably at the instruction pointer address pushed onto the exception handler stack if any uncorrected error has been corrected by software. 1=The thread which consumed the error is not restartable and must be terminated. Only meaningful when MCA::L2::MCA_STATUS_L2[PCC]=0. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bit 54 reserved. -->
      <field name="SyndV" bit="53" size="1" desc="Reset: Cold,0. 1=This error logged information in MCA::L2::MCA_SYND_L2. If MCA::L2::MCA_SYND_L2[ErrorPriority] is the same as the priority of the error in MCA::L2::MCA_STATUS_L2, then the information in MCA::L2::MCA_SYND_L2 is associated with the error in MCA::L2::MCA_STATUS_L2. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 52:47 reserved. -->
      <field name="CECC" bit="46" size="1" desc="Reset: Cold,0. 1=The error was a correctable ECC error according to the restrictions of the ECC algorithm. UC indicates whether the error was actually corrected by the processor. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="UECC" bit="45" size="1" desc="Reset: Cold,0. 1=The error was an uncorrectable ECC error according to the restrictions of the ECC algorithm. UC indicates whether the error was actually corrected by the processor. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Deferred" bit="44" size="1" desc="Reset: Cold,0. 1=A deferred error was created. A deferred error is the result of an uncorrectable data error which did not immediately cause a processor exception; an exception is deferred until the erroneous data is consumed. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Poison" bit="43" size="1" desc="Reset: Cold,0. 1=The error was the result of attempting to consume poisoned data. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 42:38 reserved. -->
      <field name="ErrCoreId" bit="32" size="6" desc="Reset: Cold,00h. When ErrCoreIdVal=1 this field indicates which core within the processor is associated with the error; Otherwise this field is reserved. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 31:22 reserved. -->
      <field name="ErrorCodeExt" bit="16" size="6" desc="Reset: Cold,00h. Extended Error Code. This field is used to identify the error type for root cause analysis. This field indicates which bit position in MCA::L2::MCA_CTL_L2 enables error reporting for the logged error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="ErrorCode" bit="0" size="16" desc="Reset: Cold,0000h. Error code for this error. See 3.1.3.3 [Error Codes] for details on decoding this field. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
    </register>

    <!-- page 211 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2022 -->
    <register name="MCA_ADDR_L2" type="msr" msr="0x0000040A" desc="L2 Machine Check Address Thread 0. Reset: Cold,0000_0000_0000_0000h. MCA::L2::MCA_ADDR_L2 stores an address and other information associated with the error in MCA::L2::MCA_STATUS_L2. The register is only meaningful if MCA::L2::MCA_STATUS_L2[Val]=1 and MCA::L2::MCA_STATUS_L2[AddrV]=1.">
      <!-- Bits 63:62 reserved. -->
      <field name="LSB" bit="56" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the least significant valid bit of the address contained in MCA::L2::MCA_ADDR_L2[ErrorAddr]. A value of 0 indicates that MCA::L2::MCA_ADDR_L2[55:0] contains a valid byte address. A value of 6 indicates that MCA::L2::MCA_ADDR_L2[55:6] contains a valid cache line address and that MCA::L2::MCA_ADDR_L2[5:0] are not part of the address and should be ignored by error handling software. A value of 12 indicates that MCA::L2::MCA_ADDR_L2[55:12] contain a valid 4KB memory page and that MCA::L2::MCA_ADDR_L2[11:0] should be ignored by error handling software." />
      <field name="ErrorAddr" bit="0" size="56" desc="Read-write,Volatile. Reset: Cold,00_0000_0000_0000h. Unless otherwise specified by an error, contains the address associated with the error logged in MCA::L2::MCA_STATUS_L2. For physical addresses, the most significant bit is given by Core::X86::Cpuid::LongModeInfo[PhysAddrSize]." />
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC000_2023 -->
    <register name="MCA_MISC0_L2" type="msr" msr="0x0000040B" desc="L2 Machine Check Miscellaneous 0 Thread 0. Log miscellaneous information associated with errors.">
      <field name="Valid" bit="63" size="1" desc="Reset: 1. 1=A valid CntP field is present in this register. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="CntP" bit="62" size="1" desc="Reset: 1. 1=A valid threshold counter is present. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="Locked" bit="61" size="1" desc="Reset: 0. 1=Writes to this register are ignored. This bit is set by BIOS to indicate that this register is not available for OS use. BIOS should set this bit if ThresholdIntType is set to SMI. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="IntP" bit="60" size="1" desc="Reset: 1. 1=ThresholdIntType can be used to generate interrupts. 0=ThresholdIntType and interrupt generation are not supported. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::L2::MCA_MISC0_L2[Locked]) ? Read-write : Read-only." />
      <!-- Bits 59:56 reserved. -->
      <field name="LvtOffset" bit="52" size="4" desc="Reset: 0h. One per die. For error thresholding interrupts, specifies the address of the LVT entry in the APIC registers as follows: LVT address = (LvtOffset shifted left 4 bits) + 500h (see Core::X86::Apic::ExtendedInterruptLvtEntries). AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::L2::MCA_MISC0_L2[Locked]) ? Read-write :   Read-only." />
      <field name="CntEn" bit="51" size="1" desc="Reset: 0. 1=Count thresholding errors. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::L2::MCA_MISC0_L2[Locked]) ? Read-write : Read-only." />
      <field name="ThresholdIntType" bit="49" size="2" desc="Reset: Cold,0h. Specifies the type of interrupt signaled when Ovrflw is set and IntP==1. 00b = No interrupt. 01b = APIC based interrupt (see Core::X86::Msr::McaIntrCfg[ThresholdLvtOffset]). 10b = SMI trigger event. 11b = Reserved. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::L2::MCA_MISC0_L2[Locked]) ? Read-write : Read-only." />
      <field name="Ovrflw" bit="48" size="1" desc="Reset: Cold,0. Set by hardware when ErrCnt transitions from FFEh to FFFh. When this field is set, ErrCnt no longer increments. When this bit is set, the interrupt selected by the ThresholdIntType field is generated. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::L2::MCA_MISC0_L2[Locked]) ? Read-write : Read-only." />
      <!-- Bits 47:44 reserved. -->
      <field name="ErrCnt" bit="32" size="12" desc="Reset: Cold,000h. This is written by software to set the starting value of the error counter. This is incremented by hardware when errors are logged. When this counter overflows, it stays at FFFh (no rollover). The threshold value, written by software, is (FFFh - the desired error count (the number of errors necessary in order for an interrupt to be taken)); the desired error count of 0 (a write value of FFFh) is not supported. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::L2::MCA_MISC0_L2[Locked]) ? Read-write : Read-only." />
      <field name="BlkPtr" bit="24" size="8" desc="Read-write. Reset: 01h. 00h=Extended MISC MSR block is not valid. 01h=Extended MSR block is valid." />
      <!-- Bits 23:0 reserved. -->
    </register>

    <!-- page 212 -->

    <register name="MCA_CONFIG_L2" type="msr" msr="0xC0002024" desc="L2 Machine Check Configuration. Reset: 0000_0000_0000_0025h. Controls configuration of the associated machine check bank.">
      <!-- Bits 63:39 reserved. -->
      <field name="DeferredIntType" bit="37" size="2" desc="Read-write. Reset: 0h. Specifies the type of interrupt signaled when a deferred error is logged. 00b = No interrupt. 01b = APIC based interrupt (see Core::X86::Msr::McaIntrCfg[DeferredLvtOffset]). 10b = SMI trigger event. 11b = Reserved." />
      <!-- Bits 36:35 reserved. -->
      <field name="LogDeferredInMcaStat" bit="34" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. 1=Log deferred errors in MCA::L2::MCA_STATUS_L2 and MCA::L2::MCA_ADDR_L2 in addition to MCA::L2::MCA_DESTAT_L2 and MCA::L2::MCA_DEADDR_L2. 0=Only log deferred errors in MCA::L2::MCA_DESTAT_L2 and MCA::L2::MCA_DEADDR_L2. This bit does not affect logging of deferred errors in MCA::L2::MCA_SYND_L2, MCA::L2::MCA_MISC0_L2." />
      <!-- Bit 33 reserved. -->
      <field name="McaXEnable" bit="32" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. Check: 1. 1=Software has acknowledged support for the MCAX feature set. 0=Software has not acknowledged support for the MCAX feature set. All uncorrected and fatal errors will cause an ErrorEvent packet to be generated. Deferred error interrupts are configured via Core::X86::Msr::McaIntrCfg." />
      <!-- Bits 31:6 reserved. -->
      <field name="DeferredIntTypeSupported" bit="5" size="1" desc="Read-only. Reset: 1. 1=MCA::L2::MCA_CONFIG_L2[DeferredIntType] controls the type of interrupt generated on a deferred error. Deferred errors are supported in this bank only if MCA::L2::MCA_CONFIG_L2[DeferredErrorLoggingSupported]=1." />
      <!-- Bits 4:3 reserved. -->
      <field name="DeferredErrorLoggingSupported" bit="2" size="1" desc="Read-only. Reset: 1. 1=Deferred errors are supported in this MCA bank, and MCA::L2::MCA_CONFIG_L2[LogDeferredInMcaStat] controls the logging behavior of these errors.   MCA::L2::MCA_DESTAT_L2 and MCA::L2::MCA_DEADDR_L2 are supported in this MCA bank. 0=Deferred errors are not supported in this bank." />
      <!-- Bit 1 reserved. -->
      <field name="McaX" bit="0" size="1" desc="Read-only. Reset: 1. 1=This bank provides Machine Check Architecture Extensions. Up to 4 additional MISC registers (MISC1-MISC4) are supported. MCA::L2::MCA_MISC0_L2[BlkPtr] indicates the presence of the additional MISC registers, but is not used to determine their MSR numbers. Deferred error interrupt type is specifiable by MCA bank. MCA::L2::MCA_STATUS_L2[TCC] is present." />
    </register>

    <!-- page 213 -->

    <register name="MCA_IPID_L2" type="msr" msr="0xC0002025" desc="L2 IP Identification. Reset: 0002_00B0_0000_0000h. The MCA::L2::MCA_IPID_L2 register is used by software to determine what IP type and revision is associated with the MCA bank.">
      <field name="McaType" bit="48" size="16" desc="Read-only. Reset: 0002h. The McaType of the MCA bank within this IP." />
      <!-- Bits 47:44 reserved. -->
      <field name="HardwareID" bit="32" size="12" desc="Read-only. Reset: 0B0h. The Hardware ID of the IP associated with this MCA bank." />
      <field name="InstanceId" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. The instance ID of this IP. This is initialized to a unique ID per instance of this register." />
    </register>
    <register name="MCA_SYND_L2" type="msr" msr="0xC0002026" desc="L2 Machine Check Syndrome Thread 0. Read-write,Volatile. Reset: Cold,0000_0000_0000_0000h. Logs physical location information associated with error in MCA::L2::MCA_STATUS_L2 Thread 0">
      <!-- Bits 63:49 reserved. -->
      <field name="Syndrome" bit="32" size="17" desc="Read-write,Volatile. Reset: Cold,0_0000h. Contains the syndrome, if any, associated with the error logged in MCA::L2::MCA_STATUS_L2. The low-order bit of the syndrome is stored in bit 0, and the syndrome has a length specified by MCA::L2::MCA_SYND_L2[Length]. The Syndrome field is only valid when MCA::L2::MCA_SYND_L2[Length] is not 0." />
      <!-- Bits 31:27 reserved. -->
      <field name="ErrorPriority" bit="24" size="3" desc="Read-write,Volatile. Reset: Cold,0h. Encodes the priority of the error logged in MCA::L2::MCA_SYND_L2. 3'b000 = No error; 3'b001 = Reserved; 3'b010 = Corrected Error; 3'b011 = Deferred Error; 3'b100 = Uncorrected Error; 3'b101 = Fatal Error; all others reserved." />
      <field name="Length" bit="18" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the length in bits of the syndrome contained in MCA::L2::MCA_SYND_L2[Syndrome]. A value of 0 indicates that there is no valid syndrome in MCA::L2::MCA_SYND_L2. For example, a syndrome length of 9 means that MCA::L2::MCA_SYND_L2[Syndrome] bits [8:0] contains a valid syndrome." />
      <field name="ErrorInformation" bit="0" size="18" desc="Read-write,Volatile. Reset: Cold,0_0000h. Contains error-specific information about the location of the error. Decoding is available in Table 41 [MCA_SYND_L2 Register]." />
    </register>

    <!-- page 214 -->

    <register name="MCA_DESTAT_L2" type="msr" msr="0xC0002028" desc="L2 Machine Check Deferred Error Status Thread 0. Read-write,Volatile. Reset: Cold,0000_0000_0000_0000h. Holds status information for the first deferred error seen in this bank.">
      <field name="Val" bit="63" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=A valid error has been detected (whether it is enabled or not)." />
      <field name="Overflow" bit="62" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=An error was detected while the valid bit (Val) was set; at least one error was not logged. Overflow is set independently of whether the existing error is overwritten. (See the section on overwrite priorities.)" />
      <!-- Bits 61:59 reserved. -->
      <field name="AddrV" bit="58" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=MCA::L2::MCA_DEADDR_L2 contains address information associated with the error." />
      <!-- Bits 57:54 reserved. -->
      <field name="SyndV" bit="53" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=This error logged information in MCA::L2::MCA_SYND_L2. If MCA::L2::MCA_SYND_L2[ErrorPriority] is the same as the priority of the error in MCA::L2::MCA_STATUS_L2, then the information in MCA::L2::MCA_SYND_L2 is associated with the error in MCA::L2::MCA_DESTAT_L2." />
      <!-- Bits 52:45 reserved. -->
      <field name="Deferred" bit="44" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=A deferred error was created. A deferred error is the result of an uncorrectable data error which did not immediately cause a processor exception; poison is created and an exception is deferred until the poison data is consumed." />
      <!-- Bits 43:0 reserved. -->
    </register>
    <register name="MCA_DEADDR_L2" type="msr" msr="0xC0002029" desc="L2 Deferred Error Address Thread 0. Reset: Cold,0000_0000_0000_0000h. The MCA::L2::MCA_DEADDR_L2 register stores the address associated with the error in MCA::L2::MCA_DESTAT_L2. The register is only meaningful if MCA::L2::MCA_DESTAT_L2[Val]=1 and MCA::L2::MCA_DESTAT_L2[AddrV]=1. The lowest valid bit of the address is defined by MCA::L2::MCA_DEADDR_L2[LSB].">
      <!-- Bits 63:62 reserved. -->
      <field name="LSB" bit="56" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the least significant valid bit of the address contained in MCA::L2::MCA_DEADDR_L2[ErrorAddr]. A value of 0 indicates that MCA::L2::MCA_DEADDR_L2[55:0] contains a valid byte address. A value of 6 indicates that MCA::L2::MCA_DEADDR_L2[55:6] contains a valid cache line address and that MCA::L2::MCA_DEADDR_L2[5:0] are not part of the address and should be ignored by error handling software. A value of 12 indicates that MCA::L2::MCA_DEADDR_L2[55:12] contain a valid 4KB memory page and that MCA::L2::MCA_DEADDR_L2[11:0] should be ignored by error handling software." />
      <field name="ErrorAddr" bit="0" size="56" desc="Read-write,Volatile. Reset: Cold,00_0000_0000_0000h. Contains the address, if any, associated with the error logged in MCA::L2::MCA_DESTAT_L2. The lowest-order valid bit of the address is specified in MCA::L2::MCA_DEADDR_L2[LSB]." />
    </register>

    <!-- page 215 -->

    <register name="MCA_CTL_MASK_L2" type="msr" msr="0xC0010402" desc="L2 Machine Check Control Mask. Read-write. Reset: 0000_0000_0000_0000h. Inhibit detection of an error source.">
      <!-- Bits 63:4 reserved. -->
      <field name="Hwa" bit="3" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. Hardware Assert Error." />
      <field name="Data" bit="2" size="1" desc="Read-write. Reset: 0. L2M Data Array ECC Error." />
      <field name="Tag" bit="1" size="1" desc="Read-write. Reset: 0. L2M Tag or State Array ECC Error." />
      <field name="MultiHit" bit="0" size="1" desc="Read-write. Reset: 0. L2M Tag Multiple-Way-Hit error." />
    </register>

    <!-- 3.2.5.4 DE -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2030 -->
    <register name="MCA_CTL_DE" type="msr" msr="0x0000040C" desc="DE Machine Check Control. Read-write. Reset: 0000_0000_0000_0000h. 0=Disables error reporting for the corresponding error. 1=Enables error reporting via machine check exception for the corresponding error. The MCA::DE::MCA_CTL_DE register must be enabled by the corresponding enable bit in Core::X86::Msr::MCG_CTL. Does not affect error detection, correction, or logging.">
      <!-- Bits 63:9 reserved. -->
      <field name="OCBQ" bit="8" size="1" desc="Read-write. Reset: 0. Micro-op buffer parity error." />
      <field name="UcSeq" bit="7" size="1" desc="Read-write. Reset: 0. Patch RAM sequencer parity error." />
      <field name="UcDat" bit="6" size="1" desc="Read-write. Reset: 0. Patch RAM data parity error." />
      <field name="Faq" bit="5" size="1" desc="Read-write. Reset: 0. Fetch address FIFO parity error." />
      <field name="Idq" bit="4" size="1" desc="Read-write. Reset: 0. Instruction dispatch queue parity error." />
      <field name="UopQ" bit="3" size="1" desc="Read-write. Reset: 0. Micro-op queue parity error." />
      <field name="Ibq" bit="2" size="1" desc="Read-write. Reset: 0. Instruction buffer parity error." />
      <field name="OcDat" bit="1" size="1" desc="Read-write. Reset: 0. Micro-op cache data parity error." />
      <field name="OcTag" bit="0" size="1" desc="Read-write. Reset: 0. Micro-op cache tag parity error." />
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC000_2031 -->
    <register name="MCA_STATUS_DE" type="msr" msr="0x0000040D" desc="DE Machine Check Status Thread 0. Reset: Cold,0000_0000_0000_0000h. Logs information associated with errors.">
      <field name="Val" bit="63" size="1" desc="Reset: Cold,0. 1=A valid error has been detected. This bit should be cleared by software after the register has been read. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Overflow" bit="62" size="1" desc="Reset: Cold,0. 1=An error was detected while the valid bit (Val) was set; at least one error was not logged. Overflow is set independently of whether the existing error is overwritten. See 3.1.3 [Machine Check Errors]. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="UC" bit="61" size="1" desc="Reset: Cold,0. 1=The error was not corrected by hardware. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="En" bit="60" size="1" desc="Reset: Cold,0. 1=MCA error reporting is enabled for this error, as indicated by the corresponding bit in MCA::DE::MCA_CTL_DE. This bit is a copy of bit in MCA::DE::MCA_CTL_DE for this error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="MiscV" bit="59" size="1" desc="Reset: Cold,0. 1=Valid thresholding in MCA::DE::MCA_MISC0_DE. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="AddrV" bit="58" size="1" desc="Reset: Cold,0. 1=MCA::DE::MCA_ADDR_DE contains address information associated with the error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="PCC" bit="57" size="1" desc="Reset: Cold,0. 1=Hardware context held by the processor may have been corrupted. Continued operation of the system may have unpredictable results. The error is not recoverable or survivable, and the system should be  reinitialized. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="ErrCoreIdVal" bit="56" size="1" desc="Reset: Cold,0. 1=The ErrCoreId field is valid. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="TCC" bit="55" size="1" desc="Reset: Cold,0. 0=The thread which consumed the error can be restarted reliably at the instruction pointer address pushed onto the exception handler stack if any uncorrected error has been corrected by software. 1=The thread which consumed the error is not restartable and must be terminated. Only meaningful when MCA::DE::MCA_STATUS_DE[PCC]=0. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bit 54 reserved. -->
      <field name="SyndV" bit="53" size="1" desc="Reset: Cold,0. 1=This error logged information in MCA::DE::MCA_SYND_DE. If MCA::DE::MCA_SYND_DE[ErrorPriority] is the same as the priority of the error in MCA::DE::MCA_STATUS_DE, then the information in MCA::DE::MCA_SYND_DE is associated with the error in MCA::DE::MCA_STATUS_DE. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 52:47 reserved. -->
      <field name="CECC" bit="46" size="1" desc="Reset: Cold,0. 1=The error was a correctable ECC error according to the restrictions of the ECC algorithm. UC indicates whether the error was actually corrected by the processor. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="UECC" bit="45" size="1" desc="Reset: Cold,0. 1=The error was an uncorrectable ECC error according to the restrictions of the ECC algorithm. UC indicates whether the error was actually corrected by the processor. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Deferred" bit="44" size="1" desc="Reset: Cold,0. 1=A deferred error was created. A deferred error is the result of an uncorrectable data error which did not immediately cause a processor exception; an exception is deferred until the erroneous data is consumed. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Poison" bit="43" size="1" desc="Reset: Cold,0. 1=The error was the result of attempting to consume poisoned data. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 42:38 reserved. -->
      <field name="ErrCoreId" bit="32" size="6" desc="Reset: Cold,00h. When ErrCoreIdVal=1 this field indicates which core within the processor is associated with the error; Otherwise this field is reserved. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 31:22 reserved. -->
      <field name="ErrorCodeExt" bit="16" size="6" desc="Reset: Cold,00h. Extended Error Code. This field is used to identify the error type for root cause analysis. This field indicates which bit position in MCA::DE::MCA_CTL_DE enables error reporting for the logged error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="ErrorCode" bit="0" size="16" desc="Reset: Cold,0000h. Error code for this error. See 3.1.3.3 [Error Codes] for details on decoding this field. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
    </register>

    <!-- page 217 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2032 -->
    <register name="MCA_ADDR_DE" type="msr" msr="0x0000040E" desc="DE Machine Check Address Thread 0. Reset: Cold,0000_0000_0000_0000h. MCA::DE::MCA_ADDR_DE stores an address and other information associated with the error in MCA::DE::MCA_STATUS_DE. The register is only meaningful if MCA::DE::MCA_STATUS_DE[Val]=1 and MCA::DE::MCA_STATUS_DE[AddrV]=1.">
      <!-- Bits 63:62 reserved. -->
      <field name="LSB" bit="56" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the least significant valid bit of the address contained in MCA::DE::MCA_ADDR_DE[ErrorAddr]. A value of 0 indicates that MCA::DE::MCA_ADDR_DE[55:0] contains a valid byte address. A value of 6 indicates that MCA::DE::MCA_ADDR_DE[55:6] contains a valid cache line address and that MCA::DE::MCA_ADDR_DE[5:0] are not part of the address and should be ignored by error handling software. A value of 12 indicates that MCA::DE::MCA_ADDR_DE[55:12] contain a valid 4KB memory page and that MCA::DE::MCA_ADDR_DE[11:0] should be ignored by error handling software." />
      <field name="ErrorAddr" bit="0" size="56" desc="Read-write,Volatile. Reset: Cold,00_0000_0000_0000h. Unless otherwise specified by an error, contains the address associated with the error logged in MCA::DE::MCA_STATUS_DE. For physical addresses, the most significant bit is given by Core::X86::Cpuid::LongModeInfo[PhysAddrSize]." />
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC000_2033 -->
    <register name="MCA_MISC0_DE" type="msr" msr="0x0000040F" desc="DE Machine Check Miscellaneous 0 Thread 0. Log miscellaneous information associated with errors.">
      <field name="Valid" bit="63" size="1" desc="Reset: 1. 1=A valid CntP field is present in this register. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="CntP" bit="62" size="1" desc="Reset: 1. 1=A valid threshold counter is present. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="Locked" bit="61" size="1" desc="Reset: 0. 1=Writes to this register are ignored. This bit is set by BIOS to indicate that this register is not available for OS use. BIOS should set this bit if ThresholdIntType is set to SMI. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="IntP" bit="60" size="1" desc="Reset: 1. 1=ThresholdIntType can be used to generate interrupts. 0=ThresholdIntType and interrupt generation are not supported. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::DE::MCA_MISC0_DE[Locked]) ? Read-write :  Read-only." />
      <!-- Bits 59:56 reserved. -->
      <field name="LvtOffset" bit="52" size="4" desc="Reset: 0h. One per die. For error thresholding interrupts, specifies the address of the LVT entry in the APIC registers as follows: LVT address = (LvtOffset shifted left 4 bits) + 500h (see Core::X86::Apic::ExtendedInterruptLvtEntries). AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::DE::MCA_MISC0_DE[Locked]) ? Read-write : Read-only." />
      <field name="CntEn" bit="51" size="1" desc="Reset: 0. 1=Count thresholding errors. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::DE::MCA_MISC0_DE[Locked]) ? Read-write : Read-only." />
      <field name="ThresholdIntType" bit="49" size="2" desc="Reset: Cold,0h. Specifies the type of interrupt signaled when Ovrflw is set and IntP==1. 00b = No interrupt. 01b = APIC based interrupt (see Core::X86::Msr::McaIntrCfg[ThresholdLvtOffset]). 10b = SMI trigger event. 11b = Reserved. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::DE::MCA_MISC0_DE[Locked]) ? Read-write : Read-only." />
      <field name="Ovrflw" bit="48" size="1" desc="Reset: Cold,0. Set by hardware when ErrCnt transitions from FFEh to FFFh. When this field is set, ErrCnt no longer increments. When this bit is set, the interrupt selected by the ThresholdIntType field is generated. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::DE::MCA_MISC0_DE[Locked]) ? Read-write : Read-only." />
      <!-- Bits 47:44 reserved. -->
      <field name="ErrCnt" bit="32" size="12" desc="Reset: Cold,000h. This is written by software to set the starting value of the error counter. This is incremented by hardware when errors are logged. When this counter overflows, it stays at FFFh (no rollover). The threshold value, written by software, is (FFFh - the desired error count (the number of errors necessary in order for an interrupt to be taken)); the desired error count of 0 (a write value of FFFh) is not supported. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::DE::MCA_MISC0_DE[Locked]) ? Read-write : Read-only." />
      <field name="BlkPtr" bit="24" size="8" desc="Read-write. Reset: 01h. 00h=Extended MISC MSR block is not valid. 01h=Extended MSR block is valid." />
      <!-- Bits 23:0 reserved. -->
    </register>

    <!-- page 218 -->

    <register name="MCA_CONFIG_DE" type="msr" msr="0xC0002034" desc="DE Machine Check Configuration. Reset: 0000_0002_0000_0021h. Controls configuration of the associated machine check bank.">
      <!-- Bits 63:39 reserved. -->
      <field name="DeferredIntType" bit="37" size="2" desc="Read-write. Reset: 0h. Specifies the type of interrupt signaled when a deferred error is logged. 00b = No interrupt. 01b = APIC based interrupt (see Core::X86::Msr::McaIntrCfg[DeferredLvtOffset]). 10b = SMI trigger event. 11b = Reserved." />
      <!-- Bits 36:33 reserved. -->
      <field name="McaXEnable" bit="32" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. Check: 1. 1=Software has acknowledged support for the MCAX feature set. 0=Software has not acknowledged support for the MCAX feature set. All uncorrected and fatal errors will cause an ErrorEvent packet to be generated. Deferred error interrupts are configured via Core::X86::Msr::McaIntrCfg." />
      <!-- Bits 31:6 reserved. -->
      <field name="DeferredIntTypeSupported" bit="5" size="1" desc="Read-only. Reset: 1. 1=MCA::DE::MCA_CONFIG_DE[DeferredIntType] controls the type of interrupt generated on a deferred error. Deferred errors are supported in this bank only if MCA::DE::MCA_CONFIG_DE[DeferredErrorLoggingSupported]=1." />
      <!-- Bits 4:3 reserved. -->
      <field name="DeferredErrorLoggingSupported" bit="2" size="1" desc="Read-only. Reset: 0. 1=Deferred errors are supported in this MCA bank, and the LogDeferredInMcaStat field in this register controls the logging behavior of these errors. MCA_DESTAT and   MCA_DEADDR are supported in this MCA bank. 0=Deferred errors are not supported in this bank." />
      <!-- Bit 1 reserved. -->
      <field name="McaX" bit="0" size="1" desc="Read-only. Reset: 1. 1=This bank provides Machine Check Architecture Extensions. Up to 4 additional MISC registers (MISC1-MISC4) are supported. MCA::DE::MCA_MISC0_DE[BlkPtr] indicates the presence of the additional MISC registers, but is not used to determine their MSR numbers. Deferred error interrupt type is specifiable by MCA bank. MCA::DE::MCA_STATUS_DE[TCC] is present." />
    </register>

    <!-- page 219 -->

    <register name="MCA_IPID_DE" type="msr" msr="0xC0002035" desc="DE IP Identification. Reset: 0003_00B0_0000_0000h. The MCA::DE::MCA_IPID_DE register is used by software to determine what IP type and revision is associated with the MCA bank.">
      <field name="McaType" bit="48" size="16" desc="Read-only. Reset: 0003h. The McaType of the MCA bank within this IP." />
      <!-- Bits 47:44 reserved. -->
      <field name="HardwareID" bit="32" size="12" desc="Read-only. Reset: 0B0h. The Hardware ID of the IP associated with this MCA bank." />
      <field name="InstanceId" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. The instance ID of this IP. This is initialized to a unique ID per instance of this register." />
    </register>
    <register name="MCA_SYND_DE" type="msr" msr="0xC0002036" desc="DE Machine Check Syndrome Thread 0. Read-write,Volatile. Reset: Cold,0000_0000_0000_0000h. Logs physical location information associated with error in MCA::DE::MCA_STATUS_DE Thread 0">
      <!-- Bits 63:33 reserved. -->
      <field name="Syndrome" bit="32" size="1" desc="Read-write,Volatile. Reset: Cold,0. Contains the syndrome, if any, associated with the error logged in MCA::DE::MCA_STATUS_DE. The low-order bit of the syndrome is stored in bit 0, and the syndrome has a length specified by MCA::DE::MCA_SYND_DE[Length]. The Syndrome field is only valid when MCA::DE::MCA_SYND_DE[Length] is not 0." />
      <!-- Bits 31:27 reserved. -->
      <field name="ErrorPriority" bit="24" size="3" desc="Read-write,Volatile. Reset: Cold,0h. Encodes the priority of the error logged in MCA::DE::MCA_SYND_DE. 3'b000 = No error; 3'b001 = Reserved; 3'b010 = Corrected Error; 3'b011 = Deferred Error; 3'b100 = Uncorrected Error; 3'b101 = Fatal Error; all others reserved." />
      <field name="Length" bit="18" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the length in bits of the syndrome contained in MCA::DE::MCA_SYND_DE[Syndrome]. A value of 0 indicates that there is no valid syndrome in MCA::DE::MCA_SYND_DE. For example, a syndrome length of 9 means that MCA::DE::MCA_SYND_DE[Syndrome] bits [8:0] contains a valid syndrome." />
      <field name="ErrorInformation" bit="0" size="18" desc="Read-write,Volatile. Reset: Cold,0_0000h. Contains error-specific information about the location of the error. Decoding is available in Table 44 [MCA_SYND_DE Register]." />
    </register>

    <!-- page 220 -->

    <register name="MCA_CTL_MASK_DE" type="msr" msr="0xC0010403" desc="DE Machine Check Control Mask. Read-write. Reset: 0000_0000_0000_0000h. Inhibit detection of an error source.">
      <!-- Bits 63:9 reserved. -->
      <field name="OCBQ" bit="8" size="1" desc="Read-write. Reset: 0. Micro-op buffer parity error." />
      <field name="UcSeq" bit="7" size="1" desc="Read-write. Reset: 0. Patch RAM sequencer parity error." />
      <field name="UcDat" bit="6" size="1" desc="Read-write. Reset: 0. Patch RAM data parity error." />
      <field name="Faq" bit="5" size="1" desc="Read-write. Reset: 0. Fetch address FIFO parity error." />
      <field name="Idq" bit="4" size="1" desc="Read-write. Reset: 0. Instruction dispatch queue parity error." />
      <field name="UopQ" bit="3" size="1" desc="Read-write. Reset: 0. Micro-op queue parity error." />
      <field name="Ibq" bit="2" size="1" desc="Read-write. Reset: 0. Instruction buffer parity error." />
      <field name="OcDat" bit="1" size="1" desc="Read-write. Reset: 0. Micro-op cache data parity error." />
      <field name="OcTag" bit="0" size="1" desc="Read-write. Reset: 0. Micro-op cache tag parity error." />
    </register>

    <!-- 3.2.5.5 EX -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2050 -->
    <register name="MCA_CTL_EX" type="msr" msr="0x00000414" desc="EX Machine Check Control. Read-write. Reset: 0000_0000_0000_0000h. 0=Disables error reporting for the corresponding error. 1=Enables error reporting via machine check exception for the corresponding error. The MCA::EX::MCA_CTL_EX register must be enabled by the corresponding enable bit in Core::X86::Msr::MCG_CTL. Does not affect error detection, correction, or logging.">
      <!-- Bits 63:11 reserved. -->
      <field name="BBQ" bit="10" size="1" desc="Read-write. Reset: 0. Branch buffer queue parity error." />
      <field name="SQ" bit="9" size="1" desc="Read-write. Reset: 0. Scheduling queue parity error." />
      <field name="STATQ" bit="8" size="1" desc="Read-write. Reset: 0. Retire status queue parity error." />
      <field name="RETDISP" bit="7" size="1" desc="Read-write. Reset: 0. Retire dispatch queue parity error." />
      <field name="CHKPTQ" bit="6" size="1" desc="Read-write. Reset: 0. CHKPTQ. Checkpoint queue parity error." />
      <field name="PLDAL" bit="5" size="1" desc="Read-write. Reset: 0. EX payload parity error." />
      <field name="PLDAG" bit="4" size="1" desc="Read-write. Reset: 0. Address generator payload parity error." />
      <field name="IDRF" bit="3" size="1" desc="Read-write. Reset: 0. Immediate displacement register file parity error." />
      <field name="FRF" bit="2" size="1" desc="Read-write. Reset: 0. Flag register file parity error." />
      <field name="PRF" bit="1" size="1" desc="Read-write. Reset: 0. Physical register file parity error." />
      <field name="WDT" bit="0" size="1" desc="Read-write. Reset: 0. Watchdog Timeout error." />
    </register>

    <!-- page 221 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2051 -->
    <register name="MCA_STATUS_EX" type="msr" msr="0x00000415" desc="EX Machine Check Status Thread 0. Reset: Cold,0000_0000_0000_0000h. Logs information associated with errors.">
      <field name="Val" bit="63" size="1" desc="Reset: Cold,0. 1=A valid error has been detected. This bit should be cleared by software after the register has been read. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Overflow" bit="62" size="1" desc="Reset: Cold,0. 1=An error was detected while the valid bit (Val) was set; at least one error was not logged. Overflow is set independently of whether the existing error is overwritten. See 3.1.3 [Machine Check Errors]. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="UC" bit="61" size="1" desc="Reset: Cold,0. 1=The error was not corrected by hardware. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="En" bit="60" size="1" desc="Reset: Cold,0. 1=MCA error reporting is enabled for this error, as indicated by the corresponding bit in MCA::EX::MCA_CTL_EX. This bit is a copy of bit in MCA::EX::MCA_CTL_EX for this error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="MiscV" bit="59" size="1" desc="Reset: Cold,0. 1=Valid thresholding in MCA::EX::MCA_MISC0_EX. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="AddrV" bit="58" size="1" desc="Reset: Cold,0. 1=MCA::EX::MCA_ADDR_EX contains address information associated with the error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="PCC" bit="57" size="1" desc="Reset: Cold,0. 1=Hardware context held by the processor may have been corrupted. Continued operation of the system may have unpredictable results. The error is not recoverable or survivable, and the system should be reinitialized. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="ErrCoreIdVal" bit="56" size="1" desc="Reset: Cold,0. 1=The ErrCoreId field is valid. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="TCC" bit="55" size="1" desc="Reset: Cold,0. 0=The thread which consumed the error can be restarted reliably at the instruction pointer address pushed onto the exception handler stack if any uncorrected error has been corrected by software. 1=The thread which consumed the error is not restartable and must be terminated. Only meaningful when MCA::EX::MCA_STATUS_EX[PCC]=0. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bit 54 reserved. -->
      <field name="SyndV" bit="53" size="1" desc="Reset: Cold,0. 1=This error logged information in MCA::EX::MCA_SYND_EX. If MCA::EX::MCA_SYND_EX[ErrorPriority] is the same as the priority of the error in MCA::EX::MCA_STATUS_EX, then the information in MCA::EX::MCA_SYND_EX is associated with the error in MCA::EX::MCA_STATUS_EX. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 52:47 reserved. -->
      <field name="CECC" bit="46" size="1" desc="Reset: Cold,0. 1=The error was a correctable ECC error according to the restrictions of the ECC algorithm. UC indicates whether the error was actually corrected by the processor. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="UECC" bit="45" size="1" desc="Reset: Cold,0. 1=The error was an uncorrectable ECC error according to the restrictions of the ECC algorithm. UC indicates whether the error was actually corrected by the processor. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Deferred" bit="44" size="1" desc="Reset: Cold,0. 1=A deferred error was created. A deferred error is the result of an uncorrectable data error which did not immediately cause a processor exception; an exception is deferred until the erroneous data is consumed. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Poison" bit="43" size="1" desc="Reset: Cold,0. 1=The error was the result of attempting to consume poisoned data. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 42:38 reserved. -->
      <field name="ErrCoreId" bit="32" size="6" desc="Reset: Cold,00h. When ErrCoreIdVal=1 this field indicates which core within the processor is associated with the error; Otherwise this field is reserved.   AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 31:22 reserved. -->
      <field name="ErrorCodeExt" bit="16" size="6" desc="Reset: Cold,00h. Extended Error Code. This field is used to identify the error type for root cause analysis. This field indicates which bit position in MCA::EX::MCA_CTL_EX enables error reporting for the logged error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="ErrorCode" bit="0" size="16" desc="Reset: Cold,0000h. Error code for this error. See 3.1.3.3 [Error Codes] for details on decoding this field. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
    </register>

    <!-- page 222 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2052 -->
    <register name="MCA_ADDR_EX" type="msr" msr="0x00000416" desc="EX Machine Check Address Thread 0. Read-only. Reset: Cold,0000_0000_0000_0000h. MCA::EX::MCA_ADDR_EX stores an address and other information associated with the error in MCA::EX::MCA_STATUS_EX. The register is only meaningful if MCA::EX::MCA_STATUS_EX[Val]=1 and MCA::EX::MCA_STATUS_EX[AddrV]=1.">
      <!-- Bits 63:62 reserved. -->
      <field name="LSB" bit="56" size="6" desc="Read-only. Reset: Cold,00h. Specifies the least significant valid bit of the address contained in MCA::EX::MCA_ADDR_EX[ErrorAddr]. A value of 0 indicates that MCA::EX::MCA_ADDR_EX[55:0] contains a valid byte address. A value of 6 indicates that MCA::EX::MCA_ADDR_EX[55:6] contains a valid cache line address and that MCA::EX::MCA_ADDR_EX[5:0] are not part of the address and should be ignored by error handling software. A value of 12 indicates that MCA::EX::MCA_ADDR_EX[55:12] contain a valid 4KB memory page and that MCA::EX::MCA_ADDR_EX[11:0] should be ignored by error handling software." />
      <field name="ErrorAddr" bit="0" size="56" desc="Read-only. Reset: Cold,00_0000_0000_0000h. Contains the address, if any, associated with the error logged in MCA::EX::MCA_STATUS_EX." />
    </register>

    <!-- page 223 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2053 -->
    <register name="MCA_MISC0_EX" type="msr" msr="0x00000417" desc="EX Machine Check Miscellaneous 0 Thread 0. Log miscellaneous information associated with errors.">
      <field name="Valid" bit="63" size="1" desc="Reset: 1. 1=A valid CntP field is present in this register. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="CntP" bit="62" size="1" desc="Reset: 1. 1=A valid threshold counter is present. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="Locked" bit="61" size="1" desc="Reset: 0. 1=Writes to this register are ignored. This bit is set by BIOS to indicate that this register is not available for OS use. BIOS should set this bit if ThresholdIntType is set to SMI. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="IntP" bit="60" size="1" desc="Reset: 1. 1=ThresholdIntType can be used to generate interrupts. 0=ThresholdIntType and interrupt generation are not supported. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::EX::MCA_MISC0_EX[Locked]) ? Read-write : Read-only." />
      <!-- Bits 59:56 reserved. -->
      <field name="LvtOffset" bit="52" size="4" desc="Reset: 0h. One per die. For error thresholding interrupts, specifies the address of the LVT entry in the APIC registers as follows: LVT address = (LvtOffset shifted left 4 bits) + 500h (see Core::X86::Apic::ExtendedInterruptLvtEntries). AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::EX::MCA_MISC0_EX[Locked]) ? Read-write : Read-only." />
      <field name="CntEn" bit="51" size="1" desc="Reset: 0. 1=Count thresholding errors. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::EX::MCA_MISC0_EX[Locked]) ? Read-write : Read-only." />
      <field name="ThresholdIntType" bit="49" size="2" desc="Reset: Cold,0h. Specifies the type of interrupt signaled when Ovrflw is set and IntP==1. 00b = No interrupt. 01b = APIC based interrupt (see Core::X86::Msr::McaIntrCfg[ThresholdLvtOffset]). 10b = SMI trigger event. 11b = Reserved. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::EX::MCA_MISC0_EX[Locked]) ? Read-write : Read-only." />
      <field name="Ovrflw" bit="48" size="1" desc="Reset: Cold,0. Set by hardware when ErrCnt transitions from FFEh to FFFh. When this field is set, ErrCnt no longer increments. When this bit is set, the interrupt selected by the ThresholdIntType field is generated. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::EX::MCA_MISC0_EX[Locked]) ? Read-write : Read-only." />
      <!-- Bits 47:44 reserved. -->
      <field name="ErrCnt" bit="32" size="12" desc="Reset: Cold,000h. This is written by software to set the starting value of the error counter. This is incremented by hardware when errors are logged. When this counter overflows, it stays at FFFh (no rollover). The threshold value, written by software, is (FFFh - the desired error count (the number of errors necessary in order for an interrupt to be taken)); the desired error count of 0 (a write value of FFFh) is not supported. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::EX::MCA_MISC0_EX[Locked]) ? Read-write : Read-only." />
      <field name="BlkPtr" bit="24" size="8" desc="Read-write. Reset: 01h. 00h=Extended MISC MSR block is not valid. 01h=Extended MSR block is valid." />
      <!-- Bits 23:0 reserved. -->
    </register>

    <!-- page 224 -->

    <register name="MCA_CONFIG_EX" type="msr" msr="0xC0002054" desc="EX Machine Check Configuration. Reset: 0000_0002_0000_0021h. Controls configuration of the associated machine check bank.">
      <!-- Bits 63:39 reserved. -->
      <field name="DeferredIntType" bit="37" size="2" desc="Read-write. Reset: 0h. Specifies the type of interrupt signaled when a deferred error is logged. 00b = No interrupt. 01b = APIC based interrupt (see Core::X86::Msr::McaIntrCfg[DeferredLvtOffset]). 10b = SMI trigger event. 11b = Reserved." />
      <!-- Bits 36:33 reserved. -->
      <field name="McaXEnable" bit="32" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. Check: 1. 1=Software has acknowledged support for the MCAX feature set. 0=Software has not acknowledged support for the MCAX feature set. All uncorrected and fatal errors will cause an ErrorEvent packet to be generated. Deferred error interrupts are configured via Core::X86::Msr::McaIntrCfg." />
      <!-- Bits 31:6 reserved. -->
      <field name="DeferredIntTypeSupported" bit="5" size="1" desc="Read-only. Reset: 1. 1=MCA::EX::MCA_CONFIG_EX[DeferredIntType] controls the type of interrupt generated on a deferred error. Deferred errors are supported in this bank only if MCA::EX::MCA_CONFIG_EX[DeferredErrorLoggingSupported]=1." />
      <!-- Bits 4:3 reserved. -->
      <field name="DeferredErrorLoggingSupported" bit="2" size="1" desc="Read-only. Reset: 0. 1=Deferred errors are supported in this MCA bank, and the LogDeferredInMcaStat field in this register controls the logging behavior of these errors. MCA_DESTAT and MCA_DEADDR are supported in this MCA bank. 0=Deferred errors are not supported in this bank." />
      <!-- Bit 1 reserved. -->
      <field name="McaX" bit="0" size="1" desc="Read-only. Reset: 1. 1=This bank provides Machine Check Architecture Extensions. Up to 4 additional MISC registers (MISC1-MISC4) are supported. MCA::EX::MCA_MISC0_EX[BlkPtr] indicates the presence of the additional MISC registers, but is not used to determine their MSR numbers. Deferred error interrupt type is specifiable by MCA bank. MCA::EX::MCA_STATUS_EX[TCC] is present." />
    </register>
    <register name="MCA_IPID_EX" type="msr" msr="0xC0002055" desc="EX IP Identification. Reset: 0005_00B0_0000_0000h. The MCA::EX::MCA_IPID_EX register is used by software to determine what IP type and revision is associated with the MCA bank.">
      <field name="McaType" bit="48" size="16" desc="Read-only. Reset: 0005h. The McaType of the MCA bank within this IP." />
      <!-- Bits 47:44 reserved. -->
      <field name="HardwareID" bit="32" size="12" desc="Read-only. Reset: 0B0h. The Hardware ID of the IP associated with this MCA bank." />
      <field name="InstanceId" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. The instance ID of this IP. This is initialized to a unique ID per instance of this register." />
    </register>
    <register name="MCA_SYND_EX" type="msr" msr="0xC0002056" desc="EX Machine Check Syndrome Thread 0. Read-write,Volatile. Reset: Cold,0000_0000_0000_0000h. Logs physical location information associated with error in MCA::EX::MCA_STATUS_EX Thread 0">
      <!-- Bits 63:33 reserved. -->
      <field name="Syndrome" bit="32" size="1" desc="Read-write,Volatile. Reset: Cold,0. Contains the syndrome, if any, associated with the error logged in MCA::EX::MCA_STATUS_EX. The low-order bit of the syndrome is stored in bit 0, and the syndrome has a length specified by MCA::EX::MCA_SYND_EX[Length]. The Syndrome field is only valid when  MCA::EX::MCA_SYND_EX[Length] is not 0." />
      <!-- Bits 31:27 reserved. -->
      <field name="ErrorPriority" bit="24" size="3" desc="Read-write,Volatile. Reset: Cold,0h. Encodes the priority of the error logged in MCA::EX::MCA_SYND_EX. 3'b000 = No error; 3'b001 = Reserved; 3'b010 = Corrected Error; 3'b011 = Deferred Error; 3'b100 = Uncorrected Error; 3'b101 = Fatal Error; all others reserved." />
      <field name="Length" bit="18" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the length in bits of the syndrome contained in MCA::EX::MCA_SYND_EX[Syndrome]. A value of 0 indicates that there is no valid syndrome in MCA::EX::MCA_SYND_EX. For example, a syndrome length of 9 means that MCA::EX::MCA_SYND_EX[Syndrome] bits [8:0] contains a valid syndrome." />
      <field name="ErrorInformation" bit="0" size="18" desc="Read-write,Volatile. Reset: Cold,0_0000h. Contains error-specific information about the location of the error. Decoding is available in Table 47 [MCA_SYND_EX Register]." />
    </register>

    <!-- page 225 -->

    <register name="MCA_CTL_MASK_EX" type="msr" msr="0xC0010405" desc="EX Machine Check Control Mask. Read-write. Reset: 0000_0000_0000_0000h. Inhibit detection of an error source.">
      <!-- Bits 63:11 reserved. -->
      <field name="BBQ" bit="10" size="1" desc="Read-write. Reset: 0. Branch buffer queue parity error." />
      <field name="SQ" bit="9" size="1" desc="Read-write. Reset: 0. Scheduling queue parity error." />
      <field name="STATQ" bit="8" size="1" desc="Read-write. Reset: 0. Retire status queue parity error." />
      <field name="RETDISP" bit="7" size="1" desc="Read-write. Reset: 0. Retire dispatch queue parity error." />
      <field name="CHKPTQ" bit="6" size="1" desc="Read-write. Reset: 0. CHKPTQ. Checkpoint queue parity error." />
      <field name="PLDAL" bit="5" size="1" desc="Read-write. Reset: 0. EX payload parity error." />
      <field name="PLDAG" bit="4" size="1" desc="Read-write. Reset: 0. Address generator payload parity error." />
      <field name="IDRF" bit="3" size="1" desc="Read-write. Reset: 0. Immediate displacement register file parity error." />
      <field name="FRF" bit="2" size="1" desc="Read-write. Reset: 0. Flag register file parity error." />
      <field name="PRF" bit="1" size="1" desc="Read-write. Reset: 0. Physical register file parity error." />
      <field name="WDT" bit="0" size="1" desc="Read-write. Reset: 0. Watchdog Timeout error." />
    </register>

    <!-- 3.2.5.6 FP -->

    <!-- page 226 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2060 -->
    <register name="MCA_CTL_FP" type="msr" msr="0x00000418" desc="FP Machine Check Control. Read-write. Reset: 0000_0000_0000_0000h. 0=Disables error reporting for the corresponding error. 1=Enables error reporting via machine check exception for the corresponding error. The MCA::FP::MCA_CTL_FP register must be enabled by the corresponding enable bit in Core::X86::Msr::MCG_CTL. Does not affect error detection, correction, or logging.">
      <!-- Bits 63:7 reserved. -->
      <field name="HWA" bit="6" size="1" desc="Read-write. Reset: 0. Hardware assertion." />
      <field name="SRF" bit="5" size="1" desc="Read-write. Reset: 0. Status register file (SRF) parity error." />
      <field name="RQ" bit="4" size="1" desc="Read-write. Reset: 0. Retire queue (RQ) parity error." />
      <field name="NSQ" bit="3" size="1" desc="Read-write. Reset: 0. NSQ parity error." />
      <field name="SCH" bit="2" size="1" desc="Read-write. Reset: 0. Schedule queue parity error." />
      <field name="FL" bit="1" size="1" desc="Read-write. Reset: 0. Freelist (FL) parity error." />
      <field name="PRF" bit="0" size="1" desc="Read-write. Reset: 0. Physical register file (PRF) parity error." />
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC000_2061 -->
    <register name="MCA_STATUS_FP" type="msr" msr="0x00000419" desc="FP Machine Check Status Thread 0. Reset: Cold,0000_0000_0000_0000h. Logs information associated with errors.">
      <field name="Val" bit="63" size="1" desc="Reset: Cold,0. 1=A valid error has been detected. This bit should be cleared by software after the register has been read. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Overflow" bit="62" size="1" desc="Reset: Cold,0. 1=An error was detected while the valid bit (Val) was set; at least one error was not logged. Overflow is set independently of whether the existing error is overwritten. See 3.1.3 [Machine Check Errors]. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="UC" bit="61" size="1" desc="Reset: Cold,0. 1=The error was not corrected by hardware. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="En" bit="60" size="1" desc="Reset: Cold,0. 1=MCA error reporting is enabled for this error, as indicated by the corresponding bit in MCA::FP::MCA_CTL_FP. This bit is a copy of bit in MCA::FP::MCA_CTL_FP for this error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="MiscV" bit="59" size="1" desc="Reset: Cold,0. 1=Valid thresholding in MCA::FP::MCA_MISC0_FP. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="AddrV" bit="58" size="1" desc="Reset: Cold,0. 1=MCA::FP::MCA_ADDR_FP contains address information associated with the error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="PCC" bit="57" size="1" desc="Reset: Cold,0. 1=Hardware context held by the processor may have been corrupted. Continued operation of the system may have unpredictable results. The error is not recoverable or survivable, and the system should be reinitialized. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="ErrCoreIdVal" bit="56" size="1" desc="Reset: Cold,0. 1=The ErrCoreId field is valid. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="TCC" bit="55" size="1" desc="Reset: Cold,0. 0=The thread which consumed the error can be restarted reliably at the instruction pointer address pushed onto the exception handler stack if any uncorrected error has been corrected by software. 1=The thread which consumed the error is not restartable and must be terminated. Only meaningful when MCA::FP::MCA_STATUS_FP[PCC]=0. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bit 54 reserved. -->
      <field name="SyndV" bit="53" size="1" desc="Reset: Cold,0. 1=This error logged information in MCA::FP::MCA_SYND_FP. If MCA::FP::MCA_SYND_FP[ErrorPriority] is the same as the priority of the error in MCA::FP::MCA_STATUS_FP, then the information in MCA::FP::MCA_SYND_FP is associated with the error in MCA::FP::MCA_STATUS_FP. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 52:47 reserved. -->
      <field name="CECC" bit="46" size="1" desc="Reset: Cold,0. 1=The error was a correctable ECC error according to the restrictions of the ECC algorithm. UC indicates whether the error was actually corrected by the processor. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="UECC" bit="45" size="1" desc="Reset: Cold,0. 1=The error was an uncorrectable ECC error according to the restrictions of the ECC algorithm. UC indicates whether the error was actually corrected by the processor. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Deferred" bit="44" size="1" desc="Reset: Cold,0. 1=A deferred error was created. A deferred error is the result of an uncorrectable data error which did not immediately cause a processor exception; an exception is deferred until the erroneous data is consumed. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Poison" bit="43" size="1" desc="Reset: Cold,0. 1=The error was the result of attempting to consume poisoned data. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 42:38 reserved. -->
      <field name="ErrCoreId" bit="32" size="6" desc="Reset: Cold,00h. When ErrCoreIdVal=1 this field indicates which core within the processor is associated with the error; Otherwise this field is reserved. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 31:22 reserved. -->
      <field name="ErrorCodeExt" bit="16" size="6" desc="Reset: Cold,00h. Extended Error Code. This field is used to identify the error type for root cause analysis. This field indicates which bit position in MCA::FP::MCA_CTL_FP enables error reporting for the logged error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="ErrorCode" bit="0" size="16" desc="Reset: Cold,0000h. Error code for this error. See 3.1.3.3 [Error Codes] for details on decoding this field. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
    </register>

    <!-- page 228 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2062 -->
    <register name="MCA_ADDR_FP" type="msr" msr="0x0000041A" desc="FP Machine Check Address Thread 0. Read-only. Reset: Cold,0000_0000_0000_0000h. MCA::FP::MCA_ADDR_FP stores an address and other information associated with the error in MCA::FP::MCA_STATUS_FP. The register is only meaningful if MCA::FP::MCA_STATUS_FP[Val]=1 and MCA::FP::MCA_STATUS_FP[AddrV]=1.">
      <!-- Bits 63:62 reserved. -->
      <field name="LSB" bit="56" size="6" desc="Read-only. Reset: Cold,00h. Specifies the least significant valid bit of the address contained in MCA::FP::MCA_ADDR_FP[ErrorAddr]. A value of 0 indicates that MCA::FP::MCA_ADDR_FP[55:0] contains a valid byte address. A value of 6 indicates that MCA::FP::MCA_ADDR_FP[55:6] contains a valid cache line address and that MCA::FP::MCA_ADDR_FP[5:0] are not part of the address and should be ignored by error handling software. A value of 12 indicates that MCA::FP::MCA_ADDR_FP[55:12] contain a valid 4KB memory page and that MCA::FP::MCA_ADDR_FP[11:0] should be ignored by error handling software." />
      <field name="ErrorAddr" bit="0" size="56" desc="Read-only. Reset: Cold,00_0000_0000_0000h. Contains the address, if any, associated with the error logged in MCA::FP::MCA_STATUS_FP." />
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC000_2063 -->
    <register name="MCA_MISC0_FP" type="msr" msr="0x0000041B" desc="FP Machine Check Miscellaneous 0 Thread 0. Log miscellaneous information associated with errors.">
      <field name="Valid" bit="63" size="1" desc="Reset: 1. 1=A valid CntP field is present in this register. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="CntP" bit="62" size="1" desc="Reset: 1. 1=A valid threshold counter is present. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="Locked" bit="61" size="1" desc="Reset: 0. 1=Writes to this register are ignored. This bit is set by BIOS to indicate that this register is not available for OS use. BIOS should set this bit if ThresholdIntType is set to SMI. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="IntP" bit="60" size="1" desc="Reset: 1. 1=ThresholdIntType can be used to generate interrupts. 0=ThresholdIntType and interrupt generation are not supported. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::FP::MCA_MISC0_FP[Locked]) ? Read-write : Read-only." />
      <!-- Bits 59:56 reserved. -->
      <field name="LvtOffset" bit="52" size="4" desc="Reset: 0h. One per die. For error thresholding interrupts, specifies the address of the LVT entry in the APIC registers as follows: LVT address = (LvtOffset shifted left 4 bits) + 500h (see Core::X86::Apic::ExtendedInterruptLvtEntries). AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::FP::MCA_MISC0_FP[Locked]) ? Read-write : Read-only." />
      <field name="CntEn" bit="51" size="1" desc="Reset: 0. 1=Count thresholding errors.   AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::FP::MCA_MISC0_FP[Locked]) ? Read-write : Read-only." />
      <field name="ThresholdIntType" bit="49" size="2" desc="Reset: Cold,0h. Specifies the type of interrupt signaled when Ovrflw is set and IntP==1. 00b = No interrupt. 01b = APIC based interrupt (see Core::X86::Msr::McaIntrCfg[ThresholdLvtOffset]). 10b = SMI trigger event. 11b = Reserved. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::FP::MCA_MISC0_FP[Locked]) ? Read-write : Read-only." />
      <field name="Ovrflw" bit="48" size="1" desc="Reset: Cold,0. Set by hardware when ErrCnt transitions from FFEh to FFFh. When this field is set, ErrCnt no longer increments. When this bit is set, the interrupt selected by the ThresholdIntType field is generated. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::FP::MCA_MISC0_FP[Locked]) ? Read-write : Read-only." />
      <!-- Bits 47:44 reserved. -->
      <field name="ErrCnt" bit="32" size="12" desc="Reset: Cold,000h. This is written by software to set the starting value of the error counter. This is incremented by hardware when errors are logged. When this counter overflows, it stays at FFFh (no rollover). The threshold value, written by software, is (FFFh - the desired error count (the number of errors necessary in order for an interrupt to be taken)); the desired error count of 0 (a write value of FFFh) is not supported. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::FP::MCA_MISC0_FP[Locked]) ? Read-write : Read-only." />
      <field name="BlkPtr" bit="24" size="8" desc="Read-write. Reset: 01h. 00h=Extended MISC MSR block is not valid. 01h=Extended MSR block is valid." />
      <!-- Bits 23:0 reserved. -->
    </register>

    <!-- page 229 -->

    <register name="MCA_CONFIG_FP" type="msr" msr="0xC0002064" desc="FP Machine Check Configuration. Reset: 0000_0002_0000_0021h. Controls configuration of the associated machine check bank.">
      <!-- Bits 63:39 reserved. -->
      <field name="DeferredIntType" bit="37" size="2" desc="Read-write. Reset: 0h. Specifies the type of interrupt signaled when a deferred error is logged. 00b = No interrupt. 01b = APIC based interrupt (see Core::X86::Msr::McaIntrCfg[DeferredLvtOffset]). 10b = SMI trigger event. 11b = Reserved." />
      <!-- Bits 36:33 reserved. -->
      <field name="McaXEnable" bit="32" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. Check: 1. 1=Software has acknowledged support for the MCAX feature set. 0=Software has not acknowledged support for the MCAX feature set. All uncorrected and fatal errors will cause an ErrorEvent packet to be generated. Deferred error interrupts are configured via Core::X86::Msr::McaIntrCfg." />
      <!-- Bits 31:6 reserved. -->
      <field name="DeferredIntTypeSupported" bit="5" size="1" desc="Read-only. Reset: 1. 1=MCA::FP::MCA_CONFIG_FP[DeferredIntType] controls the type of interrupt generated on a deferred error. Deferred errors are supported in this bank only if MCA::FP::MCA_CONFIG_FP[DeferredErrorLoggingSupported]=1." />
      <!-- Bits 4:3 reserved. -->
      <field name="DeferredErrorLoggingSupported" bit="2" size="1" desc="Read-only. Reset: 0. 1=Deferred errors are supported in this MCA bank, and the LogDeferredInMcaStat field in this register controls the logging behavior of these errors. MCA_DESTAT and MCA_DEADDR are supported in this MCA bank. 0=Deferred errors are not supported in this bank." />
      <!-- Bit 1 reserved. -->
      <field name="McaX" bit="0" size="1" desc="Read-only. Reset: 1. 1=This bank provides Machine Check Architecture Extensions. Up to 4 additional MISC registers (MISC1-MISC4) are supported. MCA::FP::MCA_MISC0_FP[BlkPtr] indicates the presence of the additional MISC registers, but is not used to determine their MSR numbers. Deferred error interrupt type is specifiable by MCA bank. MCA::FP::MCA_STATUS_FP[TCC] is present." />
    </register>

    <!-- page 230 -->

    <register name="MCA_IPID_FP" type="msr" msr="0xC0002065" desc="FP IP Identification. Reset: 0006_00B0_0000_0000h. The MCA::FP::MCA_IPID_FP register is used by software to determine what IP type and revision is associated with the MCA bank.">
      <field name="McaType" bit="48" size="16" desc="Read-only. Reset: 0006h. The McaType of the MCA bank within this IP." />
      <!-- Bits 47:44 reserved. -->
      <field name="HardwareID" bit="32" size="12" desc="Read-only. Reset: 0B0h. The Hardware ID of the IP associated with this MCA bank." />
      <field name="InstanceId" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. The instance ID of this IP. This is initialized to a unique ID per instance of this register." />
    </register>
    <register name="MCA_SYND_FP" type="msr" msr="0xC0002066" desc="FP Machine Check Syndrome Thread 0. Read-write,Volatile. Reset: Cold,0000_0000_0000_0000h. Logs physical location information associated with error in MCA::FP::MCA_STATUS_FP Thread 0">
      <!-- Bits 63:33 reserved. -->
      <field name="Syndrome" bit="32" size="1" desc="Read-write,Volatile. Reset: Cold,0. Contains the syndrome, if any, associated with the error logged in MCA::FP::MCA_STATUS_FP. The low-order bit of the syndrome is stored in bit 0, and the syndrome has a length specified by MCA::FP::MCA_SYND_FP[Length]. The Syndrome field is only valid when MCA::FP::MCA_SYND_FP[Length] is not 0." />
      <!-- Bits 31:27 reserved. -->
      <field name="ErrorPriority" bit="24" size="3" desc="Read-write,Volatile. Reset: Cold,0h. Encodes the priority of the error logged in MCA::FP::MCA_SYND_FP. 3'b000 = No error; 3'b001 = Reserved; 3'b010 = Corrected Error; 3'b011 = Deferred Error; 3'b100 = Uncorrected Error; 3'b101 = Fatal Error; all others reserved." />
      <field name="Length" bit="18" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the length in bits of the syndrome contained in MCA::FP::MCA_SYND_FP[Syndrome]. A value of 0 indicates that there is no valid syndrome in MCA::FP::MCA_SYND_FP. For example, a syndrome length of 9 means that MCA::FP::MCA_SYND_FP[Syndrome] bits [8:0] contains a valid syndrome." />
      <field name="ErrorInformation" bit="0" size="18" desc="Read-write,Volatile. Reset: Cold,0_0000h. Contains error-specific information about the location of the error. Decoding is available in Table 50 [MCA_SYND_FP Register]." />
    </register>
    <register name="MCA_CTL_MASK_FP" type="msr" msr="0xC0010406" desc="FP Machine Check Control Mask. Read-write. Reset: 0000_0000_0000_0000h. Inhibit detection of an error source.">
      <!-- Bits 63:7 reserved. -->
      <field name="HWA" bit="6" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. Hardware assertion." />
      <field name="SRF" bit="5" size="1" desc="Read-write. Reset: 0. Status register file (SRF) parity error." />
      <field name="RQ" bit="4" size="1" desc="Read-write. Reset: 0. Retire queue (RQ) parity error." />
      <field name="NSQ" bit="3" size="1" desc="Read-write. Reset: 0. NSQ parity error." />
      <field name="SCH" bit="2" size="1" desc="Read-write. Reset: 0. Schedule queue parity error." />
      <field name="FL" bit="1" size="1" desc="Read-write. Reset: 0. Freelist (FL) parity error." />
      <field name="PRF" bit="0" size="1" desc="Read-write. Reset: 0. Physical register file (PRF) parity error." />
    </register>

    <!-- 3.2.5.7 L3 -->

    <!-- page 231 -->

    <!-- TODO Multiple MSR instances, skipping MSR0000_0420 -->
    <!-- TODO Multiple MSR instances, skipping MSR0000_0424 -->
    <!-- TODO Multiple MSR instances, skipping MSR0000_0428 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2070 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2080 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2090 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_20A0 -->
    <register name="MCA_CTL_L3" type="msr" msr="0x0000041C" desc="L3 Machine Check Control. Read-write. Reset: 0000_0000_0000_0000h. 0=Disables error reporting for the corresponding error. 1=Enables error reporting via machine check exception for the corresponding error. The MCA::L3::MCA_CTL_L3 register must be enabled by the corresponding enable bit in Core::X86::Msr::MCG_CTL. Does not affect error detection, correction, or logging.">
      <!-- Bits 63:8 reserved. -->
      <field name="Hwa" bit="7" size="1" desc="Read-write. Reset: 0. L3 Hardware Assertion." />
      <field name="XiVictimQueue" bit="6" size="1" desc="Read-write. Reset: 0. L3 Victim Queue Parity Error." />
      <field name="SdpParity" bit="5" size="1" desc="Read-write. Reset: 0. SDP Parity Error from XI." />
      <field name="DataArray" bit="4" size="1" desc="Read-write. Reset: 0. L3M Data ECC Error." />
      <field name="MultiHitTag" bit="3" size="1" desc="Read-write. Reset: 0. L3M Tag Multi-way-hit Error." />
      <field name="Tag" bit="2" size="1" desc="Read-write. Reset: 0. L3M Tag ECC Error." />
      <field name="MultiHitShadowTag" bit="1" size="1" desc="Read-write. Reset: 0. Shadow Tag Macro Multi-way-hit Error." />
      <field name="ShadowTag" bit="0" size="1" desc="Read-write. Reset: 0. Shadow Tag Macro ECC Error." />
    </register>

    <!-- TODO Multiple MSR instances, skipping MSR0000_0421 -->
    <!-- TODO Multiple MSR instances, skipping MSR0000_0425 -->
    <!-- TODO Multiple MSR instances, skipping MSR0000_0429 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2071 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2081 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2091 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_20A1 -->
    <register name="MCA_STATUS_L3" type="msr" msr="0x0000041D" desc="L3 Machine Check Status. Reset: Cold,0000_0000_0000_0000h. Logs information associated with errors.">
      <field name="Val" bit="63" size="1" desc="Reset: Cold,0. 1=A valid error has been detected. This bit should be cleared by software after the register has been read. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Overflow" bit="62" size="1" desc="Reset: Cold,0. 1=An error was detected while the valid bit (Val) was set; at least one error was not logged. Overflow is set independently of whether the existing error is overwritten. See 3.1.3 [Machine Check Errors]. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="UC" bit="61" size="1" desc="Reset: Cold,0. 1=The error was not corrected by hardware.   AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="En" bit="60" size="1" desc="Reset: Cold,0. 1=MCA error reporting is enabled for this error, as indicated by the corresponding bit in MCA::L3::MCA_CTL_L3. This bit is a copy of bit in MCA::L3::MCA_CTL_L3 for this error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="MiscV" bit="59" size="1" desc="Reset: Cold,0. 1=Valid thresholding in MCA::L3::MCA_MISC0_L3. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="AddrV" bit="58" size="1" desc="Reset: Cold,0. 1=MCA::L3::MCA_ADDR_L3 contains address information associated with the error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="PCC" bit="57" size="1" desc="Reset: Cold,0. 1=Hardware context held by the processor may have been corrupted. Continued operation of the system may have unpredictable results. The error is not recoverable or survivable, and the system should be reinitialized. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="ErrCoreIdVal" bit="56" size="1" desc="Reset: Cold,0. 1=The ErrCoreId field is valid. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="TCC" bit="55" size="1" desc="Reset: Cold,0. 0=The thread which consumed the error can be restarted reliably at the instruction pointer address pushed onto the exception handler stack if any uncorrected error has been corrected by software. 1=The thread which consumed the error is not restartable and must be terminated. Only meaningful when MCA::L3::MCA_STATUS_L3[PCC]=0. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bit 54 reserved. -->
      <field name="SyndV" bit="53" size="1" desc="Reset: Cold,0. 1=This error logged information in MCA::L3::MCA_SYND_L3. If MCA::L3::MCA_SYND_L3[ErrorPriority] is the same as the priority of the error in MCA::L3::MCA_STATUS_L3, then the information in MCA::L3::MCA_SYND_L3 is associated with the error in MCA::L3::MCA_STATUS_L3. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 52:47 reserved. -->
      <field name="CECC" bit="46" size="1" desc="Reset: Cold,0. 1=The error was a correctable ECC error according to the restrictions of the ECC algorithm. UC indicates whether the error was actually corrected by the processor. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="UECC" bit="45" size="1" desc="Reset: Cold,0. 1=The error was an uncorrectable ECC error according to the restrictions of the ECC algorithm. UC indicates whether the error was actually corrected by the processor. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Deferred" bit="44" size="1" desc="Reset: Cold,0. 1=A deferred error was created. A deferred error is the result of an uncorrectable data error which did not immediately cause a processor exception; an exception is deferred until the erroneous data is consumed. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Poison" bit="43" size="1" desc="Reset: Cold,0. 1=The error was the result of attempting to consume poisoned data. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 42:38 reserved. -->
      <field name="ErrCoreId" bit="32" size="6" desc="Reset: Cold,00h. When ErrCoreIdVal=1 this field indicates which core within the processor is associated with the error; Otherwise this field is reserved. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 31:22 reserved. -->
      <field name="ErrorCodeExt" bit="16" size="6" desc="Reset: Cold,00h. Extended Error Code. This field is used to identify the error type for root cause analysis. This field indicates which bit position in MCA::L3::MCA_CTL_L3 enables error reporting for the logged error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="ErrorCode" bit="0" size="16" desc="Reset: Cold,0000h. Error code for this error. See 3.1.3.3 [Error Codes] for details on decoding this field. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
    </register>

    <!-- page 233 -->

    <!-- TODO Multiple MSR instances, skipping MSR0000_0422 -->
    <!-- TODO Multiple MSR instances, skipping MSR0000_0426 -->
    <!-- TODO Multiple MSR instances, skipping MSR0000_042A -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2072 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2082 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2092 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_20A2 -->
    <register name="MCA_ADDR_L3" type="msr" msr="0x0000041E" desc="L3 Machine Check Address. Reset: Cold,0000_0000_0000_0000h. MCA::L3::MCA_ADDR_L3 stores an address and other information associated with the error in MCA::L3::MCA_STATUS_L3. The register is only meaningful if MCA::L3::MCA_STATUS_L3[Val]=1 and MCA::L3::MCA_STATUS_L3[AddrV]=1.">
      <!-- Bits 63:62 reserved. -->
      <field name="LSB" bit="56" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the least significant valid bit of the address contained in MCA::L3::MCA_ADDR_L3[ErrorAddr]. A value of 0 indicates that MCA::L3::MCA_ADDR_L3[55:0] contains a valid byte address. A value of 6 indicates that MCA::L3::MCA_ADDR_L3[55:6] contains a valid cache line address and that MCA::L3::MCA_ADDR_L3[5:0] are not part of the address and should be ignored by error handling software. A value of 12 indicates that MCA::L3::MCA_ADDR_L3[55:12] contain a valid 4KB memory page and that MCA::L3::MCA_ADDR_L3[11:0] should be ignored by error handling software." />
      <field name="ErrorAddr" bit="0" size="56" desc="Read-write,Volatile. Reset: Cold,00_0000_0000_0000h. Unless otherwise specified by an error, contains the address associated with the error logged in MCA::L3::MCA_STATUS_L3. For physical addresses, the most significant bit is given by Core::X86::Cpuid::LongModeInfo[PhysAddrSize]." />
    </register>

    <!-- page 234 -->

    <!-- TODO Multiple MSR instances, skipping MSR0000_0423 -->
    <!-- TODO Multiple MSR instances, skipping MSR0000_0427 -->
    <!-- TODO Multiple MSR instances, skipping MSR0000_042B -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2073 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2083 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2093 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_20A3 -->
    <register name="MCA_MISC0_L3" type="msr" msr="0x0000041F" desc="L3 Machine Check Miscellaneous 0. Log miscellaneous information associated with errors.">
      <field name="Valid" bit="63" size="1" desc="Reset: 1. 1=A valid CntP field is present in this register. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="CntP" bit="62" size="1" desc="Reset: 1. 1=A valid threshold counter is present. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="Locked" bit="61" size="1" desc="Reset: 0. 1=Writes to this register are ignored. This bit is set by BIOS to indicate that this register is not available for OS use. BIOS should set this bit if ThresholdIntType is set to SMI. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="IntP" bit="60" size="1" desc="Reset: 1. 1=ThresholdIntType can be used to generate interrupts. 0=ThresholdIntType and interrupt generation are not supported. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::L3::MCA_MISC0_L3[Locked]) ? Read-write : Read-only." />
      <!-- Bits 59:56 reserved. -->
      <field name="LvtOffset" bit="52" size="4" desc="Reset: 0h. One per die. For error thresholding interrupts, specifies the address of the LVT entry in the APIC registers as follows: LVT address = (LvtOffset shifted left 4 bits) + 500h (see Core::X86::Apic::ExtendedInterruptLvtEntries). AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::L3::MCA_MISC0_L3[Locked]) ? Read-write : Read-only." />
      <field name="CntEn" bit="51" size="1" desc="Reset: 0. 1=Count thresholding errors. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::L3::MCA_MISC0_L3[Locked]) ? Read-write : Read-only." />
      <field name="ThresholdIntType" bit="49" size="2" desc="Reset: Cold,0h. Specifies the type of interrupt signaled when Ovrflw is set and IntP==1. 00b = No interrupt. 01b = APIC based interrupt (see Core::X86::Msr::McaIntrCfg[ThresholdLvtOffset]). 10b = SMI trigger event. 11b = Reserved. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::L3::MCA_MISC0_L3[Locked]) ? Read-write : Read-only." />
      <field name="Ovrflw" bit="48" size="1" desc="Reset: Cold,0. Set by hardware when ErrCnt transitions from FFEh to FFFh. When this field is set, ErrCnt no longer increments. When this bit is set, the interrupt selected by the ThresholdIntType field is generated. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::L3::MCA_MISC0_L3[Locked]) ? Read-write : Read-only." />
      <!-- Bits 47:44 reserved. -->
      <field name="ErrCnt" bit="32" size="12" desc="Reset: Cold,000h. This is written by software to set the starting value of the error counter. This is incremented by hardware when errors are logged. When this counter overflows, it stays at FFFh (no rollover). The threshold value, written by software, is (FFFh - the desired error count (the number of errors necessary in order for an interrupt to be taken)); the desired error count of 0 (a write value of FFFh) is not supported.   AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::L3::MCA_MISC0_L3[Locked]) ? Read-write : Read-only." />
      <field name="BlkPtr" bit="24" size="8" desc="Read-write. Reset: 01h. 00h=Extended MISC MSR block is not valid. 01h=Extended MSR block is valid." />
      <!-- Bits 23:0 reserved. -->
    </register>

    <!-- page 235 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2084 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2094 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_20A4 -->
    <register name="MCA_CONFIG_L3" type="msr" msr="0xC0002074" desc="L3 Machine Check Configuration. Reset: 0000_0000_0000_0025h. Controls configuration of the associated machine check bank.">
      <!-- Bits 63:39 reserved. -->
      <field name="DeferredIntType" bit="37" size="2" desc="Read-write. Reset: 0h. Specifies the type of interrupt signaled when a deferred error is logged. 00b = No interrupt. 01b = APIC based interrupt (see Core::X86::Msr::McaIntrCfg[DeferredLvtOffset]). 10b = SMI trigger event. 11b = Reserved." />
      <!-- Bits 36:35 reserved. -->
      <field name="LogDeferredInMcaStat" bit="34" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. 1=Log deferred errors in MCA::L3::MCA_STATUS_L3 and MCA::L3::MCA_ADDR_L3 in addition to MCA::L3::MCA_DESTAT_L3 and MCA::L3::MCA_DEADDR_L3. 0=Only log deferred errors in MCA::L3::MCA_DESTAT_L3 and MCA::L3::MCA_DEADDR_L3. This bit does not affect logging of deferred errors in MCA::L3::MCA_SYND_L3, MCA::L3::MCA_MISC0_L3." />
      <!-- Bit 33 reserved. -->
      <field name="McaXEnable" bit="32" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. Check: 1. 1=Software has acknowledged support for the MCAX feature set. 0=Software has not acknowledged support for the MCAX feature set. All uncorrected and fatal errors will cause an ErrorEvent packet to be generated. Deferred error interrupts are configured via Core::X86::Msr::McaIntrCfg." />
      <!-- Bits 31:6 reserved. -->
      <field name="DeferredIntTypeSupported" bit="5" size="1" desc="Read-only. Reset: 1. 1=MCA::L3::MCA_CONFIG_L3[DeferredIntType] controls the type of interrupt generated on a deferred error. Deferred errors are supported in this bank only if MCA::L3::MCA_CONFIG_L3[DeferredErrorLoggingSupported]=1." />
      <!-- Bits 4:3 reserved. -->
      <field name="DeferredErrorLoggingSupported" bit="2" size="1" desc="Read-only. Reset: 1. 1=Deferred errors are supported in this MCA bank, and MCA::L3::MCA_CONFIG_L3[LogDeferredInMcaStat] controls the logging behavior of these errors. MCA::L3::MCA_DESTAT_L3 and MCA::L3::MCA_DEADDR_L3 are supported in this MCA bank. 0=Deferred errors are not supported in this bank." />
      <!-- Bit 1 reserved. -->
      <field name="McaX" bit="0" size="1" desc="Read-only. Reset: 1. 1=This bank provides Machine Check Architecture Extensions. Up to 4 additional MISC registers (MISC1-MISC4) are supported. MCA::L3::MCA_MISC0_L3[BlkPtr] indicates the presence of the additional MISC registers, but is not used to determine their MSR numbers. Deferred error interrupt type is specifiable by MCA bank. MCA::L3::MCA_STATUS_L3[TCC] is present." />
    </register>

    <!-- page 236 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2085 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2095 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_20A5 -->
    <register name="MCA_IPID_L3" type="msr" msr="0xC0002075" desc="L3 IP Identification. Reset: 0007_00B0_0000_0000h. The MCA::L3::MCA_IPID_L3 register is used by software to determine what IP type and revision is associated with the MCA bank.">
      <field name="McaType" bit="48" size="16" desc="Read-only. Reset: 0007h. The McaType of the MCA bank within this IP." />
      <!-- Bits 47:44 reserved. -->
      <field name="HardwareID" bit="32" size="12" desc="Read-only. Reset: 0B0h. The Hardware ID of the IP associated with this MCA bank." />
      <field name="InstanceId" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. The instance ID of this IP. This is initialized to a unique ID per instance of this register." />
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC000_2086 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2096 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_20A6 -->
    <register name="MCA_SYND_L3" type="msr" msr="0xC0002076" desc="L3 Machine Check Syndrome. Read-write,Volatile. Reset: Cold,0000_0000_0000_0000h. Logs physical location information associated with error in MCA::L3::MCA_STATUS_L3 Thread 0">
      <!-- Bits 63:49 reserved. -->
      <field name="Syndrome" bit="32" size="17" desc="Read-write,Volatile. Reset: Cold,0_0000h. Contains the syndrome, if any, associated with the error logged in MCA::L3::MCA_STATUS_L3. The low-order bit of the syndrome is stored in bit 0, and the syndrome has a length specified by MCA::L3::MCA_SYND_L3[Length]. The Syndrome field is only valid when MCA::L3::MCA_SYND_L3[Length] is not 0." />
      <!-- Bits 31:27 reserved. -->
      <field name="ErrorPriority" bit="24" size="3" desc="Read-write,Volatile. Reset: Cold,0h. Encodes the priority of the error logged in MCA::L3::MCA_SYND_L3. 3'b000 = No error; 3'b001 = Reserved; 3'b010 = Corrected Error; 3'b011 = Deferred Error; 3'b100 = Uncorrected Error; 3'b101 = Fatal Error; all others reserved." />
      <field name="Length" bit="18" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the length in bits of the syndrome contained in MCA::L3::MCA_SYND_L3[Syndrome]. A value of 0 indicates that there is no valid syndrome in MCA::L3::MCA_SYND_L3. For example, a syndrome length of 9 means that MCA::L3::MCA_SYND_L3[Syndrome] bits [8:0] contains a valid syndrome." />
      <field name="ErrorInformation" bit="0" size="18" desc="Read-write,Volatile. Reset: Cold,0_0000h. Contains error-specific information about the location of the error. Decoding is available in Table 53 [MCA_SYND_L3 Register]." />
    </register>

    <!-- page 237 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2088 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2098 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_20A8 -->
    <register name="MCA_DESTAT_L3" type="msr" msr="0xC0002078" desc="L3 Machine Check Deferred Error Status. Read-write,Volatile. Reset: Cold,0000_0000_0000_0000h. Holds status information for the first deferred error seen in this bank.">
      <field name="Val" bit="63" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=A valid error has been detected (whether it is enabled or not)." />
      <field name="Overflow" bit="62" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=An error was detected while the valid bit (Val) was set; at least one error was not logged. Overflow is set independently of whether the existing error is overwritten. (See the section on overwrite priorities.)" />
      <!-- Bits 61:59 reserved. -->
      <field name="AddrV" bit="58" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=MCA::L3::MCA_DEADDR_L3 contains address information associated with the error." />
      <!-- Bits 57:54 reserved. -->
      <field name="SyndV" bit="53" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=This error logged information in MCA::L3::MCA_SYND_L3. If MCA::L3::MCA_SYND_L3[ErrorPriority] is the same as the priority of the error in MCA::L3::MCA_STATUS_L3, then the information in MCA::L3::MCA_SYND_L3 is associated with the error in MCA::L3::MCA_DESTAT_L3." />
      <!-- Bits 52:45 reserved. -->
      <field name="Deferred" bit="44" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=A deferred error was created. A deferred error is the result of an uncorrectable data error which did not immediately cause a processor exception; poison is created and an exception is deferred until the poison data is consumed." />
      <!-- Bits 43:0 reserved. -->
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC000_2089 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2099 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_20A9 -->
    <register name="MCA_DEADDR_L3" type="msr" msr="0xC0002079" desc="L3 Deferred Error Address. Reset: Cold,0000_0000_0000_0000h. The MCA::L3::MCA_DEADDR_L3 register stores the address associated with the error in MCA::L3::MCA_DESTAT_L3. The register is only meaningful if MCA::L3::MCA_DESTAT_L3[Val]=1 and MCA::L3::MCA_DESTAT_L3[AddrV]=1. The lowest valid bit of the address is defined by MCA::L3::MCA_DEADDR_L3[LSB].">
      <!-- Bits 63:62 reserved. -->
      <field name="LSB" bit="56" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the least significant valid bit of the address contained in MCA::L3::MCA_DEADDR_L3[ErrorAddr]. A value of 0 indicates that MCA::L3::MCA_DEADDR_L3[55:0] contains a valid byte address. A value of 6 indicates that MCA::L3::MCA_DEADDR_L3[55:6] contains a valid cache line address and that MCA::L3::MCA_DEADDR_L3[5:0] are not part of the address and should be ignored by error handling software. A value of 12 indicates that MCA::L3::MCA_DEADDR_L3[55:12] contain a valid 4KB memory page and that MCA::L3::MCA_DEADDR_L3[11:0] should be ignored by error handling software." />
      <field name="ErrorAddr" bit="0" size="56" desc="Read-write,Volatile. Reset: Cold,00_0000_0000_0000h. Contains the address, if any, associated with the error logged in MCA::L3::MCA_DESTAT_L3. The lowest-order valid bit of the address is specified in MCA::L3::MCA_DEADDR_L3[LSB]." />
    </register>

    <!-- page 238 -->

    <!-- TODO Multiple MSR instances, skipping MSRC001_0408 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_0409 -->
    <!-- TODO Multiple MSR instances, skipping MSRC001_040A -->
    <register name="MCA_CTL_MASK_L3" type="msr" msr="0xC0010407" desc="L3 Machine Check Control Mask. Read-write. Reset: 0000_0000_0000_0000h. Inhibit detection of an error source.">
      <!-- Bits 63:8 reserved. -->
      <field name="Hwa" bit="7" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. L3 Hardware Assertion." />
      <field name="XiVictimQueue" bit="6" size="1" desc="Read-write. Reset: 0. L3 Victim Queue Parity Error." />
      <field name="SdpParity" bit="5" size="1" desc="Read-write. Reset: 0. SDP Parity Error from XI." />
      <field name="DataArray" bit="4" size="1" desc="Read-write. Reset: 0. L3M Data ECC Error." />
      <field name="MultiHitTag" bit="3" size="1" desc="Read-write. Reset: 0. L3M Tag Multi-way-hit Error." />
      <field name="Tag" bit="2" size="1" desc="Read-write. Reset: 0. L3M Tag ECC Error." />
      <field name="MultiHitShadowTag" bit="1" size="1" desc="Read-write. Reset: 0. Shadow Tag Macro Multi-way-hit Error." />
      <field name="ShadowTag" bit="0" size="1" desc="Read-write. Reset: 0. Shadow Tag Macro ECC Error." />
    </register>

    <!-- 3.2.5.8 CS -->

    <!-- TODO Multiple MSR instances, skipping MSR0000_0454 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2140 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2150 -->
    <register name="MCA_CTL_CS" type="msr" msr="0x00000450" desc="CS Machine Check Control. Read-write. Reset: 0000_0000_0000_0000h. 0=Disables error reporting for the corresponding error. 1=Enables error reporting via machine check exception for the corresponding error. The MCA::CS::MCA_CTL_CS register must be enabled by the corresponding enable bit in Core::X86::Msr::MCG_CTL. Does not affect error detection, correction, or logging.">
      <!-- Bits 63:9 reserved. -->
      <field name="SPF_ECC_ERR" bit="8" size="1" desc="Read-write. Reset: 0. Probe Filter ECC Error: An ECC error occurred on a probe filter access." />
      <field name="ATM_PAR_ERR" bit="7" size="1" desc="Read-write. Reset: 0. Atomic Request Parity Error: Parity error on read of an atomic transaction." />
      <field name="SDP_PAR_ERR" bit="6" size="1" desc="Read-write. Reset: 0. Read Response Parity Error: Parity error on incoming read response data." />
      <field name="FTI_PAR_ERR" bit="5" size="1" desc="Read-write. Reset: 0. Request or Probe Parity Error: Parity error on incoming request or probe response data." />
      <field name="FTI_RSP_NO_MTCH" bit="4" size="1" desc="Read-write. Reset: 0. Unexpected Response: A response was received from the transport layer which does not match any request." />
      <field name="FTI_ILL_RSP" bit="3" size="1" desc="Read-write. Reset: 0. Illegal Response: An illegal response was received from the transport layer." />
      <field name="FTI_SEC_VIOL" bit="2" size="1" desc="Read-write. Reset: 0. Security Violation: A security violation was received from the transport layer." />
      <field name="FTI_ADDR_VIOL" bit="1" size="1" desc="Read-write. Reset: 0. Address Violation: An address violation was received from the transport layer." />
      <field name="FTI_ILL_REQ" bit="0" size="1" desc="Read-write. Reset: 0. Illegal Request: An illegal request was received from the transport layer." />
    </register>

    <!-- page 239 -->

    <!-- TODO Multiple MSR instances, skipping MSR0000_0455 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2141 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2151 -->
    <register name="MCA_STATUS_CS" type="msr" msr="0x00000451" desc="CS Machine Check Status. Reset: Cold,0000_0000_0000_0000h. Logs information associated with errors.">
      <field name="Val" bit="63" size="1" desc="Reset: Cold,0. 1=A valid error has been detected. This bit should be cleared by software after the register has been read.   AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Overflow" bit="62" size="1" desc="Reset: Cold,0. 1=An error was detected while the valid bit (Val) was set; at least one error was not logged. Overflow is set independently of whether the existing error is overwritten. See 3.1.3 [Machine Check Errors]. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="UC" bit="61" size="1" desc="Reset: Cold,0. 1=The error was not corrected by hardware. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="En" bit="60" size="1" desc="Reset: Cold,0. 1=MCA error reporting is enabled for this error, as indicated by the corresponding bit in MCA::CS::MCA_CTL_CS. This bit is a copy of bit in MCA::CS::MCA_CTL_CS for this error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="MiscV" bit="59" size="1" desc="Reset: Cold,0. 1=Valid thresholding in MCA::CS::MCA_MISC0_CS. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="AddrV" bit="58" size="1" desc="Reset: Cold,0. 1=MCA::CS::MCA_ADDR_CS contains address information associated with the error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="PCC" bit="57" size="1" desc="Reset: Cold,0. 1=Hardware context held by the processor may have been corrupted. Continued operation of the system may have unpredictable results. The error is not recoverable or survivable, and the system should be reinitialized. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="ErrCoreIdVal" bit="56" size="1" desc="Reset: Cold,0. 1=The ErrCoreId field is valid. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="TCC" bit="55" size="1" desc="Reset: Cold,0. 0=The thread which consumed the error can be restarted reliably at the instruction pointer address pushed onto the exception handler stack if any uncorrected error has been corrected by software. 1=The thread which consumed the error is not restartable and must be terminated. Only meaningful when MCA::CS::MCA_STATUS_CS[PCC]=0. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bit 54 reserved. -->
      <field name="SyndV" bit="53" size="1" desc="Reset: Cold,0. 1=This error logged information in MCA::CS::MCA_SYND_CS. If MCA::CS::MCA_SYND_CS[ErrorPriority] is the same as the priority of the error in MCA::CS::MCA_STATUS_CS, then the information in MCA::CS::MCA_SYND_CS is associated with the error in MCA::CS::MCA_STATUS_CS. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 52:47 reserved. -->
      <field name="CECC" bit="46" size="1" desc="Reset: Cold,0. 1=The error was a correctable ECC error according to the restrictions of the ECC algorithm. UC indicates whether the error was actually corrected by the processor. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="UECC" bit="45" size="1" desc="Reset: Cold,0. 1=The error was an uncorrectable ECC error according to the restrictions of the ECC algorithm. UC indicates whether the error was actually corrected by the processor. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Deferred" bit="44" size="1" desc="Reset: Cold,0. 1=A deferred error was created. A deferred error is the result of an uncorrectable data error which did not immediately cause a processor exception; an exception is deferred until the erroneous data is consumed. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Poison" bit="43" size="1" desc="Reset: Cold,0. 1=The error was the result of attempting to consume poisoned data. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 42:38 reserved. -->
      <field name="ErrCoreId" bit="32" size="6" desc="Reset: Cold,00h. When ErrCoreIdVal=1 this field indicates which core within the processor is associated with the error; Otherwise this field is reserved. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 31:22 reserved. -->
      <field name="ErrorCodeExt" bit="16" size="6" desc="Reset: Cold,00h. Extended Error Code. This field is used to identify the error type for root cause   analysis. This field indicates which bit position in MCA::CS::MCA_CTL_CS enables error reporting for the logged error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="ErrorCode" bit="0" size="16" desc="Reset: Cold,0000h. Error code for this error. See 3.1.3.3 [Error Codes] for details on decoding this field. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
    </register>

    <!-- page 240 -->

    <!-- TODO Multiple MSR instances, skipping MSR0000_0456 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2142 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2152 -->
    <register name="MCA_ADDR_CS" type="msr" msr="0x00000452" desc="CS Machine Check Address. Reset: Cold,0000_0000_0000_0000h. MCA::CS::MCA_ADDR_CS stores an address and other information associated with the error in MCA::CS::MCA_STATUS_CS. The register is only meaningful if MCA::CS::MCA_STATUS_CS[Val]=1 and MCA::CS::MCA_STATUS_CS[AddrV]=1.">
      <!-- Bits 63:62 reserved. -->
      <field name="LSB" bit="56" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the least significant valid bit of the address contained in MCA::CS::MCA_ADDR_CS[ErrorAddr]. A value of 0 indicates that MCA::CS::MCA_ADDR_CS[55:0] contains a valid byte address. A value of 6 indicates that MCA::CS::MCA_ADDR_CS[55:6] contains a valid cache line address and that MCA::CS::MCA_ADDR_CS[5:0] are not part of the address and should be ignored by error handling software. A value of 12 indicates that MCA::CS::MCA_ADDR_CS[55:12] contain a valid 4KB memory page and that MCA::CS::MCA_ADDR_CS[11:0] should be ignored by error handling software." />
      <field name="ErrorAddr" bit="0" size="56" desc="Read-write,Volatile. Reset: Cold,00_0000_0000_0000h. Unless otherwise specified by an error, contains the address associated with the error logged in MCA::CS::MCA_STATUS_CS. For physical addresses, the most significant bit is given by Core::X86::Cpuid::LongModeInfo[PhysAddrSize]." />
    </register>

    <!-- page 241 -->

    <!-- TODO Multiple MSR instances, skipping MSR0000_0457 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2143 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2153 -->
    <register name="MCA_MISC0_CS" type="msr" msr="0x00000453" desc="CS Machine Check Miscellaneous 0. Log miscellaneous information associated with errors.">
      <field name="Valid" bit="63" size="1" desc="Reset: 1. 1=A valid CntP field is present in this register. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="CntP" bit="62" size="1" desc="Reset: 1. 1=A valid threshold counter is present. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="Locked" bit="61" size="1" desc="Reset: 0. 1=Writes to this register are ignored. This bit is set by BIOS to indicate that this register is not available for OS use. BIOS should set this bit if ThresholdIntType is set to SMI. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="IntP" bit="60" size="1" desc="Reset: 1. 1=ThresholdIntType can be used to generate interrupts. 0=ThresholdIntType and interrupt generation are not supported. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::CS::MCA_MISC0_CS[Locked]) ? Read-write : Read-only." />
      <!-- Bits 59:56 reserved. -->
      <field name="LvtOffset" bit="52" size="4" desc="Reset: 0h. One per die. For error thresholding interrupts, specifies the address of the LVT entry in the APIC registers as follows: LVT address = (LvtOffset shifted left 4 bits) + 500h (see Core::X86::Apic::ExtendedInterruptLvtEntries). AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::CS::MCA_MISC0_CS[Locked]) ? Read-write : Read-only." />
      <field name="CntEn" bit="51" size="1" desc="Reset: 0. 1=Count thresholding errors. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::CS::MCA_MISC0_CS[Locked]) ? Read-write : Read-only." />
      <field name="ThresholdIntType" bit="49" size="2" desc="Reset: Cold,0h. Specifies the type of interrupt signaled when Ovrflw is set and IntP==1. 00b = No interrupt. 01b = APIC based interrupt (see Core::X86::Msr::McaIntrCfg[ThresholdLvtOffset]). 10b = SMI trigger event. 11b = Reserved. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::CS::MCA_MISC0_CS[Locked]) ? Read-write : Read-only." />
      <field name="Ovrflw" bit="48" size="1" desc="Reset: Cold,0. Set by hardware when ErrCnt transitions from FFEh to FFFh. When this field is set, ErrCnt no longer increments. When this bit is set, the interrupt selected by the ThresholdIntType field is generated. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::CS::MCA_MISC0_CS[Locked]) ? Read-write : Read-only." />
      <!-- Bits 47:44 reserved. -->
      <field name="ErrCnt" bit="32" size="12" desc="Reset: Cold,000h. This is written by software to set the starting value of the error counter. This is incremented by hardware when errors are logged. When this counter overflows, it stays at FFFh (no rollover). The threshold value, written by software, is (FFFh - the desired error count (the number of errors necessary in order for an interrupt to be taken)); the desired error count of 0 (a write value of FFFh) is not supported. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::CS::MCA_MISC0_CS[Locked]) ? Read-write : Read-only." />
      <field name="BlkPtr" bit="24" size="8" desc="Read-write. Reset: 01h. 00h=Extended MISC MSR block is not valid. 01h=Extended MSR block is valid." />
      <!-- Bits 23:0 reserved. -->
    </register>

    <!-- page 242 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2154 -->
    <register name="MCA_CONFIG_CS" type="msr" msr="0xC0002144" desc="CS Machine Check Configuration. Reset: 0000_0000_0000_0025h. Controls configuration of the associated machine check bank.">
      <!-- Bits 63:39 reserved. -->
      <field name="DeferredIntType" bit="37" size="2" desc="Read-write. Reset: 0h. Specifies the type of interrupt signaled when a deferred error is logged. 00b = No interrupt. 01b = APIC based interrupt (see Core::X86::Msr::McaIntrCfg[DeferredLvtOffset]). 10b = SMI trigger event. 11b = Reserved." />
      <!-- Bits 36:35 reserved. -->
      <field name="LogDeferredInMcaStat" bit="34" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. 1=Log deferred errors in MCA::CS::MCA_STATUS_CS and MCA::CS::MCA_ADDR_CS in addition to MCA::CS::MCA_DESTAT_CS and MCA::CS::MCA_DEADDR_CS. 0=Only log deferred errors in MCA::CS::MCA_DESTAT_CS and MCA::CS::MCA_DEADDR_CS. This bit does not affect logging of deferred errors in MCA::CS::MCA_SYND_CS, MCA::CS::MCA_MISC0_CS." />
      <!-- Bit 33 reserved. -->
      <field name="McaXEnable" bit="32" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. Check: 1. 1=Software has acknowledged support for the MCAX feature set. 0=Software has not acknowledged support for the MCAX feature set. All uncorrected and fatal errors will cause an ErrorEvent packet to be generated. Deferred error interrupts are configured via Core::X86::Msr::McaIntrCfg." />
      <!-- Bits 31:6 reserved. -->
      <field name="DeferredIntTypeSupported" bit="5" size="1" desc="Read-only. Reset: 1. 1=MCA::CS::MCA_CONFIG_CS[DeferredIntType] controls the type of interrupt generated on a deferred error. Deferred errors are supported in this bank only if MCA::CS::MCA_CONFIG_CS[DeferredErrorLoggingSupported]=1." />
      <!-- Bits 4:3 reserved. -->
      <field name="DeferredErrorLoggingSupported" bit="2" size="1" desc="Read-only. Reset: 1. 1=Deferred errors are supported in this MCA bank, and MCA::CS::MCA_CONFIG_CS[LogDeferredInMcaStat] controls the logging behavior of these errors. MCA::CS::MCA_DESTAT_CS and MCA::CS::MCA_DEADDR_CS are supported in this MCA bank. 0=Deferred errors are not supported in this bank." />
      <!-- Bit 1 reserved. -->
      <field name="McaX" bit="0" size="1" desc="Read-only. Reset: 1. 1=This bank provides Machine Check Architecture Extensions. Up to 4 additional MISC registers (MISC1-MISC4) are supported. MCA::CS::MCA_MISC0_CS[BlkPtr] indicates the presence of the additional MISC registers, but is not used to determine their MSR numbers. Deferred error interrupt type is specifiable by MCA bank. MCA::CS::MCA_STATUS_CS[TCC] is present." />
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC000_2155 -->
    <register name="MCA_IPID_CS" type="msr" msr="0xC0002145" desc="CS IP Identification. Reset: 0000_002E_0000_0000h. The MCA::CS::MCA_IPID_CS register is used by software to determine what IP type and revision is associated with the MCA bank.">
      <field name="McaType" bit="48" size="16" desc="Read-only. Reset: 0000h. The McaType of the MCA bank within this IP." />
      <!-- Bits 47:44 reserved. -->
      <field name="HardwareID" bit="32" size="12" desc="Read-only. Reset: 02Eh. The Hardware ID of the IP associated with this MCA bank." />
      <field name="InstanceId" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. The instance ID of this IP. This is initialized to a unique ID per instance of this register." />
    </register>

    <!-- page 243 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2156 -->
    <register name="MCA_SYND_CS" type="msr" msr="0xC0002146" desc="CS Machine Check Syndrome. Read-write,Volatile. Reset: Cold,0000_0000_0000_0000h. Logs physical location information associated with error in MCA::CS::MCA_STATUS_CS Thread 0">
      <!-- Bits 63:48 reserved. -->
      <field name="Syndrome" bit="32" size="16" desc="Read-write,Volatile. Reset: Cold,0000h. Contains the syndrome, if any, associated with the error logged in MCA::CS::MCA_STATUS_CS. The low-order bit of the syndrome is stored in bit 0, and the syndrome has a length specified by MCA::CS::MCA_SYND_CS[Length]. The Syndrome field is only valid when MCA::CS::MCA_SYND_CS[Length] is not 0." />
      <!-- Bits 31:27 reserved. -->
      <field name="ErrorPriority" bit="24" size="3" desc="Read-write,Volatile. Reset: Cold,0h. Encodes the priority of the error logged in MCA::CS::MCA_SYND_CS. 3'b000 = No error; 3'b001 = Reserved; 3'b010 = Corrected Error; 3'b011 = Deferred Error; 3'b100 = Uncorrected Error; 3'b101 = Fatal Error; all others reserved." />
      <field name="Length" bit="18" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the length in bits of the syndrome contained in MCA::CS::MCA_SYND_CS[Syndrome]. A value of 0 indicates that there is no valid syndrome in MCA::CS::MCA_SYND_CS. For example, a syndrome length of 9 means that MCA::CS::MCA_SYND_CS[Syndrome] bits [8:0] contains a valid syndrome." />
      <field name="ErrorInformation" bit="0" size="18" desc="Read-write,Volatile. Reset: Cold,0_0000h. Contains error-specific information about the location of the error. Decoding is available in Table 56 [MCA_SYND_CS Register]." />
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC000_2158 -->
    <register name="MCA_DESTAT_CS" type="msr" msr="0xC0002148" desc="CS Machine Check Deferred Error Status. Read-write,Volatile. Reset: Cold,0000_0000_0000_0000h. Holds status information for the first deferred error seen in this bank.">
      <field name="Val" bit="63" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=A valid error has been detected (whether it is enabled or not)." />
      <field name="Overflow" bit="62" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=An error was detected while the valid bit (Val) was set; at least one error was not logged. Overflow is set independently of whether the existing error is overwritten. (See the section on overwrite priorities.)" />
      <!-- Bits 61:59 reserved. -->
      <field name="AddrV" bit="58" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=MCA::CS::MCA_DEADDR_CS contains address information associated with the error." />
      <!-- Bits 57:54 reserved. -->
      <field name="SyndV" bit="53" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=This error logged information in MCA::CS::MCA_SYND_CS. If MCA::CS::MCA_SYND_CS[ErrorPriority] is the same as the priority of the error in MCA::CS::MCA_STATUS_CS, then the information in MCA::CS::MCA_SYND_CS is associated with the error in MCA::CS::MCA_DESTAT_CS." />
      <!-- Bits 52:45 reserved. -->
      <field name="Deferred" bit="44" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=A deferred error was created. A deferred error is the result of an uncorrectable data error which did not immediately cause a processor exception; poison is created and an exception is deferred until the poison data is consumed." />
      <!-- Bits 43:0 reserved. -->
    </register>

    <!-- page 244 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2159 -->
    <register name="MCA_DEADDR_CS" type="msr" msr="0xC0002149" desc="CS Deferred Error Address. Reset: Cold,0000_0000_0000_0000h. The MCA::CS::MCA_DEADDR_CS register stores the address associated with the error in MCA::CS::MCA_DESTAT_CS. The register is only meaningful if MCA::CS::MCA_DESTAT_CS[Val]=1 and MCA::CS::MCA_DESTAT_CS[AddrV]=1. The lowest valid bit of the address is defined by MCA::CS::MCA_DEADDR_CS[LSB].">
      <!-- Bits 63:62 reserved. -->
      <field name="LSB" bit="56" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the least significant valid bit of the address contained in MCA::CS::MCA_DEADDR_CS[ErrorAddr]. A value of 0 indicates that MCA::CS::MCA_DEADDR_CS[55:0] contains a valid byte address. A value of 6 indicates that MCA::CS::MCA_DEADDR_CS[55:6] contains a valid cache line address and that MCA::CS::MCA_DEADDR_CS[5:0] are not part of the address and should be ignored by error handling software. A value of 12 indicates that MCA::CS::MCA_DEADDR_CS[55:12] contain a valid 4KB memory page and that MCA::CS::MCA_DEADDR_CS[11:0] should be ignored by error handling software." />
      <field name="ErrorAddr" bit="0" size="56" desc="Read-write,Volatile. Reset: Cold,00_0000_0000_0000h. Contains the address, if any, associated with the error logged in MCA::CS::MCA_DESTAT_CS. The lowest-order valid bit of the address is specified in MCA::CS::MCA_DEADDR_CS[LSB]." />
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC001_0415 -->
    <register name="MCA_CTL_MASK_CS" type="msr" msr="0xC0010414" desc="CS Machine Check Control Mask. Read-write. Reset: 0000_0000_0000_0000h. Inhibit detection of an error source.">
      <!-- Bits 63:9 reserved. -->
      <field name="SPF_ECC_ERR" bit="8" size="1" desc="Read-write. Reset: 0. Probe Filter ECC Error: An ECC error occurred on a probe filter access." />
      <field name="ATM_PAR_ERR" bit="7" size="1" desc="Read-write. Reset: 0. Atomic Request Parity Error: Parity error on read of an atomic transaction." />
      <field name="SDP_PAR_ERR" bit="6" size="1" desc="Read-write. Reset: 0. Read Response Parity Error: Parity error on incoming read response data." />
      <field name="FTI_PAR_ERR" bit="5" size="1" desc="Read-write. Reset: 0. Request or Probe Parity Error: Parity error on incoming request or probe response data." />
      <field name="FTI_RSP_NO_MTCH" bit="4" size="1" desc="Read-write. Reset: 0. Unexpected Response: A response was received from the transport layer which does not match any request." />
      <field name="FTI_ILL_RSP" bit="3" size="1" desc="Read-write. Reset: 0. Illegal Response: An illegal response was received from the transport layer." />
      <field name="FTI_SEC_VIOL" bit="2" size="1" desc="Read-write. Reset: 0. Security Violation: A security violation was received from the transport layer." />
      <field name="FTI_ADDR_VIOL" bit="1" size="1" desc="Read-write. Reset: 0. Address Violation: An address violation was received from the transport layer." />
      <field name="FTI_ILL_REQ" bit="0" size="1" desc="Read-write. Reset: 0. Illegal Request: An illegal request was received from the transport layer." />
    </register>

    <!-- 3.2.5.9 PIE -->

    <!-- page 245 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2160 -->
    <register name="MCA_CTL_PIE" type="msr" msr="0x00000458" desc="PIE Machine Check Control. Read-write. Reset: 0000_0000_0000_0000h. 0=Disables error reporting for the corresponding error. 1=Enables error reporting via machine check exception for the corresponding error. The MCA::PIE::MCA_CTL_PIE register must be enabled by the corresponding enable bit in Core::X86::Msr::MCG_CTL. Does not affect error detection, correction, or logging.">
      <!-- Bits 63:4 reserved. -->
      <field name="FTI_DAT_STAT" bit="3" size="1" desc="Read-write. Reset: 0. Poison data consumption: Poison data was written to an internal PIE register." />
      <field name="GMI" bit="2" size="1" desc="Read-write. Reset: 0. Link Error: An error occurred on a GMI or xGMI link." />
      <field name="CSW" bit="1" size="1" desc="Read-write. Reset: 0. Register security violation: A security violation was detected on an access to an internal PIE register." />
      <field name="HW_ASSERT" bit="0" size="1" desc="Read-write. Reset: 0. Hardware Assert: A hardware assert was detected." />
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC000_2161 -->
    <register name="MCA_STATUS_PIE" type="msr" msr="0x00000459" desc="PIE Machine Check Status. Reset: Cold,0000_0000_0000_0000h. Logs information associated with errors.">
      <field name="Val" bit="63" size="1" desc="Reset: Cold,0. 1=A valid error has been detected. This bit should be cleared by software after the register has been read. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Overflow" bit="62" size="1" desc="Reset: Cold,0. 1=An error was detected while the valid bit (Val) was set; at least one error was not logged. Overflow is set independently of whether the existing error is overwritten. See 3.1.3 [Machine Check Errors]. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="UC" bit="61" size="1" desc="Reset: Cold,0. 1=The error was not corrected by hardware. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="En" bit="60" size="1" desc="Reset: Cold,0. 1=MCA error reporting is enabled for this error, as indicated by the corresponding bit in MCA::PIE::MCA_CTL_PIE. This bit is a copy of bit in MCA::PIE::MCA_CTL_PIE for this error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="MiscV" bit="59" size="1" desc="Reset: Cold,0. 1=Valid thresholding in MCA::PIE::MCA_MISC0_PIE. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="AddrV" bit="58" size="1" desc="Reset: Cold,0. 1=MCA::PIE::MCA_ADDR_PIE contains address information associated with the error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="PCC" bit="57" size="1" desc="Reset: Cold,0. 1=Hardware context held by the processor may have been corrupted. Continued operation of the system may have unpredictable results. The error is not recoverable or survivable, and the system should be reinitialized. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="ErrCoreIdVal" bit="56" size="1" desc="Reset: Cold,0. 1=The ErrCoreId field is valid. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="TCC" bit="55" size="1" desc="Reset: Cold,0. 0=The thread which consumed the error can be restarted reliably at the instruction pointer address pushed onto the exception handler stack if any uncorrected error has been corrected by software. 1=The thread which consumed the error is not restartable and must be terminated. Only meaningful when MCA::PIE::MCA_STATUS_PIE[PCC]=0. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bit 54 reserved. -->
      <field name="SyndV" bit="53" size="1" desc="Reset: Cold,0. 1=This error logged information in MCA::PIE::MCA_SYND_PIE. If MCA::PIE::MCA_SYND_PIE[ErrorPriority] is the same as the priority of the error in MCA::PIE::MCA_STATUS_PIE, then the information in MCA::PIE::MCA_SYND_PIE is associated with the error in MCA::PIE::MCA_STATUS_PIE. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 52:47 reserved. -->
      <field name="CECC" bit="46" size="1" desc="Reset: Cold,0. 1=The error was a correctable ECC error according to the restrictions of the ECC algorithm. UC indicates whether the error was actually corrected by the processor. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="UECC" bit="45" size="1" desc="Reset: Cold,0. 1=The error was an uncorrectable ECC error according to the restrictions of the ECC algorithm. UC indicates whether the error was actually corrected by the processor. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Deferred" bit="44" size="1" desc="Reset: Cold,0. 1=A deferred error was created. A deferred error is the result of an uncorrectable data error which did not immediately cause a processor exception; an exception is deferred until the erroneous data is consumed. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Poison" bit="43" size="1" desc="Reset: Cold,0. 1=The error was the result of attempting to consume poisoned data. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 42:38 reserved. -->
      <field name="ErrCoreId" bit="32" size="6" desc="Reset: Cold,00h. When ErrCoreIdVal=1 this field indicates which core within the processor is associated with the error; Otherwise this field is reserved. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 31:22 reserved. -->
      <field name="ErrorCodeExt" bit="16" size="6" desc="Reset: Cold,00h. Extended Error Code. This field is used to identify the error type for root cause analysis. This field indicates which bit position in MCA::PIE::MCA_CTL_PIE enables error reporting for the logged error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="ErrorCode" bit="0" size="16" desc="Reset: Cold,0000h. Error code for this error. See 3.1.3.3 [Error Codes] for details on decoding this field. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
    </register>

    <!-- page 246 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2162 -->
    <register name="MCA_ADDR_PIE" type="msr" msr="0x0000045A" desc="PIE Machine Check Address. Read-only. Reset: Cold,0000_0000_0000_0000h. MCA::PIE::MCA_ADDR_PIE stores an address and other information associated with the error in MCA::PIE::MCA_STATUS_PIE. The register is only meaningful if MCA::PIE::MCA_STATUS_PIE[Val]=1 and MCA::PIE::MCA_STATUS_PIE[AddrV]=1.">
      <!-- Bits 63:62 reserved. -->
      <field name="LSB" bit="56" size="6" desc="Read-only. Reset: Cold,00h. Specifies the least significant valid bit of the address contained in MCA::PIE::MCA_ADDR_PIE[ErrorAddr]. A value of 0 indicates that MCA::PIE::MCA_ADDR_PIE[55:0] contains a valid byte address. A value of 6 indicates that MCA::PIE::MCA_ADDR_PIE[55:6] contains a valid cache line address and that MCA::PIE::MCA_ADDR_PIE[5:0] are not part of the address and should be ignored by error handling software. A value of 12 indicates that MCA::PIE::MCA_ADDR_PIE[55:12] contain a valid 4KB memory page and that MCA::PIE::MCA_ADDR_PIE[11:0] should be ignored by error handling software." />
      <field name="ErrorAddr" bit="0" size="56" desc="Read-only. Reset: Cold,00_0000_0000_0000h. Contains the address, if any, associated with the error logged in MCA::PIE::MCA_STATUS_PIE." />
    </register>

    <!-- page 247 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2163 -->
    <register name="MCA_MISC0_PIE" type="msr" msr="0x0000045B" desc="PIE Machine Check Miscellaneous 0. Log miscellaneous information associated with errors.">
      <field name="Valid" bit="63" size="1" desc="Reset: 1. 1=A valid CntP field is present in this register. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="CntP" bit="62" size="1" desc="Reset: 1. 1=A valid threshold counter is present. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="Locked" bit="61" size="1" desc="Reset: 0. 1=Writes to this register are ignored. This bit is set by BIOS to indicate that this register is not available for OS use. BIOS should set this bit if ThresholdIntType is set to SMI. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="IntP" bit="60" size="1" desc="Reset: 1. 1=ThresholdIntType can be used to generate interrupts. 0=ThresholdIntType and interrupt generation are not supported. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::PIE::MCA_MISC0_PIE[Locked]) ? Read- write : Read-only." />
      <!-- Bits 59:56 reserved. -->
      <field name="LvtOffset" bit="52" size="4" desc="Reset: 0h. One per die. For error thresholding interrupts, specifies the address of the LVT entry in the APIC registers as follows: LVT address = (LvtOffset shifted left 4 bits) + 500h (see Core::X86::Apic::ExtendedInterruptLvtEntries). AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::PIE::MCA_MISC0_PIE[Locked]) ? Read- write : Read-only." />
      <field name="CntEn" bit="51" size="1" desc="Reset: 0. 1=Count thresholding errors. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::PIE::MCA_MISC0_PIE[Locked]) ? Read- write : Read-only." />
      <field name="ThresholdIntType" bit="49" size="2" desc="Reset: Cold,0h. Specifies the type of interrupt signaled when Ovrflw is set and IntP==1. 00b = No interrupt. 01b = APIC based interrupt (see Core::X86::Msr::McaIntrCfg[ThresholdLvtOffset]). 10b = SMI trigger event. 11b = Reserved. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::PIE::MCA_MISC0_PIE[Locked]) ? Read- write : Read-only." />
      <field name="Ovrflw" bit="48" size="1" desc="Reset: Cold,0. Set by hardware when ErrCnt transitions from FFEh to FFFh. When this field is set, ErrCnt no longer increments. When this bit is set, the interrupt selected by the ThresholdIntType field is generated. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::PIE::MCA_MISC0_PIE[Locked]) ? Read- write : Read-only." />
      <!-- Bits 47:44 reserved. -->
      <field name="ErrCnt" bit="32" size="12" desc="Reset: Cold,000h. This is written by software to set the starting value of the error counter. This is incremented by hardware when errors are logged. When this counter overflows, it stays at FFFh (no rollover). The threshold value, written by software, is (FFFh - the desired error count (the number of errors necessary in order for an interrupt to be taken)); the desired error count of 0 (a write value of FFFh) is not supported. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::PIE::MCA_MISC0_PIE[Locked]) ? Read- write : Read-only." />
      <field name="BlkPtr" bit="24" size="8" desc="Read-write. Reset: 01h. 00h=Extended MISC MSR block is not valid. 01h=Extended MSR block is valid." />
      <!-- Bits 23:0 reserved. -->
    </register>

    <!-- page 248 -->

    <register name="MCA_CONFIG_PIE" type="msr" msr="0xC0002164" desc="PIE Machine Check Configuration. Reset: 0000_0002_0000_0025h. Controls configuration of the associated machine check bank.">
      <!-- Bits 63:39 reserved. -->
      <field name="DeferredIntType" bit="37" size="2" desc="Read-write. Reset: 0h. Specifies the type of interrupt signaled when a deferred error is logged. 00b = No interrupt. 01b = APIC based interrupt (see Core::X86::Msr::McaIntrCfg[DeferredLvtOffset]). 10b = SMI trigger event. 11b = Reserved." />
      <!-- Bits 36:35 reserved. -->
      <field name="LogDeferredInMcaStat" bit="34" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. 1=Log deferred errors in MCA::PIE::MCA_STATUS_PIE and MCA::PIE::MCA_ADDR_PIE in addition to MCA::PIE::MCA_DESTAT_PIE and MCA::PIE::MCA_DEADDR_PIE. 0=Only log deferred errors in MCA::PIE::MCA_DESTAT_PIE and MCA::PIE::MCA_DEADDR_PIE. This bit does not affect logging of deferred errors in MCA::PIE::MCA_SYND_PIE, MCA::PIE::MCA_MISC0_PIE." />
      <!-- Bit 33 reserved. -->
      <field name="McaXEnable" bit="32" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. Check: 1. 1=Software has acknowledged support for the MCAX feature set. 0=Software has not acknowledged support for the MCAX feature set. All uncorrected and fatal errors will cause an ErrorEvent packet to be generated. Deferred error interrupts are configured via Core::X86::Msr::McaIntrCfg." />
      <!-- Bits 31:6 reserved. -->
      <field name="DeferredIntTypeSupported" bit="5" size="1" desc="Read-only. Reset: 1. 1=MCA::PIE::MCA_CONFIG_PIE[DeferredIntType] controls the type of interrupt generated on a deferred error. Deferred errors are supported in this bank only if MCA::PIE::MCA_CONFIG_PIE[DeferredErrorLoggingSupported]=1." />
      <!-- Bits 4:3 reserved. -->
      <field name="DeferredErrorLoggingSupported" bit="2" size="1" desc="Read-only. Reset: 1. 1=Deferred errors are supported in this MCA bank, and MCA::PIE::MCA_CONFIG_PIE[LogDeferredInMcaStat] controls the logging behavior of these errors. MCA::PIE::MCA_DESTAT_PIE and MCA::PIE::MCA_DEADDR_PIE are supported in this MCA bank. 0=Deferred errors are not supported in this bank." />
      <!-- Bit 1 reserved. -->
      <field name="McaX" bit="0" size="1" desc="Read-only. Reset: 1. 1=This bank provides Machine Check Architecture Extensions. Up to 4 additional MISC registers (MISC1-MISC4) are supported. MCA::PIE::MCA_MISC0_PIE[BlkPtr] indicates the presence of the additional MISC registers, but is not used to determine their MSR numbers. Deferred error interrupt type is specifiable by MCA bank. MCA::PIE::MCA_STATUS_PIE[TCC] is present." />
    </register>
    <register name="MCA_IPID_PIE" type="msr" msr="0xC0002165" desc="PIE IP Identification. Reset: 0001_002E_0000_0000h. The MCA::PIE::MCA_IPID_PIE register is used by software to determine what IP type and revision is associated with the MCA bank.">
      <field name="McaType" bit="48" size="16" desc="Read-only. Reset: 0001h. The McaType of the MCA bank within this IP." />
      <!-- Bits 47:44 reserved. -->
      <field name="HardwareID" bit="32" size="12" desc="Read-only. Reset: 02Eh. The Hardware ID of the IP associated with this MCA bank." />
      <field name="InstanceId" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. The instance ID of this IP. This is initialized to a unique ID per instance of this register." />
    </register>

    <!-- page 249 -->

    <register name="MCA_SYND_PIE" type="msr" msr="0xC0002166" desc="PIE Machine Check Syndrome. Read-write,Volatile. Reset: Cold,0000_0000_0000_0000h. Logs physical location information associated with error in MCA::PIE::MCA_STATUS_PIE Thread 0">
      <!-- Bits 63:33 reserved. -->
      <field name="Syndrome" bit="32" size="1" desc="Read-write,Volatile. Reset: Cold,0. Contains the syndrome, if any, associated with the error logged in MCA::PIE::MCA_STATUS_PIE. The low-order bit of the syndrome is stored in bit 0, and the syndrome has a length specified by MCA::PIE::MCA_SYND_PIE[Length]. The Syndrome field is only valid when MCA::PIE::MCA_SYND_PIE[Length] is not 0." />
      <!-- Bits 31:27 reserved. -->
      <field name="ErrorPriority" bit="24" size="3" desc="Read-write,Volatile. Reset: Cold,0h. Encodes the priority of the error logged in MCA::PIE::MCA_SYND_PIE. 3'b000 = No error; 3'b001 = Reserved; 3'b010 = Corrected Error; 3'b011 = Deferred Error; 3'b100 = Uncorrected Error; 3'b101 = Fatal Error; all others reserved." />
      <field name="Length" bit="18" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the length in bits of the syndrome contained in MCA::PIE::MCA_SYND_PIE[Syndrome]. A value of 0 indicates that there is no valid syndrome in MCA::PIE::MCA_SYND_PIE. For example, a syndrome length of 9 means that MCA::PIE::MCA_SYND_PIE[Syndrome] bits [8:0] contains a valid syndrome." />
      <field name="ErrorInformation" bit="0" size="18" desc="Read-write,Volatile. Reset: Cold,0_0000h. Contains error-specific information about the location of the error. Decoding is available in Table 59 [MCA_SYND_PIE Register]." />
    </register>
    <register name="MCA_DESTAT_PIE" type="msr" msr="0xC0002168" desc="PIE Machine Check Deferred Error Status. Read-write,Volatile. Reset: Cold,0000_0000_0000_0000h. Holds status information for the first deferred error seen in this bank.">
      <field name="Val" bit="63" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=A valid error has been detected (whether it is enabled or not)." />
      <field name="Overflow" bit="62" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=An error was detected while the valid bit (Val) was set; at least one error was not logged. Overflow is set independently of whether the existing error is overwritten. (See the section on overwrite priorities.)" />
      <!-- Bits 61:59 reserved. -->
      <field name="AddrV" bit="58" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=MCA::PIE::MCA_DEADDR_PIE contains address information associated with the error." />
      <!-- Bits 57:54 reserved. -->
      <field name="SyndV" bit="53" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=This error logged information in MCA::PIE::MCA_SYND_PIE. If MCA::PIE::MCA_SYND_PIE[ErrorPriority] is the same as the priority of the error in MCA::PIE::MCA_STATUS_PIE, then the information in MCA::PIE::MCA_SYND_PIE is associated with the error in MCA::PIE::MCA_DESTAT_PIE." />
      <!-- Bits 52:45 reserved. -->
      <field name="Deferred" bit="44" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=A deferred error was created. A deferred error is the result of an uncorrectable data error which did not immediately cause a processor exception; poison is created and an exception is deferred until the poison data is consumed." />
      <!-- Bits 43:0 reserved. -->
    </register>

    <!-- page 250 -->

    <register name="MCA_DEADDR_PIE" type="msr" msr="0xC0002169" desc="PIE Deferred Error Address. Reset: Cold,0000_0000_0000_0000h. The MCA::PIE::MCA_DEADDR_PIE register stores the address associated with the error in MCA::PIE::MCA_DESTAT_PIE. The register is only meaningful if MCA::PIE::MCA_DESTAT_PIE[Val]=1 and MCA::PIE::MCA_DESTAT_PIE[AddrV]=1. The lowest valid bit of the address is defined by MCA::PIE::MCA_DEADDR_PIE[LSB].">
      <!-- Bits 63:62 reserved. -->
      <field name="LSB" bit="56" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the least significant valid bit of the address contained in MCA::PIE::MCA_DEADDR_PIE[ErrorAddr]. A value of 0 indicates that MCA::PIE::MCA_DEADDR_PIE[55:0] contains a valid byte address. A value of 6 indicates that MCA::PIE::MCA_DEADDR_PIE[55:6] contains a valid cache line address and that MCA::PIE::MCA_DEADDR_PIE[5:0] are not part of the address and should be ignored by error handling software. A value of 12 indicates that MCA::PIE::MCA_DEADDR_PIE[55:12] contain a valid 4KB memory page and that MCA::PIE::MCA_DEADDR_PIE[11:0] should be ignored by error handling software." />
      <field name="ErrorAddr" bit="0" size="56" desc="Read-write,Volatile. Reset: Cold,00_0000_0000_0000h. Contains the address, if any, associated with the error logged in MCA::PIE::MCA_DESTAT_PIE. The lowest-order valid bit of the address is specified in MCA::PIE::MCA_DEADDR_PIE[LSB]." />
    </register>
    <register name="MCA_CTL_MASK_PIE" type="msr" msr="0xC0010416" desc="PIE Machine Check Control Mask. Read-write. Reset: 0000_0000_0000_0000h. Inhibit detection of an error source.">
      <!-- Bits 63:4 reserved. -->
      <field name="FTI_DAT_STAT" bit="3" size="1" desc="Read-write. Reset: 0. Poison data consumption: Poison data was written to an internal PIE register." />
      <field name="GMI" bit="2" size="1" desc="Read-write. Reset: 0. Link Error: An error occurred on a GMI or xGMI link." />
      <field name="CSW" bit="1" size="1" desc="Read-write. Reset: 0. Register security violation: A security violation was detected on an access to an internal PIE register." />
      <field name="HW_ASSERT" bit="0" size="1" desc="Read-write. Reset: 0. Hardware Assert: A hardware assert was detected." />
    </register>

    <!-- 3.2.5.10 UMC -->

    <!-- TODO Multiple MSR instances, skipping MSR0000_0440 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_20F0 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2100 -->
    <register name="MCA_CTL_UMC" type="msr" msr="0x0000043C" desc="UMC Machine Check Control. Read-write. Reset: 0000_0000_0000_0000h. 0=Disables error reporting for the corresponding error. 1=Enables error reporting via machine check exception for the corresponding error. The MCA::UMC::MCA_CTL_UMC register must be enabled by the corresponding enable bit in Core::X86::Msr::MCG_CTL. Does not affect error detection, correction, or logging.">
      <!-- Bits 63:6 reserved. -->
      <field name="WriteDataCrcErr" bit="5" size="1" desc="Read-write. Reset: 0. Write data CRC error. A write data CRC error on the DRAM data bus." />
      <field name="AddressCommandParityErr" bit="4" size="1" desc="Read-write. Reset: 0. Address/command parity error. A parity error on the DRAM address/command bus." />
      <field name="ApbErr" bit="3" size="1" desc="Read-write. Reset: 0. Advanced peripheral bus error. An error on the advanced peripheral bus." />
      <field name="SdpParityErr" bit="2" size="1" desc="Read-write. Reset: 0. SDP parity error. A parity error on write data from the data fabric." />
      <field name="WriteDataPoisonErr" bit="1" size="1" desc="Read-write. Reset: 0. Data poison error." />
      <field name="DramEccErr" bit="0" size="1" desc="Read-write. Reset: 0. DRAM ECC error. An ECC error on a DRAM read." />
    </register>

    <!-- page 251 -->

    <!-- TODO Multiple MSR instances, skipping MSR0000_0441 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_20F1 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2101 -->
    <register name="MCA_STATUS_UMC" type="msr" msr="0x0000043D" desc="UMC Machine Check Status. Reset: Cold,0000_0000_0000_0000h. Logs information associated with errors.">
      <field name="Val" bit="63" size="1" desc="Reset: Cold,0. 1=A valid error has been detected. This bit should be cleared by software after the register has been read. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Overflow" bit="62" size="1" desc="Reset: Cold,0. 1=An error was detected while the valid bit (Val) was set; at least one error was not logged. Overflow is set independently of whether the existing error is overwritten. See 3.1.3 [Machine Check Errors]. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="UC" bit="61" size="1" desc="Reset: Cold,0. 1=The error was not corrected by hardware. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="En" bit="60" size="1" desc="Reset: Cold,0. 1=MCA error reporting is enabled for this error, as indicated by the corresponding bit in MCA::UMC::MCA_CTL_UMC. This bit is a copy of bit in MCA::UMC::MCA_CTL_UMC for this error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="MiscV" bit="59" size="1" desc="Reset: Cold,0. 1=Valid thresholding in MCA::UMC::MCA_MISC0_UMC. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="AddrV" bit="58" size="1" desc="Reset: Cold,0. 1=MCA::UMC::MCA_ADDR_UMC contains address information associated with the error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="PCC" bit="57" size="1" desc="Reset: Cold,0. 1=Hardware context held by the processor may have been corrupted. Continued operation of the system may have unpredictable results. The error is not recoverable or survivable, and the system should be reinitialized. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="ErrCoreIdVal" bit="56" size="1" desc="Reset: Cold,0. 1=The ErrCoreId field is valid. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="TCC" bit="55" size="1" desc="Reset: Cold,0. 0=The thread which consumed the error can be restarted reliably at the instruction pointer address pushed onto the exception handler stack if any uncorrected error has been corrected by software. 1=The thread which consumed the error is not restartable and must be terminated. Only meaningful when MCA::UMC::MCA_STATUS_UMC[PCC]=0. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bit 54 reserved. -->
      <field name="SyndV" bit="53" size="1" desc="Reset: Cold,0. 1=This error logged information in MCA::UMC::MCA_SYND_UMC. If MCA::UMC::MCA_SYND_UMC[ErrorPriority] is the same as the priority of the error in MCA::UMC::MCA_STATUS_UMC, then the information in MCA::UMC::MCA_SYND_UMC is associated with the error in MCA::UMC::MCA_STATUS_UMC. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 52:47 reserved. -->
      <field name="CECC" bit="46" size="1" desc="Reset: Cold,0. 1=The error was a correctable ECC error according to the restrictions of the ECC algorithm. UC indicates whether the error was actually corrected by the processor. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="UECC" bit="45" size="1" desc="Reset: Cold,0. 1=The error was an uncorrectable ECC error according to the restrictions of the ECC algorithm. UC indicates whether the error was actually corrected by the processor. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Deferred" bit="44" size="1" desc="Reset: Cold,0. 1=A deferred error was created. A deferred error is the result of an uncorrectable data error which did not immediately cause a processor exception; an exception is deferred until the erroneous data is  consumed. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="Poison" bit="43" size="1" desc="Reset: Cold,0. 1=The error was the result of attempting to consume poisoned data. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 42:38 reserved. -->
      <field name="ErrCoreId" bit="32" size="6" desc="Reset: Cold,00h. When ErrCoreIdVal=1 this field indicates which core within the processor is associated with the error; Otherwise this field is reserved. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <!-- Bits 31:22 reserved. -->
      <field name="ErrorCodeExt" bit="16" size="6" desc="Reset: Cold,00h. Extended Error Code. This field is used to identify the error type for root cause analysis. This field indicates which bit position in MCA::UMC::MCA_CTL_UMC enables error reporting for the logged error. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
      <field name="ErrorCode" bit="0" size="16" desc="Reset: Cold,0000h. Error code for this error. See 3.1.3.3 [Error Codes] for details on decoding this field. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read,Write-0-only,Error-on-write-1." />
    </register>

    <!-- page 252 -->

    <!-- TODO Multiple MSR instances, skipping MSR0000_0442 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_20F2 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2102 -->
    <register name="MCA_ADDR_UMC" type="msr" msr="0x0000043E" desc="UMC Machine Check Address. Reset: Cold,0000_0000_0000_0000h. MCA::UMC::MCA_ADDR_UMC stores an address and other information associated with the error in MCA::UMC::MCA_STATUS_UMC. The register is only meaningful if MCA::UMC::MCA_STATUS_UMC[Val]=1 and MCA::UMC::MCA_STATUS_UMC[AddrV]=1.">
      <!-- Bits 63:62 reserved. -->
      <field name="LSB" bit="56" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the least significant valid bit of the address contained in MCA::UMC::MCA_ADDR_UMC[ErrorAddr]. A value of 0 indicates that MCA::UMC::MCA_ADDR_UMC[55:0] contains a valid byte address. A value of 6 indicates that MCA::UMC::MCA_ADDR_UMC[55:6] contains a valid cache line address and that MCA::UMC::MCA_ADDR_UMC[5:0] are not part of the address and should be ignored by error handling software. A value of 12 indicates that MCA::UMC::MCA_ADDR_UMC[55:12] contain a valid 4KB memory page and that MCA::UMC::MCA_ADDR_UMC[11:0] should be ignored by error handling software." />
      <field name="ErrorAddr" bit="0" size="56" desc="Read-write,Volatile. Reset: Cold,00_0000_0000_0000h. Unless otherwise specified by an error, contains the address associated with the error logged in MCA::UMC::MCA_STATUS_UMC. For physical addresses, the most significant bit is given by Core::X86::Cpuid::LongModeInfo[PhysAddrSize]." />
    </register>

    <!-- page 253 -->

    <!-- TODO Multiple MSR instances, skipping MSR0000_0443 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_20F3 -->
    <!-- TODO Multiple MSR instances, skipping MSRC000_2103 -->
    <register name="MCA_MISC0_UMC" type="msr" msr="0x0000043F" desc="UMC Machine Check Miscellaneous 0. Log miscellaneous information associated with errors.">
      <field name="Valid" bit="63" size="1" desc="Reset: 1. 1=A valid CntP field is present in this register. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="CntP" bit="62" size="1" desc="Reset: 1. 1=A valid threshold counter is present. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="Locked" bit="61" size="1" desc="Reset: 0. 1=Writes to this register are ignored. This bit is set by BIOS to indicate that this register is not available for OS use. BIOS should set this bit if ThresholdIntType is set to SMI. AccessType: Core::X86::Msr::HWCR[McStatusWrEn] ? Read-write : Read-only." />
      <field name="IntP" bit="60" size="1" desc="Reset: 1. 1=ThresholdIntType can be used to generate interrupts. 0=ThresholdIntType and interrupt generation are not supported. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::UMC::MCA_MISC0_UMC[Locked]) ? Read- write : Read-only." />
      <!-- Bits 59:56 reserved. -->
      <field name="LvtOffset" bit="52" size="4" desc="Reset: 0h. One per die. For error thresholding interrupts, specifies the address of the LVT entry in the APIC registers as follows: LVT address = (LvtOffset shifted left 4 bits) + 500h (see Core::X86::Apic::ExtendedInterruptLvtEntries). AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::UMC::MCA_MISC0_UMC[Locked]) ? Read- write : Read-only." />
      <field name="CntEn" bit="51" size="1" desc="Reset: 0. 1=Count thresholding errors. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::UMC::MCA_MISC0_UMC[Locked]) ? Read- write : Read-only." />
      <field name="ThresholdIntType" bit="49" size="2" desc="Reset: Cold,0h. Specifies the type of interrupt signaled when Ovrflw is set and IntP==1. 00b = No interrupt. 01b = APIC based interrupt (see Core::X86::Msr::McaIntrCfg[ThresholdLvtOffset]). 10b = SMI trigger event. 11b = Reserved. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::UMC::MCA_MISC0_UMC[Locked]) ? Read- write : Read-only." />
      <field name="Ovrflw" bit="48" size="1" desc="Reset: Cold,0. Set by hardware when ErrCnt transitions from FFEh to FFFh. When this field is set, ErrCnt no longer increments. When this bit is set, the interrupt selected by the ThresholdIntType field is generated.   AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::UMC::MCA_MISC0_UMC[Locked]) ? Read- write : Read-only." />
      <!-- Bits 47:44 reserved. -->
      <field name="ErrCnt" bit="32" size="12" desc="Reset: Cold,000h. This is written by software to set the starting value of the error counter. This is incremented by hardware when errors are logged. When this counter overflows, it stays at FFFh (no rollover). The threshold value, written by software, is (FFFh - the desired error count (the number of errors necessary in order for an interrupt to be taken)); the desired error count of 0 (a write value of FFFh) is not supported. AccessType: (Core::X86::Msr::HWCR[McStatusWrEn] | !MCA::UMC::MCA_MISC0_UMC[Locked]) ? Read- write : Read-only." />
      <field name="BlkPtr" bit="24" size="8" desc="Read-write. Reset: 01h. 00h=Extended MISC MSR block is not valid. 01h=Extended MSR block is valid." />
      <!-- Bits 23:0 reserved. -->
    </register>

    <!-- page 254 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2104 -->
    <register name="MCA_CONFIG_UMC" type="msr" msr="0xC00020F4" desc="UMC Machine Check Configuration. Reset: 0000_0002_0000_0025h. Controls configuration of the associated machine check bank.">
      <!-- Bits 63:39 reserved. -->
      <field name="DeferredIntType" bit="37" size="2" desc="Read-write. Reset: 0h. Specifies the type of interrupt signaled when a deferred error is logged. 00b = No interrupt. 01b = APIC based interrupt (see Core::X86::Msr::McaIntrCfg[DeferredLvtOffset]). 10b = SMI trigger event. 11b = Reserved." />
      <!-- Bits 36:35 reserved. -->
      <field name="LogDeferredInMcaStat" bit="34" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. 1=Log deferred errors in MCA::UMC::MCA_STATUS_UMC and MCA::UMC::MCA_ADDR_UMC in addition to MCA::UMC::MCA_DESTAT_UMC and MCA::UMC::MCA_DEADDR_UMC. 0=Only log deferred errors in MCA::UMC::MCA_DESTAT_UMC and MCA::UMC::MCA_DEADDR_UMC. This bit does not affect logging of deferred errors in MCA::UMC::MCA_SYND_UMC, MCA::UMC::MCA_MISC0_UMC." />
      <!-- Bit 33 reserved. -->
      <field name="McaXEnable" bit="32" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. Check: 1. 1=Software has acknowledged support for the MCAX feature set. 0=Software has not acknowledged support for the MCAX feature set. All uncorrected and fatal errors will cause an ErrorEvent packet to be generated. Deferred error interrupts are configured via Core::X86::Msr::McaIntrCfg." />
      <!-- Bits 31:6 reserved. -->
      <field name="DeferredIntTypeSupported" bit="5" size="1" desc="Read-only. Reset: 1. 1=MCA::UMC::MCA_CONFIG_UMC[DeferredIntType] controls the type of interrupt generated on a deferred error. Deferred errors are supported in this bank only if MCA::UMC::MCA_CONFIG_UMC[DeferredErrorLoggingSupported]=1." />
      <!-- Bits 4:3 reserved. -->
      <field name="DeferredErrorLoggingSupported" bit="2" size="1" desc="Read-only. Reset: 1. 1=Deferred errors are supported in this MCA bank, and MCA::UMC::MCA_CONFIG_UMC[LogDeferredInMcaStat] controls the logging behavior of these errors. MCA::UMC::MCA_DESTAT_UMC and MCA::UMC::MCA_DEADDR_UMC are supported in this MCA bank. 0=Deferred errors are not supported in this bank." />
      <!-- Bit 1 reserved. -->
      <field name="McaX" bit="0" size="1" desc="Read-only. Reset: 1. 1=This bank provides Machine Check Architecture Extensions. Up to 4 additional MISC registers (MISC1-MISC4) are supported. MCA::UMC::MCA_MISC0_UMC[BlkPtr] indicates the presence of the additional MISC registers, but is not used to determine their MSR numbers. Deferred error interrupt type is specifiable by MCA bank. MCA::UMC::MCA_STATUS_UMC[TCC] is present." />
    </register>

    <!-- page 255 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2105 -->
    <register name="MCA_IPID_UMC" type="msr" msr="0xC00020F5" desc="UMC IP Identification. Reset: 0000_0096_0000_0000h. The MCA::UMC::MCA_IPID_UMC register is used by software to determine what IP type and revision is associated with the MCA bank.">
      <field name="McaType" bit="48" size="16" desc="Read-only. Reset: 0000h. The McaType of the MCA bank within this IP." />
      <!-- Bits 47:44 reserved. -->
      <field name="HardwareID" bit="32" size="12" desc="Read-only. Reset: 096h. The Hardware ID of the IP associated with this MCA bank." />
      <field name="InstanceId" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. The instance ID of this IP. This is initialized to a unique ID per instance of this register." />
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC000_2106 -->
    <register name="MCA_SYND_UMC" type="msr" msr="0xC00020F6" desc="UMC Machine Check Syndrome. Read-write,Volatile. Reset: Cold,0000_0000_0000_0000h. Logs physical location information associated with error in MCA::UMC::MCA_STATUS_UMC Thread 0">
      <!-- Bits 63:48 reserved. -->
      <field name="Syndrome" bit="32" size="16" desc="Read-write,Volatile. Reset: Cold,0000h. Contains the syndrome, if any, associated with the error logged in MCA::UMC::MCA_STATUS_UMC. The low-order bit of the syndrome is stored in bit 0, and the syndrome has a length specified by MCA::UMC::MCA_SYND_UMC[Length]. The Syndrome field is only valid when MCA::UMC::MCA_SYND_UMC[Length] is not 0." />
      <!-- Bits 31:27 reserved. -->
      <field name="ErrorPriority" bit="24" size="3" desc="Read-write,Volatile. Reset: Cold,0h. Encodes the priority of the error logged in MCA::UMC::MCA_SYND_UMC. 3'b000 = No error; 3'b001 = Reserved; 3'b010 = Corrected Error; 3'b011 = Deferred Error; 3'b100 = Uncorrected Error; 3'b101 = Fatal Error; all others reserved." />
      <field name="Length" bit="18" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the length in bits of the syndrome contained in MCA::UMC::MCA_SYND_UMC[Syndrome]. A value of 0 indicates that there is no valid syndrome in MCA::UMC::MCA_SYND_UMC. For example, a syndrome length of 9 means that MCA::UMC::MCA_SYND_UMC[Syndrome] bits [8:0] contains a valid syndrome." />
      <field name="ErrorInformation" bit="0" size="18" desc="Read-write,Volatile. Reset: Cold,0_0000h. Contains error-specific information about the location of the error. Decoding is available in Table 62 [MCA_SYND_UMC Register]." />
    </register>

    <!-- page 256 -->

    <!-- TODO Multiple MSR instances, skipping MSRC000_2108 -->
    <register name="MCA_DESTAT_UMC" type="msr" msr="0xC00020F8" desc="UMC Machine Check Deferred Error Status. Read-write,Volatile. Reset: Cold,0000_0000_0000_0000h. Holds status information for the first deferred error seen in this bank.">
      <field name="Val" bit="63" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=A valid error has been detected (whether it is enabled or not)." />
      <field name="Overflow" bit="62" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=An error was detected while the valid bit (Val) was set; at least one error was not logged. Overflow is set independently of whether the existing error is overwritten. (See the section on overwrite priorities.)" />
      <!-- Bits 61:59 reserved. -->
      <field name="AddrV" bit="58" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=MCA::UMC::MCA_DEADDR_UMC contains address information associated with the error." />
      <!-- Bits 57:54 reserved. -->
      <field name="SyndV" bit="53" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=This error logged information in MCA::UMC::MCA_SYND_UMC. If MCA::UMC::MCA_SYND_UMC[ErrorPriority] is the same as the priority of the error in MCA::UMC::MCA_STATUS_UMC, then the information in MCA::UMC::MCA_SYND_UMC is associated with the error in MCA::UMC::MCA_DESTAT_UMC." />
      <!-- Bits 52:45 reserved. -->
      <field name="Deferred" bit="44" size="1" desc="Read-write,Volatile. Reset: Cold,0. 1=A deferred error was created. A deferred error is the result of an uncorrectable data error which did not immediately cause a processor exception; poison is created and an exception is deferred until the poison data is consumed." />
      <!-- Bits 43:0 reserved. -->
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC000_2109 -->
    <register name="MCA_DEADDR_UMC" type="msr" msr="0xC00020F9" desc="UMC Deferred Error Address. Reset: Cold,0000_0000_0000_0000h. The MCA::UMC::MCA_DEADDR_UMC register stores the address associated with the error in MCA::UMC::MCA_DESTAT_UMC. The register is only meaningful if MCA::UMC::MCA_DESTAT_UMC[Val]=1 and MCA::UMC::MCA_DESTAT_UMC[AddrV]=1. The lowest valid bit of the address is defined by MCA::UMC::MCA_DEADDR_UMC[LSB].">
      <!-- Bits 63:62 reserved. -->
      <field name="LSB" bit="56" size="6" desc="Read-write,Volatile. Reset: Cold,00h. Specifies the least significant valid bit of the address contained in MCA::UMC::MCA_DEADDR_UMC[ErrorAddr]. A value of 0 indicates that MCA::UMC::MCA_DEADDR_UMC[55:0] contains a valid byte address. A value of 6 indicates that MCA::UMC::MCA_DEADDR_UMC[55:6] contains a valid cache line address and that MCA::UMC::MCA_DEADDR_UMC[5:0] are not part of the address and should be ignored by error handling software. A value of 12 indicates that MCA::UMC::MCA_DEADDR_UMC[55:12] contain a valid 4KB memory page and that MCA::UMC::MCA_DEADDR_UMC[11:0] should be ignored by error handling software." />
      <field name="ErrorAddr" bit="0" size="56" desc="Read-write,Volatile. Reset: Cold,00_0000_0000_0000h. Contains the address, if any, associated with the error logged in MCA::UMC::MCA_DESTAT_UMC. The lowest-order valid bit of the address is specified in MCA::UMC::MCA_DEADDR_UMC[LSB]." />
    </register>

    <!-- TODO Multiple MSR instances, skipping MSRC000_210A -->
    <register name="MCA_MISC1_UMC" type="msr" msr="0xC00020FA" desc="UMC Machine Check Miscellaneous 1. Read-write. Log miscellaneous information associated with errors, as defined by each error type.">
      <field name="Valid" bit="63" size="1" desc="Read-write. Reset: 1. 1=A valid CntP field is present in this register." />
      <field name="CntP" bit="62" size="1" desc="Read-write. Reset: 1. 1=A valid threshold counter is present." />
      <field name="Locked" bit="61" size="1" desc="Read-write. Reset: 0. 1=Writes to this register are ignored. This bit is set by BIOS to indicate that this   register is not available for OS use. BIOS should set this bit if ThresholdIntType is set to SMI." />
      <field name="IntP" bit="60" size="1" desc="Read-write. Reset: 1. 1=ThresholdIntType can be used to generate interrupts. 0=ThresholdIntType and interrupt generation are not supported." />
      <!-- Bits 59:52 reserved. -->
      <field name="CntEn" bit="51" size="1" desc="Read-write. Reset: 0. 1=Count thresholding errors." />
      <field name="ThresholdIntType" bit="49" size="2" desc="Read-write. Reset: Cold,0h. Specifies the type of interrupt signaled when Ovrflw is set. 00b = No interrupt. 01b = APIC based interrupt (see Core::X86::Msr::McaIntrCfg[ThresholdLvtOffset]) to all cores. 10b = SMI trigger event. 11b = Reserved." />
      <field name="Ovrflw" bit="48" size="1" desc="Read-write. Reset: Cold,0. Set by hardware when ErrCnt transitions from FFEh to FFFh; also set by hardware if ErrCnt is initialized to FFFh and transitions from FFFh to 000h. When this field is set, ErrCnt no longer increments. When this bit is set, the interrupt selected by the ThresholdIntType field is generated." />
      <!-- Bits 47:44 reserved. -->
      <field name="ErrCnt" bit="32" size="12" desc="Read-write. Reset: Cold,000h. This is written by software to set the starting value of the error counter. This is incremented by hardware when errors are logged. When this counter overflows, it stays at FFFh (no rollover). The threshold value, written by software, is (FFFh - the desired error count (the number of errors necessary in order for an interrupt to be taken)); the desired error count of 0 (a write value of FFFh) is not supported." />
      <field name="BlkPtr" bit="24" size="8" desc="Read-write. Reset: 01h. 00h=Extended MISC MSR block is not valid. 01h=Extended MSR block is valid." />
      <!-- Bits 23:0 reserved. -->
    </register>

    <!-- page 257 -->

    <!-- TODO Multiple MSR instances, skipping MSRC001_0410 -->
    <register name="MCA_CTL_MASK_UMC" type="msr" msr="0xC001040F" desc="UMC Machine Check Control Mask. Read-write. Reset: 0000_0000_0000_0000h. Inhibit detection of an error source.">
      <!-- Bits 63:6 reserved. -->
      <field name="WriteDataCrcErr" bit="5" size="1" desc="Read-write. Reset: 0. Write data CRC error. A write data CRC error on the DRAM data bus." />
      <field name="AddressCommandParityErr" bit="4" size="1" desc="Read-write. Reset: 0. Address/command parity error. A parity error on the DRAM address/command bus." />
      <field name="ApbErr" bit="3" size="1" desc="Read-write. Reset: 0. Advanced peripheral bus error. An error on the advanced peripheral bus." />
      <field name="SdpParityErr" bit="2" size="1" desc="Read-write. Reset: 0. SDP parity error. A parity error on write data from the data fabric." />
      <field name="WriteDataPoisonErr" bit="1" size="1" desc="Read-write. Reset: 0. Data poison error." />
      <field name="DramEccErr" bit="0" size="1" desc="Read-write. Reset: 0. DRAM ECC error. An ECC error on a DRAM read." />
    </register>

    <!-- 4.2.1 Registers -->

    <!-- page 258 -->

    <register name="THM_TCON_CUR_TMP" type="indirect" device="SMUTHM" offset="0x00000000" size="4" desc="SMU::THM::THM_TCON_CUR_TMP. Reset: 0000_0000h.">
      <field name="CUR_TEMP" bit="21" size="11" desc="Reset: 000h. Provides current control temperature. AccessType: _aliasHOSTGPU: Read-write AccessType: _aliasSMN: (InitiatorTrust > 2) ? Read-only : Read-write" />
      <!-- Bit 20 reserved. -->
      <field name="CUR_TEMP_RANGE_SEL" bit="19" size="1" desc="Reset: 0. 0=Report on 0C to 225C scale range. 1=Report on -49C to 206C scale range. AccessType: _aliasHOSTGPU: Read-write AccessType: _aliasSMN: (InitiatorTrust > 2) ? Read-only : Read-write" />
      <!-- Bits 18:0 reserved. -->
    </register>

    <!-- 8.1.2.1 IOMMUL1 Registers -->

    <!-- page 274 -->

    <!-- TODO Multiple BAR instances, keeping only first one: IOMMUL1INT[0...1]x0000001C (IOMMUL1::L1_MISC_CNTRL_1) -->
    <register name="L1_MISC_CNTRL_1" type="indirect" device="IOMMUL1INT0" offset="0x0000001C" size="4" desc="IOMMUL1::L1_MISC_CNTRL_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:18 reserved. -->
      <field name="REG_enable_nw" bit="17" size="1" desc="Read-write. Reset: 0. 0=Don't force. 1=Force NW low for ATS. Force NW low." />
      <!-- Bits 16:7 reserved. -->
      <field name="REG_force_invalid_filter" bit="6" size="1" desc="Read-write. Reset: 0. 0=Don't force. 1=Force invalidate_filter_on in L1. Force filter invalidation." />
      <!-- Bits 5:1 reserved. -->
      <field name="REG_force_OrderStreamID_func" bit="0" size="1" desc="Read-write. Reset: 0. 0=Force the Function bit in StreamID/ReqID to '0' for Ordering in L1. 1=Use the full StreamID/ReqID bus. Force StreamID/ReqID for ordering." />
    </register>

    <!-- TODO Multiple BAR instances, keeping only first one: IOMMUL1INT[0...1]x00000024 (IOMMUL1::L1_SB_LOCATION) -->
    <register name="L1_SB_LOCATION" type="indirect" device="IOMMUL1INT0" offset="0x00000024" size="4" desc="IOMMUL1::L1_SB_LOCATION. Read-write. Reset: 0000_0000h.">
      <field name="SBlocated_Core" bit="16" size="16" desc="Read-write. Reset: 0000h. Core location of SB." />
      <field name="SBlocated_Port" bit="0" size="16" desc="Read-write. Reset: 0000h. Port location of SB." />
    </register>

    <!-- page 275 -->

    <!-- TODO Multiple BAR instances, keeping only first one: IOMMUL1INT[0...1]x00000030 (IOMMUL1::L1_CNTRL_0) -->
    <register name="L1_CNTRL_0" type="indirect" device="IOMMUL1INT0" offset="0x00000030" size="4" desc="IOMMUL1::L1_CNTRL_0. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:1 reserved. -->
      <field name="Unfilter_dis" bit="0" size="1" desc="Read-write. Reset: 0. 0=Enable. 1=Disable. Disable unfiltering in the L1 WQ of aborted L2 requests." />
    </register>

    <!-- TODO Multiple BAR instances, keeping only first one: IOMMUL1INT[0...1]x00000038 (IOMMUL1::L1_CNTRL_2) -->
    <register name="L1_CNTRL_2" type="indirect" device="IOMMUL1INT0" offset="0x00000038" size="4" desc="IOMMUL1::L1_CNTRL_2. Read-write. Reset: 1200_0000h.">
      <!-- Bits 31:29 reserved. -->
      <field name="L1ConsumedDataErrorSignalEn" bit="28" size="1" desc="Read-write. Reset: 1. 0=Disable. 1=Enable. Enables asserting Data Error on egress SDP request when parity check fails on IOMMU consumed data." />
      <field name="L1NonConsumedDataErrorSignalEn" bit="27" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enables asserting Data Error on egress SDP request when parity check fails on IOMMU non-consumed data." />
      <field name="CPD_RESP_MODE" bit="24" size="3" desc="Read-write. Reset: 2h. Consumption of poisoned data response mode." />
      <!-- Bits 23:0 reserved. -->
    </register>

    <!-- TODO Multiple BAR instances, keeping only first one: IOMMUL1INT[0...1]x0000009C (IOMMUL1::L1_FEATURE_CNTRL) -->
    <register name="L1_FEATURE_CNTRL" type="indirect" device="IOMMUL1INT0" offset="0x0000009C" size="4" desc="IOMMUL1::L1_FEATURE_CNTRL. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:3 reserved. -->
      <field name="EXE_lock_bit" bit="2" size="1" desc="Read-write. Reset: 0. When programmed to 1 will remain 1 until reset. Sticky lock bits for the EXE permission checks." />
      <field name="PMR_lock_bit" bit="1" size="1" desc="Read-write. Reset: 0. When programmed to 1 will remain 1 until reset. Sticky lock bits for the PMR permission checks." />
      <!-- Bit 0 reserved. -->
    </register>

    <!-- TODO Multiple BAR instances, keeping only first one: IOMMUL1INT[0...1]x000000A8 (IOMMUL1::L1_PGMEM_CTRL_5) -->
    <register name="L1_PGMEM_CTRL_5" type="indirect" device="IOMMUL1INT0" offset="0x000000A8" size="4" desc="IOMMUL1::L1_PGMEM_CTRL_5. Read-write. Reset: 0000_0001h.">
      <field name="L1_LS_Req_Maintain_Cnt" bit="0" size="32" desc="Read-write. Reset: 0000_0001h. LS request maintain time." />
    </register>

    <!-- TODO Multiple BAR instances, keeping only first one: IOMMUL1INT[0...1]x000000AC (IOMMUL1::L1_PGMEM_CTRL_6) -->
    <register name="L1_PGMEM_CTRL_6" type="indirect" device="IOMMUL1INT0" offset="0x000000AC" size="4" desc="IOMMUL1::L1_PGMEM_CTRL_6. Read-write. Reset: 0000_0001h.">
      <field name="L1_LS_Exit_Maintain_Cnt" bit="0" size="32" desc="Read-write. Reset: 0000_0001h. LS request exit maintain time." />
    </register>

    <!-- page 276 -->

    <!-- TODO Multiple BAR instances, keeping only first one: IOMMUL1INT[0...1]x000000B0 (IOMMUL1::L1_PGMEM_CTRL_7) -->
    <register name="L1_PGMEM_CTRL_7" type="indirect" device="IOMMUL1INT0" offset="0x000000B0" size="4" desc="IOMMUL1::L1_PGMEM_CTRL_7. Read-write. Reset: 0000_0001h.">
      <field name="L1_DS_Req_Maintain_Cnt" bit="0" size="32" desc="Read-write. Reset: 0000_0001h. DS request maintain time." />
    </register>

    <!-- TODO Multiple BAR instances, keeping only first one: IOMMUL1INT[0...1]x000000B4 (IOMMUL1::L1_PGMEM_CTRL_8) -->
    <register name="L1_PGMEM_CTRL_8" type="indirect" device="IOMMUL1INT0" offset="0x000000B4" size="4" desc="IOMMUL1::L1_PGMEM_CTRL_8. Read-write. Reset: 0000_0006h.">
      <field name="L1_DS_Exit_Maintain_Cnt" bit="0" size="32" desc="Read-write. Reset: 0000_0006h. DS request exit maintain time." />
    </register>

    <!-- TODO Multiple BAR instances, keeping only first one: IOMMUL1INT[0...1]x000000B8 (IOMMUL1::L1_PGMEM_CTRL_9) -->
    <register name="L1_PGMEM_CTRL_9" type="indirect" device="IOMMUL1INT0" offset="0x000000B8" size="4" desc="IOMMUL1::L1_PGMEM_CTRL_9. Read-write. Reset: 0000_0001h.">
      <field name="L1_SD_Req_Maintain_Cnt" bit="0" size="32" desc="Read-write. Reset: 0000_0001h. SD request maintain time." />
    </register>

    <!-- TODO Multiple BAR instances, keeping only first one: IOMMUL1INT[0...1]x000000BC (IOMMUL1::L1_PGMEM_CTRL_10) -->
    <register name="L1_PGMEM_CTRL_10" type="indirect" device="IOMMUL1INT0" offset="0x000000BC" size="4" desc="IOMMUL1::L1_PGMEM_CTRL_10. Read-write. Reset: 0000_0006h.">
      <field name="L1_SD_Exit_Maintain_Cnt" bit="0" size="32" desc="Read-write. Reset: 0000_0006h. SD request exit maintain time." />
    </register>

    <!-- TODO Multiple BAR instances, keeping only first one: IOMMUL1INT[0...1]x000000C8 (IOMMUL1::L1_CNTRL_4) -->
    <register name="L1_CNTRL_4" type="indirect" device="IOMMUL1INT0" offset="0x000000C8" size="4" desc="IOMMUL1::L1_CNTRL_4. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:3 reserved. -->
      <field name="Timeout_pulse_ext_En" bit="2" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Use external pulse for Invalidation Timeout." />
      <!-- Bit 1 reserved. -->
      <field name="ATS_multiple_resp_en" bit="0" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Allow multiple ATS responses for a large sized ATS request." />
    </register>

    <!-- TODO Multiple BAR instances, keeping only first one: IOMMUL1INT[0...1]x000000CC (IOMMUL1::L1_CLKCNTRL_0) -->
    <register name="L1_CLKCNTRL_0" type="indirect" device="IOMMUL1INT0" offset="0x000000CC" size="4" desc="IOMMUL1::L1_CLKCNTRL_0. Read-write. Reset: 0002_0000h.">
      <field name="L1_L2_CLKGATE_EN" bit="31" size="1" desc="Read-write. Reset: 0. 0=L1 does not wait for L2toL1ClkGrant before sending request. 1=L1 needs to receive L2toL1ClkGrant before sending request. This register must be set if L2 clock gating is enabled." />
      <!-- Bits 30:22 reserved. -->
      <field name="L1_CLKGATE_HYSTERESIS" bit="14" size="8" desc="Read-write. Reset: 08h. IOMMU L1 Clock branch hysteresis used in all the branches. Resets to 16 clycles." />
      <field name="L1_HOSTRSP_CLKGATE_EN" bit="13" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enables clock gating for internal Host Response path blocks." />
      <field name="L1_DMARSP_CLKGATE_EN" bit="12" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enables clock gating for internal DMA Response path blocks." />
      <field name="L1_HOSTREQ_CLKGATE_EN" bit="11" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enables clock gating for internal Host path blocks." />
      <field name="L1_REG_CLKGATE_EN" bit="10" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enables clock gating for internal register blocks." />
      <field name="L1_MEMORY_CLKGATE_EN" bit="9" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enables clock gating for internal memory blocks." />
      <field name="L1_PERF_CLKGATE_EN" bit="8" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enables clock gating for internal Performance blocks." />
      <!-- Bit 7 reserved. -->
      <field name="L1_CPSLV_CLKGATE_EN" bit="6" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enables clock gating for internal  Command Process Slave blocks." />
      <field name="L1_CACHE_CLKGATE_EN" bit="5" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enables clock gating for internal Cache blocks." />
      <field name="L1_DMA_CLKGATE_EN" bit="4" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enables clock gating for internal DMA path blocks." />
      <!-- Bits 3:0 reserved. -->
    </register>

    <!-- page 277 -->

    <!-- TODO Multiple BAR instances, keeping only first one: IOMMUL1INT[0...1]x000000D4 (IOMMUL1::L1_SDP_CLKREQ_CNTRL) -->
    <register name="L1_SDP_CLKREQ_CNTRL" type="indirect" device="IOMMUL1INT0" offset="0x000000D4" size="4" desc="IOMMUL1::L1_SDP_CLKREQ_CNTRL. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:2 reserved. -->
      <field name="HW_PG_WAKEUP_EN_HOST" bit="1" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Connect the ingress OrigClkReq signal on the IOHC SDP interface to the OrigClkReq on the L1_CLIENT interface." />
      <field name="HW_PG_WAKEUP_EN_DMA" bit="0" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Connect the ingress OrigClkReq signal on the client SDP interface to the OrigClkReq on the L1_IOHC interface, and the L1_L2_req_clkreq to the L2." />
    </register>

    <!-- TODO Multiple BAR instances, keeping only first one: IOMMUL1INT[0...1]x000000F0 (IOMMUL1::L1_PGMEM_CTRL_4) -->
    <register name="L1_PGMEM_CTRL_4" type="indirect" device="IOMMUL1INT0" offset="0x000000F0" size="4" desc="IOMMUL1::L1_PGMEM_CTRL_4. Read-write. Reset: 0000_0000h.">
      <field name="L1_SD_thres" bit="0" size="32" desc="Read-write. Reset: 0000_0000h." />
    </register>

    <!-- TODO Multiple BAR instances, keeping only first one: IOMMUL1INT[0...1]x000000F4 (IOMMUL1::IOMMU_PGSLV_CONTROL) -->
    <register name="IOMMU_PGSLV_CONTROL" type="indirect" device="IOMMUL1INT0" offset="0x000000F4" size="4" desc="IOMMUL1::IOMMU_PGSLV_CONTROL. Reset: 0000_000Bh. Register used in L1 ECO.">
      <!-- Bits 31:6 reserved. -->
      <field name="L1_PG_STATUS" bit="5" size="1" desc="Read-only. Reset: 0. 0=Not in isolation. 1=In isolation (power-gated). Software readable register for finding the isolation status of the L1." />
      <field name="CFG_IDLE_HYSTERESIS" bit="0" size="5" desc="Read-write. Reset: 0Bh. Controls the number of consecutive clocks when IP is idle before asserting PGMS_PGSLV_pwrGate_ready. Large enough to account for L2->L1 ClkReq/ClkAck path with repeaters. Cannot be smaller than 0xB." />
    </register>

    <!-- 8.1.2.2 IOMMUL2 Registers -->

    <register name="IOMMU_VENDOR_ID" type="pcicfg" device="IOMMU" offset="0x000" size="2" desc="IOMMUL2::IOMMU_VENDOR_ID. Read-only. Reset: 1022h.">
      <field name="VENDOR_ID" bit="0" size="16" desc="Read-only. Reset: 1022h. Vendor Identifier. This 16-bit field identifies the manufacturer of the device: Advanced Micro Devices Inc." />
    </register>

    <!-- page 278 -->

    <register name="IOMMU_DEVICE_ID" type="pcicfg" device="IOMMU" offset="0x002" size="2" desc="IOMMUL2::IOMMU_DEVICE_ID. Read-only. Reset: 15D1h.">
      <field name="DEVICE_ID" bit="0" size="16" desc="Read-only. Reset: 15D1h. Device Identifier. This 16-bit field is assigned by the device manufacturer and identifies the type of device." />
    </register>
    <register name="IOMMU_COMMAND" type="pcicfg" device="IOMMU" offset="0x004" size="2" desc="IOMMUL2::IOMMU_COMMAND.">
      <!-- Bits 15:11 reserved. -->
      <field name="INTERRUPT_DIS" bit="10" size="1" desc="Read-write. Reset: 0. 0=This function is allowed to generate legacy INTx interrupts. 1=This function is not allowed to generate legacy INTx interrupts. Description: Interrupt Disable. 1=This function is not allowed to generate legacy INTx interrupts. 0=This function is allowed to generate legacy INTx interrupts." />
      <!-- Bit 9 reserved. -->
      <field name="SERR_EN" bit="8" size="1" desc="Read-only. Reset: Fixed,0. 0=Disable. 1=Enable. Description: System Error Enable. This function does not set IOMMUL2::IOMMU_STATUS[SIGNALED_SYSTEM_ERROR]." />
      <!-- Bit 7 reserved. -->
      <field name="PARITY_ERROR_EN" bit="6" size="1" desc="Read-write. Reset: 0. 0=This function is not allowed to set IOMMUL2::IOMMU_STATUS[PARITY_ERROR_DETECTED]. 1=This function is allowed to set IOMMUL2::IOMMU_STATUS[PARITY_ERROR_DETECTED]. Parity Error Enable." />
      <!-- Bits 5:3 reserved. -->
      <field name="BUS_MASTER_EN" bit="2" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. 0=This function is not allowed to generate DMA reqests. 1=This function is allowed to generate DMA requests. Bus Master Enable." />
      <field name="MEM_ACCESS_EN" bit="1" size="1" desc="Read-only. Reset: Fixed,0. 0=Disable. 1=Enable. Description: Memory Access Enable. This register controls no hardware. This function does not declare any standard memory BARs." />
      <field name="IO_ACCESS_EN" bit="0" size="1" desc="Read-only. Reset: Fixed,0. 0=Disable. 1=Enable. Description: I/O Access Enable. This register controls no hardware. This function does not declare any standard I/O BARs." />
    </register>
    <register name="IOMMU_STATUS" type="pcicfg" device="IOMMU" offset="0x006" size="2" desc="IOMMUL2::IOMMU_STATUS.">
      <field name="PARITY_ERROR_DETECTED" bit="15" size="1" desc="Read,Write-1-to-clear. Reset: 0. Description: Parity Error Detected. This bit is set by hardware whenever this function receives a Read response with the data error attribute set." />
      <field name="SIGNALED_SYSTEM_ERROR" bit="14" size="1" desc="Read-only. Reset: Fixed,0. Description: Signaled System Error. This bit is always set to 0 because this function does not generate signaled system error status." />
      <field name="RECEIVED_MASTER_ABORT" bit="13" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Inactive. 1=Active. Description: Received Target Abort. This bit is set by hardware whenever this function receives a Read response with the master abort status." />
      <field name="RECEIVED_TARGET_ABORT" bit="12" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Inactive. 1=Active. Description: Received Target Abort. This bit is set by hardware whenever this function receives a Read response with the target abort status." />
      <field name="SIGNAL_TARGET_ABORT" bit="11" size="1" desc="Read-only. Reset: Fixed,0. 0=No Abort. 1=Target Abort asserted. Description: Signal Target Abort. This bit is always set to 0 because this function does not terminate host requests with target abort." />
      <!-- Bits 10:9 reserved. -->
      <field name="MASTER_DATA_ERROR" bit="8" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Disable. 1=Enable. Description: Master Data Error. This bit is set by hardware whenever IOMMUL2::IOMMU_COMMAND[PARITY_ERROR_EN] is set and this function receives a Read response with the data error attribute set." />
      <!-- Bits 7:5 reserved. -->
      <field name="CAP_LIST" bit="4" size="1" desc="Read-only. Reset: Fixed,1. 0=Disable. 1=Enable. Description: Capabilities List. This bit is set to indicate that this function`s configuration space supports a capabilities list." />
      <field name="INT_Status" bit="3" size="1" desc="Read-only. Reset: 0. 0=This function does not have any outstanding interrupts. 1=This function has an outstanding interrupt. Interrupt Status." />
      <!-- Bits 2:0 reserved. -->
    </register>

    <!-- page 279 -->

    <register name="IOMMU_REVISION_ID" type="pcicfg" device="IOMMU" offset="0x008" size="1" desc="IOMMUL2::IOMMU_REVISION_ID. Read-only. Reset: 00h.">
      <field name="MAJOR_REV_ID" bit="4" size="4" desc="Read-only. Reset: 0h. Identifies the revision number of the function." />
      <field name="MINOR_REV_ID" bit="0" size="4" desc="Read-only. Reset: 0h. Identifies the stepping number of the function." />
    </register>
    <register name="IOMMU_REGPROG_INF" type="pcicfg" device="IOMMU" offset="0x009" size="1" desc="IOMMUL2::IOMMU_REGPROG_INF. Read-only. Reset: Fixed,00h.">
      <field name="REG_LEVEL_PROG_INF" bit="0" size="8" desc="Read-only. Reset: Fixed,00h. Description: Register Programming Interface. IOMMU." />
    </register>
    <register name="IOMMU_SUB_CLASS" type="pcicfg" device="IOMMU" offset="0x00A" size="1" desc="IOMMUL2::IOMMU_SUB_CLASS. Read-only. Reset: Fixed,06h.">
      <field name="SUB_CLASS_INF" bit="0" size="8" desc="Read-only. Reset: Fixed,06h. Description: Sub-Class Code. IOMMU." />
    </register>
    <register name="IOMMU_BASE_CODE" type="pcicfg" device="IOMMU" offset="0x00B" size="1" desc="IOMMUL2::IOMMU_BASE_CODE. Read-only. Reset: Fixed,08h.">
      <field name="BASE_CLASS_CODE" bit="0" size="8" desc="Read-only. Reset: Fixed,08h. Description: Sub-Class Code. System Base Peripheral." />
    </register>

    <!-- page 280 -->

    <register name="IOMMU_HEADER" type="pcicfg" device="IOMMU" offset="0x00E" size="1" desc="IOMMUL2::IOMMU_HEADER. Read-only. Reset: Fixed,80h.">
      <field name="HEADER_TYPE" bit="0" size="8" desc="Read-only. Reset: Fixed,80h.   Description: Header Type. Indicates a multi-function device with a type 0 configuration space header." />
    </register>
    <register name="IOMMU_ADAPTER_ID" type="pcicfg" device="IOMMU" offset="0x02C" size="4" desc="IOMMUL2::IOMMU_ADAPTER_ID. Read-only. Reset: 1451_1022h.">
      <field name="SUBSYSTEM_ID" bit="16" size="16" desc="Read-only. Reset: 1451h. Subsystem ID." />
      <field name="SUBSYSTEM_VENDOR_ID" bit="0" size="16" desc="Read-only. Reset: 1022h. Subsystem vendor ID." />
    </register>
    <register name="IOMMU_CAPABILITIES_PTR" type="pcicfg" device="IOMMU" offset="0x034" size="4" desc="IOMMUL2::IOMMU_CAPABILITIES_PTR. Read-only. Reset: Fixed,0000_0040h.">
      <!-- Bits 31:8 reserved. -->
      <field name="CAP_PTR" bit="0" size="8" desc="Read-only. Reset: Fixed,40h. Description: Capabilities Pointer. Points to the start of the capabilities list." />
    </register>
    <register name="IOMMU_INTERRUPT_LINE" type="pcicfg" device="IOMMU" offset="0x03C" size="1" desc="IOMMUL2::IOMMU_INTERRUPT_LINE. Read-write. Reset: 00h.">
      <field name="INTERRUPT_LINE" bit="0" size="8" desc="Read-write. Reset: 00h. Init: BIOS,FFh. This register is Read/Write for software compatibility. It controls no hardware." />
    </register>
    <register name="IOMMU_INTERRUPT_PIN" type="pcicfg" device="IOMMU" offset="0x03D" size="1" desc="IOMMUL2::IOMMU_INTERRUPT_PIN. Read-only. Reset: 01h.">
      <field name="INTERRUPT_PIN" bit="0" size="8" desc="Read-only. Reset: 01h. This field indicates the INTx line used to generate legacy interrupts. All other encodings are not supported." />
    </register>
    <register name="IOMMU_CAP_HEADER" type="pcicfg" device="IOMMU" offset="0x040" size="4" desc="IOMMUL2::IOMMU_CAP_HEADER. Read-only.">
      <!-- Bits 31:29 reserved. -->
      <field name="IOMMU_CAP_EXT" bit="28" size="1" desc="Read-only. Reset: 1. 0=IOMMU Miscellaneous Information Register 1 [Capability Offset   14h] not supported. 1=Indicates support for IOMMU Miscellaneous Information Register 1 [Capability Offset 14h]. IOMMU Miscellaneous Information Register 1 support (IOMMUMMIO::IOMMU_MMIO_EVENT_BASE_1)." />
      <field name="IOMMU_EFR_SUP" bit="27" size="1" desc="Read-only. Reset: 1. 0=Extended Feature Register [MMIO Offset 0030h] is Reserved. 1=Indicates IOMMU Extended Feature Register [MMIO Offset 0030h] is supported. Extended Feature Register support (IOMMUMMIO::IOMMU_MMIO_EFR_0)." />
      <field name="IOMMU_NP_CACHE" bit="26" size="1" desc="Read-only. Reset: Fixed,0. 0=Indicates the IOMMU cache's only page table entries that are marked as present. When IOMMU_NP_CACHE is clear, software must issue an invalidate after any change to a PDE or PTE marked present before the change. 1=Indicates the IOMMU cache's page table entries that are marked as not present. When this bit is set, software must issue an invalidate after any change to a PDE or PTE. Indication of the IOMMU caches page table entries." />
      <field name="IOMMU_HT_TUNNEL_SUP" bit="25" size="1" desc="Read-only. Reset: Fixed,0. Hypertransport tunnel translation support. This register is always set to 0 to indicate that the device does not contain a hypertransport tunnel supporting address translation." />
      <field name="IOMMU_IO_TLBSUP" bit="24" size="1" desc="Read-only. Reset: 1. Indicates support for remote IOTLBs." />
      <field name="IOMMU_CAP_REV" bit="19" size="5" desc="Read-only. Reset: Fixed,01h. Specifies the IOMMU specification revision." />
      <field name="IOMMU_CAP_TYPE" bit="16" size="3" desc="Read-only. Reset: Fixed,3h. Specifies the layout of the Capability Block as an IOMMU capability block." />
      <field name="IOMMU_CAP_PTR" bit="8" size="8" desc="Read-only. Reset: Fixed,64h. Indicates the location of the next capability block if one is present." />
      <field name="IOMMU_CAP_ID" bit="0" size="8" desc="Read-only. Reset: Fixed,0Fh. Indicates a Secure Device capability block." />
    </register>

    <!-- page 281 -->

    <register name="IOMMU_CAP_BASE_LO" type="pcicfg" device="IOMMU" offset="0x044" size="4" desc="IOMMUL2::IOMMU_CAP_BASE_LO. Read-write. Reset: 0000_0000h.">
      <field name="IOMMU_BASE_ADDR_LO" bit="19" size="13" desc="Read-write. Reset: 0000h. Specifies address bits[31:19] of the 512KB-aligned base address of the IOMMU memory-mapped control registers." />
      <!-- Bits 18:1 reserved. -->
      <field name="IOMMU_ENABLE" bit="0" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. IOMMU accepts memory accesses to the address specified in the Base Address Register. Upon writting IOMMU_ENABLE = 1, all IOMMU Read/Write capability registers in PCI configuration space are locked until the next system reset." />
    </register>
    <register name="IOMMU_CAP_BASE_HI" type="pcicfg" device="IOMMU" offset="0x048" size="4" desc="IOMMUL2::IOMMU_CAP_BASE_HI. Read-write. Reset: 0000_0000h.">
      <field name="IOMMU_BASE_ADDR_HI" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Specifies address bits[63:32] of the 512KB- aligned base address of the IOMMU memory-mapped control registers." />
    </register>
    <register name="IOMMU_CAP_RANGE" type="pcicfg" device="IOMMU" offset="0x04C" size="4" desc="IOMMUL2::IOMMU_CAP_RANGE. Read-only.">
      <field name="IOMMU_LAST_DEVICE" bit="24" size="8" desc="Read-only. Reset: 00h. Indicates device and function number of the last integrated device associated with the IOMMU." />
      <field name="IOMMU_FIRST_DEVICE" bit="16" size="8" desc="Read-only. Reset: 00h. Indicates device and function number of the first integrated device associated with the IOMMU." />
      <field name="IOMMU_BUS_NUMBER" bit="8" size="8" desc="Read-only. Reset: 00h. Indicates the bus number that the IOMMU_FIRST_DEVICE and IOMMU_LAST_DEVICE reside on." />
      <field name="IOMMU_RNG_VALID" bit="7" size="1" desc="Read-only. Reset: 0. 0=Software must use the I/O topology information. 1=The IOMMU_BUS_NUMBER, IOMMU_FIRST_DEVICE and IOMMU_LAST_DEVICE fields are valid. Although the register contents are valid, software is encouraged to use the I/O topology information. IOMMU_BUS_NUMBER, IOMMU_FIRST_DEVICE and IOMMU_LAST_DEVICE validity status." />
      <!-- Bits 6:5 reserved. -->
      <field name="IOMMU_UNIT_ID" bit="0" size="5" desc="Read-only. Reset: Fixed,00h. This field returns the HyperTransport™ UnitID used by the IOMMU." />
    </register>

    <!-- page 282 -->

    <register name="IOMMU_CAP_MISC" type="pcicfg" device="IOMMU" offset="0x050" size="4" desc="IOMMUL2::IOMMU_CAP_MISC.">
      <field name="IOMMU_MSI_NUM_PPR" bit="27" size="5" desc="Read-only. Reset: 00h. This field must indicate which MSI vector is used for the interrupt message generated by the IOMMU for the peripheral page service request log when IOMMUMMIO::IOMMU_MMIO_EFR_0[PPR_SUP] == 1. IOMMU_MSI_NUM_PPR must be 0 when PPR_SUP == 0. For MSI, there can be only one IOMMU so this field must be 0. This interrupt is not remapped by the IOMMU." />
      <!-- Bits 26:23 reserved. -->
      <field name="IOMMU_HT_ATS_RESV" bit="22" size="1" desc="Read-write. Reset: 0. 0=The Address Translation address range can be translated by the IOMMU. 1=The HyperTransport Address Translation address range for ATS responses are Reserved and cannot be translated by the IOMMU. HyperTransport Address Translation address range for ATS responses." />
      <field name="IOMMU_VA_SIZE" bit="15" size="7" desc="Read-only. Reset: Fixed,40h. This field must indicate the size of the maximum virtual address processed by the IOMMU. The value is the (unsigned) binary log of the maximum address size. Allowed values are 32, 40, 48, and 64 bits. All other values are Reserved." />
      <field name="IOMMU_PA_SIZE" bit="8" size="7" desc="Read-only. Reset: 30h. This field must indicate the size of the maximum physical address generated by the IOMMU. The value is the (unsigned) binary log of the maximum address size. Allowed values are 40, 48 and 52 bits. All other values are Reserved." />
      <field name="IOMMU_GVA_SIZE" bit="5" size="3" desc="Read-only. Reset: Fixed,2h. This field indicates the width of the maximum guest virtual address processed by IOMMU. " />
      <field name="IOMMU_MSI_NUM" bit="0" size="5" desc="Read-only. Reset: 00h. Indicates the MSI vector used for interrupt messages generated by the IOMMU." />
    </register>

    <!-- page 283 -->

    <register name="IOMMU_CAP_MISC_1" type="pcicfg" device="IOMMU" offset="0x054" size="4" desc="IOMMUL2::IOMMU_CAP_MISC_1. Reset: 0000_0000h.">
      <!-- Bits 31:6 reserved. -->
      <field name="IOMMU_ARCH_MODE" bit="5" size="1" desc="Read-write. Reset: 0. 0=x86 mode. 1=ARM v1 mode. Indicates the working architecture mode of the IOMMU." />
      <field name="IOMMU_MSI_NUM_GA" bit="0" size="5" desc="Read-only. Reset: 00h. MSI message number. Message number for MSI or MSI-X interrupt associated with the guest vAPIC virtual interrupt request log." />
    </register>
    <register name="IOMMU_MSI_CAP" type="pcicfg" device="IOMMU" offset="0x064" size="4" desc="IOMMUL2::IOMMU_MSI_CAP.">
      <!-- Bits 31:24 reserved. -->
      <field name="MSI_64_EN" bit="23" size="1" desc="Read-only. Reset: Fixed,1. 0=64-bit MSI address not supported. 1=64-bit MSI address supported. Set to indicate that a 64-bit MSI address is supported." />
      <field name="MSI_MULT_MESS_EN" bit="20" size="3" desc="Read-write. Reset: 0h. Sets the number of MSI messages assigned to this function." />
      <field name="MSI_MULT_MESS_CAP" bit="17" size="3" desc="Read-only. Reset: 2h. Indicates the number of MSI messages requested by this function." />
      <field name="MSI_EN" bit="16" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enables MSI for this function and causes legacy interrupts to be disabled." />
      <field name="MSI_CAP_PTR" bit="8" size="8" desc="Read-only. Reset: Fixed,74h. Pointer to the next configuration space capability." />
      <field name="MSI_CAP_ID" bit="0" size="8" desc="Read-only. Reset: Fixed,05h. Indicates the MSI capability." />
    </register>
    <register name="IOMMU_MSI_ADDR_LO" type="pcicfg" device="IOMMU" offset="0x068" size="4" desc="IOMMUL2::IOMMU_MSI_ADDR_LO. Read-write. Reset: 0000_0000h.">
      <field name="MSI_ADDR_LO" bit="2" size="30" desc="Read-write. Reset: 0000_0000h. Sets address bits[31:2] used to issue MSI messages." />
      <!-- Bits 1:0 reserved. -->
    </register>
    <register name="IOMMU_MSI_ADDR_HI" type="pcicfg" device="IOMMU" offset="0x06C" size="4" desc="IOMMUL2::IOMMU_MSI_ADDR_HI. Read-write. Reset: 0000_0000h.">
      <field name="MSI_ADDR_HI" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Sets address bits[63:32] used to issue MSI messages." />
    </register>

    <!-- page 284 -->

    <register name="IOMMU_MSI_DATA" type="pcicfg" device="IOMMU" offset="0x070" size="4" desc="IOMMUL2::IOMMU_MSI_DATA. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="MSI_DATA" bit="0" size="16" desc="Read-write. Reset: 0000h. Sets the data issued with MSI messages." />
    </register>
    <register name="IOMMU_MSI_MAPPING_CAP" type="pcicfg" device="IOMMU" offset="0x074" size="4" desc="IOMMUL2::IOMMU_MSI_MAPPING_CAP. Read-only. Reset: Fixed,A803_0008h.">
      <field name="MSI_MAP_CAP_TYPE" bit="27" size="5" desc="Read-only. Reset: Fixed,15h. Indicates the MSI Mapping Capability." />
      <!-- Bits 26:18 reserved. -->
      <field name="MSI_MAP_FIXD" bit="17" size="1" desc="Read-only. Reset: Fixed,1. 0=MSI mapping range is programmable. 1=MSI mapping range is not programmable. Always set to 1 to indicate that this device only maps MSI interrupts with address 0xFEEX_XXXX onto Hypertransport interrupts and that the mapping range is not programmable." />
      <field name="MSI_MAP_EN" bit="16" size="1" desc="Read-only. Reset: Fixed,1. 0=MSI Mapping Capability disabled. 1=MSI Mapping Capability enabled. Always set to 1 to indicate that the MSI Mapping Capability is always enabled." />
      <field name="MSI_MAP_CAP_PTR" bit="8" size="8" desc="Read-only. Reset: Fixed,00h. Points to the next capability list item." />
      <field name="MSI_MAP_CAP_ID" bit="0" size="8" desc="Read-only. Reset: Fixed,08h. Indicates a Hypertransport capability list item." />
    </register>
    <register name="IOMMU_MMIO_CONTROL1_W" type="pcicfg" device="IOMMU" offset="0x084" size="4" desc="IOMMUL2::IOMMU_MMIO_CONTROL1_W. Read-write. Reset: 0000_0800h. See also IOMMUMMIO::IOMMU_MMIO_EFR_1.">
      <!-- Bits 31:21 reserved. -->
      <field name="HD_SUP_W" bit="20" size="1" desc="Read-write. Reset: 0. 0=Hardware does not support Dirty bit updates for v1 Page tables. 1=Hardware supports Dirty bit update for v1 Page tables. Hardware Dirty bit update support." />
      <!-- Bits 19:13 reserved. -->
      <field name="MARCnum_SUP_W" bit="11" size="2" desc="Read-write. Reset: 1h. Writes number of MARC apoertures and thus the nubmer of MARC register 3-tuples supported." />
      <!-- Bits 10:0 reserved. -->
    </register>
    <register name="L2A_UPDATE_FILTER_CNTL" type="indirect" device="IOMMUL2A" offset="0x00000088" size="4" desc="IOMMUL2::L2A_UPDATE_FILTER_CNTL. Read-write. Reset: 0000_0001h.">
      <!-- Bits 31:1 reserved. -->
      <field name="L2a_Update_Filter_Bypass" bit="0" size="1" desc="Read-write. Reset: 1. 0=Enable the dropping of updates that are already in the l2a_update_filter or in the destination L2a cache. 1=Disable duplicate update filtering. Dropping of updates that are already in the l2a_update_filter or in the destination L2a cache." />
    </register>

    <!-- page 285 -->

    <register name="L2_L2A_DTRACE_TRIGGER_1" type="indirect" device="IOMMUL2A" offset="0x00000094" size="4" desc="IOMMUL2::L2_L2A_DTRACE_TRIGGER_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:20 reserved. -->
      <field name="DTraceVAPageUpper" bit="0" size="20" desc="Read-write. Reset: 0_0000h. VA bits[63:44] for L2a debug bus transaction trigger." />
    </register>
    <register name="L2_L2A_DTRACE_TRIGGER_2" type="indirect" device="IOMMUL2A" offset="0x00000098" size="4" desc="IOMMUL2::L2_L2A_DTRACE_TRIGGER_2. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:25 reserved. -->
      <field name="DTraceClient" bit="21" size="4" desc="Read-write. Reset: 0h. Client ID for L2a debug bus transaction trigger." />
      <field name="DTraceZeroByteRead" bit="20" size="1" desc="Read-write. Reset: 0. Zero-byte Read for L2a debug bus transaction trigger." />
      <field name="DTraceAT" bit="18" size="2" desc="Read-write. Reset: 0h. AT for L2a debug bus transaction trigger." />
      <field name="DTraceInterrupt" bit="17" size="1" desc="Read-write. Reset: 0. Interrupt for L2a debug bus transaction trigger." />
      <field name="DTraceWr" bit="16" size="1" desc="Read-write. Reset: 0. Write for L2a debug bus transaction trigger." />
      <field name="DTraceReqID" bit="0" size="16" desc="Read-write. Reset: 0000h. Reqest ID for L2a debug bus transaction trigger." />
    </register>
    <register name="L2_L2A_DTRACE_MASK_0" type="indirect" device="IOMMUL2A" offset="0x0000009C" size="4" desc="IOMMUL2::L2_L2A_DTRACE_MASK_0. Read-write. Reset: 0000_0000h.">
      <field name="DTraceVAPageLowerMask" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. VA mask bits[43:12] for L2a debug bus transaction trigger." />
    </register>
    <register name="L2_L2A_DTRACE_MASK_1" type="indirect" device="IOMMUL2A" offset="0x000000A0" size="4" desc="IOMMUL2::L2_L2A_DTRACE_MASK_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:20 reserved. -->
      <field name="DTraceVAPageUpperMask" bit="0" size="20" desc="Read-write. Reset: 0_0000h. VA mask bits[63:44] for L2a debug bus transaction trigger." />
    </register>
    <register name="L2_L2A_DTRACE_MASK_2" type="indirect" device="IOMMUL2A" offset="0x000000A4" size="4" desc="IOMMUL2::L2_L2A_DTRACE_MASK_2. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:25 reserved. -->
      <field name="DTraceClientMask" bit="21" size="4" desc="Read-write. Reset: 0h. Client ID mask for L2a debug bus transaction trigger." />
      <field name="DTraceZeroByteReadMask" bit="20" size="1" desc="Read-write. Reset: 0. Zero-byte Read mask for L2a debug bus transaction trigger." />
      <field name="DTraceATMask" bit="18" size="2" desc="Read-write. Reset: 0h. AT mask for L2a debug bus transaction trigger." />
      <field name="DTraceInterruptMask" bit="17" size="1" desc="Read-write. Reset: 0. Interrupt mask for L2a debug bus transaction trigger." />
      <field name="DTraceWrMask" bit="16" size="1" desc="Read-write. Reset: 0. Write mask for L2a debug bus transaction trigger." />
      <field name="DTraceReqIDMask" bit="0" size="16" desc="Read-write. Reset: 0000h. Request ID mask for L2a debug bus transaction trigger." />
    </register>
    <register name="L2_ERR_RULE_CONTROL_3" type="indirect" device="IOMMUL2A" offset="0x000000C0" size="4" desc="IOMMUL2::L2_ERR_RULE_CONTROL_3. Write-once. Reset: 0000_0000h.">
      <!-- Bits 31:1 reserved. -->
      <field name="ERRRuleLock1" bit="0" size="1" desc="Write-once. Reset: 0. 0=No effect. 1=Lock error detection rule. Setting this field bit locks the error detection rule." />
    </register>

    <!-- page 286 -->

    <register name="L2_L2A_CK_GATE_CONTROL" type="indirect" device="IOMMUL2A" offset="0x000000CC" size="4" desc="IOMMUL2::L2_L2A_CK_GATE_CONTROL. Read-write. Reset: 0000_0057h.">
      <!-- Bits 31:8 reserved. -->
      <field name="CKGateL2AStop" bit="6" size="2" desc="Read-write. Reset: 1h. Clock cycles to delay before stopping the clocks when clkready de- asserts." />
      <field name="CKGateL2ALength" bit="4" size="2" desc="Read-write. Reset: 1h. Clock cycles to delay before stopping the clocks when idle asserts." />
      <!-- Bit 3 reserved. -->
      <field name="CKGateL2ACacheDisable" bit="2" size="1" desc="Read-write. Reset: 1. Disable the gating of the L2b upper cache ways." />
      <field name="CKGateL2ADynamicDisable" bit="1" size="1" desc="Read-write. Reset: 1. Disable the gating of the L2b dynamic clock branch." />
      <field name="CKGateL2ARegsDisable" bit="0" size="1" desc="Read-write. Reset: 1. Disable the gating of the L2b register clock branch." />
    </register>
    <register name="L2_L2A_PGSIZE_CONTROL" type="indirect" device="IOMMUL2A" offset="0x000000D0" size="4" desc="IOMMUL2::L2_L2A_PGSIZE_CONTROL. Read-write. Reset: 0000_0101h.">
      <!-- Bits 31:15 reserved. -->
      <field name="L2AREG_HOST_PGSIZE" bit="8" size="7" desc="Read-write. Reset: 01h. Controls the TLB search for different (final and partial) host page sizes." />
      <!-- Bit 7 reserved. -->
      <field name="L2AREG_GST_PGSIZE" bit="0" size="7" desc="Read-write. Reset: 01h. Controls the TLB search for different (final and partial) guest page sizes." />
    </register>

    <!-- page 287 -->

    <register name="L2_SB_LOCATION" type="indirect" device="IOMMUL2B" offset="0x0000012C" size="4" desc="IOMMUL2::L2_SB_LOCATION. Read-write. Reset: 0000_0000h. Specifies which PCIe® bridge is connected to the South Bridge (SB). Register set to 32'b0 indicates the GNB is secondary and has no SB connected.">
      <field name="SBlocated_Core" bit="16" size="16" desc="Read-write. Reset: 0000h." />
      <field name="SBlocated_Port" bit="0" size="16" desc="Read-write. Reset: 0000h. One hot encoding." />
    </register>
    <register name="L2_CONTROL_5" type="indirect" device="IOMMUL2B" offset="0x00000130" size="4" desc="IOMMUL2::L2_CONTROL_5. Read-write. Reset: 0000_1000h.">
      <!-- Bits 31:19 reserved. -->
      <field name="GST_partial_ptc_cntrl" bit="12" size="7" desc="Read-write. Reset: 01h. Prevent specified page sizes from stored in PTC cache." />
      <field name="ForceTWonVC7" bit="11" size="1" desc="Read-write. Reset: 0. 0=Don't force. 1=Force. Force table-walk fetches to use VC7 for all VC[1:0] and VC7 DMA requests." />
      <!-- Bits 10:0 reserved. -->
    </register>
    <register name="L2B_UPDATE_FILTER_CNTL" type="indirect" device="IOMMUL2B" offset="0x0000014C" size="4" desc="IOMMUL2::L2B_UPDATE_FILTER_CNTL. Read-write. Reset: 0000_0001h.">
      <!-- Bits 31:1 reserved. -->
      <field name="L2b_Update_Filter_Bypass" bit="0" size="1" desc="Read-write. Reset: 1. 1=Enable the dropping of updates that are already in the l2b_update_filter or in the PDC. L2 Update Filter bypass to enable the dropping of updates." />
    </register>
    <register name="L2_TW_CONTROL" type="indirect" device="IOMMUL2B" offset="0x00000150" size="4" desc="IOMMUL2::L2_TW_CONTROL. Read-write. Reset: 0040_1000h.">
      <!-- Bits 31:25 reserved. -->
      <field name="TWGuestPrefetchRange" bit="22" size="3" desc="Read-write. Reset: 1h. Selects the number of pages to prefetch for Guest PTEs. A   value of 0 is Reserved. Programming this register to 0 results in unpredictable hardware behavior." />
      <field name="TWGuestPrefetchEn" bit="21" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enable Guest prefetching in the table-walker." />
      <!-- Bits 20:15 reserved. -->
      <field name="TWPrefetchRange" bit="12" size="3" desc="Read-write. Reset: 1h. Selects the number of pages to prefetch." />
      <!-- Bits 11:9 reserved. -->
      <field name="TWPrefetchEn" bit="8" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enable prefetching in the table-walker." />
      <!-- Bits 7:0 reserved. -->
    </register>

    <!-- page 288 -->

    <register name="L2_CP_CONTROL" type="indirect" device="IOMMUL2B" offset="0x00000158" size="4" desc="IOMMUL2::L2_CP_CONTROL. Read-write. Reset: 0000_0004h.">
      <!-- Bits 31:3 reserved. -->
      <field name="CPFlushOnInv" bit="2" size="1" desc="Read-write. Reset: 1. 0=No flush is performed during Invalidations. 1=Command Processor flushes out old requests on every Invalidation command. Command Processor flush on Invalidation command." />
      <field name="CPFlushOnWait" bit="1" size="1" desc="Read-write. Reset: 0. 0=No flush is performed on Completion Wait. 1=Command Processor flushes out old requests on Completion Wait. Command Processor flush on Completion Wait." />
      <!-- Bit 0 reserved. -->
    </register>
    <register name="L2_CP_CONTROL_1" type="indirect" device="IOMMUL2B" offset="0x0000015C" size="4" desc="IOMMUL2::L2_CP_CONTROL_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="CPL1Off" bit="0" size="16" desc="Read-write. Reset: 0000h. Each bit in this field indicates to the IOMMU Command Processor that a corresponding L1 TLB is inaccessible due to static clock or power gating. System software is responsible for programming this field." />
    </register>
    <register name="L2_ERR_RULE_CONTROL_0" type="indirect" device="IOMMUL2B" offset="0x00000200" size="4" desc="IOMMUL2::L2_ERR_RULE_CONTROL_0. Read,Write-once. Reset: 0000_0000h.">
      <!-- Bits 31:1 reserved. -->
      <field name="ERRRuleLock0" bit="0" size="1" desc="Read,Write-once. Reset: 0. This register is Write-once." />
    </register>
    <register name="L2_L2B_CK_GATE_CONTROL" type="indirect" device="IOMMUL2B" offset="0x00000240" size="4" desc="IOMMUL2::L2_L2B_CK_GATE_CONTROL. Read-write. Reset: 0000_0057h.">
      <!-- Bits 31:8 reserved. -->
      <field name="CKGateL2BStop" bit="6" size="2" desc="Read-write. Reset: 1h. Clock cycles of delay before stopping the clocks when CLKREADY de-asserts." />
      <field name="CKGateL2BLength" bit="4" size="2" desc="Read-write. Reset: 1h. Clock cycles of delay before stopping the clocks when IDLE asserts." />
      <field name="CKGateL2BCacheDisable" bit="3" size="1" desc="Read-write. Reset: 0. 0=Enabled. 1=Disabled. Disable the gating of the L2b upper cache ways." />
      <field name="CKGateL2BMiscDisable" bit="2" size="1" desc="Read-write. Reset: 1. 0=Enabled. 1=Disabled. Disable the gating of the L2b miscelaneous clock branch." />
      <field name="CKGateL2BDynamicDisable" bit="1" size="1" desc="Read-write. Reset: 1. 0=Enabled. 1=Disabled. Disable the gating of the L2b dynamic clock branch." />
      <field name="CKGateL2BRegsDisable" bit="0" size="1" desc="Read-write. Reset: 1. 0=Enabled. 1=Disabled. Disable the gating of the L2b register clock branch." />
    </register>

    <!-- page 289 -->

    <register name="L2_L2B_PGSIZE_CONTROL" type="indirect" device="IOMMUL2B" offset="0x00000250" size="4" desc="IOMMUL2::L2_L2B_PGSIZE_CONTROL. Read-write. Reset: 0000_0101h.">
      <!-- Bits 31:15 reserved. -->
      <field name="L2BREG_HOST_PGSIZE" bit="8" size="7" desc="Read-write. Reset: 01h. Controls the allowed final host page sizes stored in PTC cache. The table shows the valid programming bit values for this register. All other bits are Reserved." />
      <!-- Bit 7 reserved. -->
      <field name="L2BREG_GST_PGSIZE" bit="0" size="7" desc="Read-write. Reset: 01h. Controls the allowed final guest page sizes stored in PTC cache. The table shows the valid programming bit values for this register. If a given final page size is disabled, the next enabled lowest page size will be cached." />
    </register>

    <!-- 8.1.2.3 IOMMUMMIO Registers -->

    <!-- page 290 -->

    <register name="IOMMU_MMIO_DEVTBL_BASE_0" type="mmio" bar="IOMMUBAR" offset="0x00000" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVTBL_BASE_0. Read-write. Reset: 0000_0000h.">
      <field name="DEV_TBL_BASE_LO" bit="12" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[31:12] of the 4K byte-aligned base address of the first level device table." />
      <!-- Bits 11:9 reserved. -->
      <field name="DEV_TBL_SIZE" bit="0" size="9" desc="Read-write. Reset: 000h. This field contains 1 less than the length of the device table, in multiples of 4K bytes. A minimum size of 0 corresponds to a 4K-byte device table and a maximum size of 1FFh corresponds to a 2M-byte device table." />
    </register>
    <register name="IOMMU_MMIO_DEVTBL_BASE_1" type="mmio" bar="IOMMUBAR" offset="0x00004" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVTBL_BASE_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:20 reserved. -->
      <field name="DEV_TBL_BASE_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[51:32] of the 4K byte-aligned base address of the first level device table." />
    </register>
    <register name="IOMMU_MMIO_CMD_BASE_0" type="mmio" bar="IOMMUBAR" offset="0x00008" size="4" desc="IOMMUMMIO::IOMMU_MMIO_CMD_BASE_0. Read-write. Reset: 0000_0000h.">
      <field name="COM_BASE_LO" bit="12" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[31:12] of the base address of the command buffer. The base address programmed must be aligned to 4K bytes." />
      <!-- Bits 11:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_CMD_BASE_1" type="mmio" bar="IOMMUBAR" offset="0x0000C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_CMD_BASE_1. Read-write. Reset: 0800_0000h.">
      <!-- Bits 31:28 reserved. -->
      <field name="COM_LEN" bit="24" size="4" desc="Read-write. Reset: 8h. Specifies the length of the command buffer in power of 2 increments. The minimum size is 256 entries (4K bytes); values less than 1000b are reserved." />
      <!-- Bits 23:20 reserved. -->
      <field name="COM_BASE_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[51:32] of the base address of the command buffer. The base address programmed must be aligned to 4K bytes." />
    </register>

    <!-- page 291 -->

    <register name="IOMMU_MMIO_EVENT_BASE_0" type="mmio" bar="IOMMUBAR" offset="0x00010" size="4" desc="IOMMUMMIO::IOMMU_MMIO_EVENT_BASE_0. Read-write. Reset: 0000_0000h.">
      <field name="EVENT_BASE_LO" bit="12" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[31:12] of the base address of the event log. The base address programmed must be aligned to 4K bytes." />
      <!-- Bits 11:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_EVENT_BASE_1" type="mmio" bar="IOMMUBAR" offset="0x00014" size="4" desc="IOMMUMMIO::IOMMU_MMIO_EVENT_BASE_1. Read-write. Reset: 0800_0000h.">
      <!-- Bits 31:28 reserved. -->
      <field name="EVENT_LEN" bit="24" size="4" desc="Read-write. Reset: 8h. Specifies the length of the event log in power of 2 increments. The minimum size is 256 entries (4K bytes); values less than 1000b are reserved." />
      <!-- Bits 23:20 reserved. -->
      <field name="EVENT_BASE_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[51:32] of the base address of the event log. The base address programmed must be aligned to 4K bytes." />
    </register>
    <register name="IOMMU_MMIO_CNTRL_0" type="mmio" bar="IOMMUBAR" offset="0x00018" size="4" desc="IOMMUMMIO::IOMMU_MMIO_CNTRL_0. Reset: 0000_0400h.">
      <field name="PPRQ" bit="30" size="2" desc="Read-write. Reset: 0h. PPR (event) queue." />
      <field name="GA_INT_EN" bit="29" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=An interrupt is not signalled when IOMMUMMIO::IOMMU_MMIO_STATUS_0[GA_INT] changes from 0 to 1.. 1=An interrupt is signaled when IOMMUMMIO::IOMMU_MMIO_STATUS_0[GA_INT] changes from 0 to 1 using IOMMUL2::IOMMU_CAP_MISC_1[IOMMU_MSI_NUM_GA]. Guest virtual APIC interrup enable. Writes to this bit are ignored when IOMMUMMIO::IOMMU_MMIO_EFR_0[GA_SUP] == 0." />
      <field name="GA_LOG_EN" bit="28" size="1" desc="Read-write. Reset: 0. 0=Disable guest vAPIC virtual interrup request logging. 1=Enable GA Logging. Guest virtual APIC GA Log Enabled. Writes to this but are ignored when IOMMUMMIO::IOMMU_MMIO_EFR_0{GASup] == 0." />
      <field name="GAM_EN" bit="25" size="3" desc="Read-write. Reset: 0h. This field specifies advanced interrupt behaviors and the size of the IRTE. When set to 1, Virtual interrupt behavior as defined by the AVIC specification." />
      <field name="SMIF_LOG_EN" bit="24" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. If SMI filtering is enabled, send EVENT_LOG when SMI is dropped." />
      <!-- Bit 23 reserved. -->
      <field name="SMIF_EN" bit="22" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enable SMI filtering. Drop SMI from ReqID not found in the SMI filter registers." />
      <field name="TLPT" bit="18" size="4" desc="Read-write. Reset: 0h. TLPT[3:0] contains the 4-bit value matched to the PCIe® TLP Type field when the PCIe® TLP format value indicates the field carries a prefix." />
      <field name="GA_EN" bit="17" size="1" desc="Read-write. Reset: 0. 0=Prohibited. 1=Loose. Guest APIC enable." />
      <field name="GT_EN" bit="16" size="1" desc="Read-write. Reset: 0. 0=Guest translation disabled. 1=Guest translation may be enabled for a peripheral by programming DTE[GV]. NOTE: This bit must be programmed to zero when IOMMUMMIO::IOMMU_MMIO_EFR_0[GT_SUP] == 0." />
      <field name="PPR_EN" bit="15" size="1" desc="Read-write. Reset: 0. 0=Peripheral page service requests are treated as invalid device requests. 1=Peripheral page service requests are processed. NOTE: This bit must be programmed to zero when IOMMUMMIO::IOMMU_MMIO_EFR_0[PPR_SUP] == 0." />
      <field name="PPR_INT_EN" bit="14" size="1" desc="Read-write. Reset: 0. 0=An interrupt is not signaled when IOMMUMMIO::IOMMU_MMIO_STATUS_0[PPR_INT] == 1. 1=An interrupt is signaled when IOMMUMMIO::IOMMU_MMIO_STATUS_0[PPR_INT] == 1. NOTE: This bit must be programmed to zero when IOMMUMMIO::IOMMU_MMIO_EFR_0[PPR_SUP] == 0. The interrupt vector used is indicated in Capability Offset (See IOMMUMMIO::IOMMU_MMIO_EVENT_BASE_0), IOMMUL2::IOMMU_CAP_MISC[IOMMU_MSI_NUM_PPR]." />
      <field name="PPR_LOG_EN" bit="13" size="1" desc="Read-write. Reset: 0. 0=Peripheral page service request logging is not enabled. Peripheral page service requests are discarded when the peripheral page service request log is not enabled or when IOMMUMMIO::IOMMU_MMIO_EFR_0[PPR_SUP] == 0. When IommuEn == 1 and software Writes PPR_LOG_EN with 1, the IOMMU clears the PPR_LOG_OVERFLOW bit and sets the PPR_RUN bit in the IOMMU Status register IOMMUMMIO::IOMMU_MMIO_STATUS_0. The IOMMU can now Write new entries to the event log if there are usable entries available. 1=The PPR Log Base Address Register IOMMUMMIO::IOMMU_MMIO_PPR_BASE_0 has been configured and peripheral page service request events are Written to the peripheral page service request log when IommuEn has also been set. Writing a 1 to this bit when PPR_LOG_EN == 1 has no effect. Description: NOTE: Software can Read IOMMUMMIO::IOMMU_MMIO_STATUS_0[PPR_RUN] to determine the status of the peripheral page service request log Writing by the IOMMU. NOTE2: The peripheral page service request and event logs are independent. SOFTWARE NOTE: The PPR Log Base Address register IOMMUMMIO::IOMMU_MMIO_PPR_BASE_0, the IOMMU PPR Log Head Pointer Register IOMMUMMIO::IOMMU_MMIO_PPR_BUF_HDPTR_0, and the IOMMU PPR Log Tail Pointer Register IOMMUMMIO::IOMMU_MMIO_PPR_BUF_TAILPTR_0 must be set prior to enabling the event log." />
      <field name="CMD_BUF_EN" bit="12" size="1" desc="Read-write. Reset: 0. 0=Halt command buffer processing. Writing a 0 to this bit causes the IOMMU to cease fetching new commands although commands previously fetched are completed. The IOMMU stops fetching commands upon reset and after errors as specified. Description: See also IOMMUMMIO::IOMMU_MMIO_STATUS_0[CMD_BUFRUN]. NOTE: See IOMMUMMIO::IOMMU_MMIO_STATUS_0 to determine the status of command buffer processing. NOTE: Writing of event log entries is independently controlled by EventLogEn. SOFTWARE NOTE: The Command Buffer Base Address Register (See IOMMUMMIO::IOMMU_MMIO_CMD_BASE_0), the Command Buffer Head Pointer Register IOMMUMMIO::IOMMU_MMIO_CMD_BUF_HDPTR_0, and the Command Buffer Tail Pointer Register IOMMUMMIO::IOMMU_MMIO_CMD_BUF_TAILPTR_0 must be set prior to enabling the IOMMU command buffer processor." />
      <field name="ISOC" bit="11" size="1" desc="Read-write. Reset: 0. 0=Request packet to use standard channel. 1=Request packet to use isochronous channel. This bit controls the state of the isochronous bit in the HyperTransport Read request packet when the IOMMU issues IO page table Reads and device table Reads on the HyperTransport link." />
      <field name="COHERENT" bit="10" size="1" desc="Read-write. Reset: 1. 0=Device table requests are not snooped by the processor. 1=Device table requests are snooped by the processor. This bit controls the state of the coherent bit in the HyperTransport Read request packet when the IOMMU issues device table Reads on the HyperTransport link." />
      <field name="RES_PASS_PW" bit="9" size="1" desc="Read-write. Reset: 0. 0=Response may not pass posted requests. 1=Response may pass posted requests. This bit controls the state of the ResPassPW bit in the HyperTransport Read request packet when the IOMMU issues IO page table Reads and device table Reads on the HyperTransport link." />
      <field name="PASS_PW" bit="8" size="1" desc="Read-write. Reset: 0. 0=Request packet may not pass posted requests. 1=Request packet may pass posted requests. This bit controls the state of the PassPW bit in the HyperTransport Read request packet when the IOMMU issues IO page table Reads and device table Reads on the HyperTransport link." />
      <field name="INV_TIMEOUT" bit="5" size="3" desc="Read-write. Reset: 0h. This field specifies the invalidation timeout for IOTLB invalidation requests." />
      <field name="COM_WAIT_INTEN" bit="4" size="1" desc="Read-write. Reset: 0. 0=No interrupt signaled. 1=An interrupt is signaled when IOMMUMMIO::IOMMU_MMIO_STATUS_0[COMWAIT_INT] == 1. Interrupt signaling." />
      <field name="EVENT_INT_EN" bit="3" size="1" desc="Read-write. Reset: 0. 0=Disabled. 1=Enabled. An interrupt is signaled when the EventLogInt bit is set in the IOMMU Status Register IOMMUMMIO::IOMMU_MMIO_STATUS_0." />
      <field name="EVENT_LOG_EN" bit="2" size="1" desc="Read-write. Reset: 0. 0=Disabled. 1=Enabled. Description: The Event Log Base Address Register IOMMUMMIO::IOMMU_MMIO_EVENT_BASE_0 has been configured and all events detected are Written to the event log when IommuEn has also been set. Writing a 1 to this bit when EventLogEn == 1 has no effect. When set to 0, event logging is not enabled. Events are discarded when the event log is not enabled. When IommuEn == 1 and software Writes EventLogEn with 1, the IOMMU clears the EventOverflow bit, and sets the EventLogRun bit in the IOMMU Status Register IOMMUMMIO::IOMMU_MMIO_STATUS_0. The IOMMU can now Write new entries to the event log if there are usable entries available. NOTE: Software can Read MMIO Offset IOMMUMMIO::IOMMU_MMIO_STATUS_0[EVENT_LOGRUN] to determine the status of event log Writing by the IOMMU. NOTE: The fetching of commands are independently controlled by CmdBufEn. SOFTWARE NOTE: The Event Log Base Address Register IOMMUMMIO::IOMMU_MMIO_EVENT_BASE_0, the Event Log Head Pointer Register IOMMUMMIO::IOMMU_MMIO_EVENT_BUF_HDPTR_0, and the Event Log Tail Pointer Register IOMMUMMIO::IOMMU_MMIO_EVENT_BUF_TAILPTR_0 must be set prior to enabling the event log." />
      <field name="HT_TUN_EN" bit="1" size="1" desc="Read-write. Reset: 0. 0=Upstream traffic received by the HyperTransport tunnel is not translated by the IOMMU. 1=Upstream traffic received by the HyperTransport tunnel is translated by the IOMMU. The IOMMU ignores the state of this bit while IommuEn == 0. See also the HtTunnel bit in the IOMMU Capability Header IOMMUL2::IOMMU_CAP_HEADER." />
      <field name="IOMMU_EN" bit="0" size="1" desc="Read-write. Reset: 0. 0=Disabled. 1=Enabled. Description: IOMMU enable. All upstream transactions are translated by the IOMMU. The Device Table Base Address Register IOMMUMMIO::IOMMU_MMIO_DEVTBL_BASE_0 must be configured by software before setting this bit. When set to 0, the IOMMU is disabled and no upstream transactions are translated or remapped by the IOMMU. When disabled, the IOMMU Reads no commands and creates no event log entries. SOFTWARE NOTE: Software must configure EventLogEn and CmdBufEn." />
    </register>

    <!-- page 294 -->

    <register name="IOMMU_MMIO_CNTRL_1" type="mmio" bar="IOMMUBAR" offset="0x0001C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_CNTRL_1. Read-write. Reset: 0000_2200h.">
      <!-- Bits 31:17 reserved. -->
      <field name="V2_HD_Dis" bit="16" size="1" desc="Read-write. Reset: 0. 0=Enable. 1=Disable. Disable v2 Hardware Dirty bit update." />
      <field name="HW_Prefetch_AD" bit="14" size="2" desc="Read-write. Reset: 0h. Controls host A/D updates for HW prefetches." />
      <field name="EPH_EN" bit="13" size="1" desc="Read-write. Reset: 1. 0=Disable. 1=Enable. Enables enhanced PRI handling support." />
      <!-- Bits 12:11 reserved. -->
      <field name="PPR_Auto_resp_AON" bit="10" size="1" desc="Read-write. Reset: 0. 0=Regular Auto Response behaviour, generate auto responses on buffer full or reaching the threshold based on the setting. 1=Always generate auto responses when PPR_Auto_resp_en == 1, otherwise no effect. Used to generate PPR auto responses all the time regardless of the threshold. PPR_Auto_resp_en has to be enabled in order for this to take effect." />
      <field name="Block_StopMark_En" bit="9" size="1" desc="Read-write. Reset: 1. 0=Disable blocking of stop mark message. 1=Enable blocking of stop mark message. Blocking of stop mark message." />
      <field name="MARC_en" bit="8" size="1" desc="Read-write. Reset: 0. 0=MARC disabled. 1=MARC enabled. Memory Address Routing and Control (MARC) feature Enable. When IOMMUMMIO::IOMMU_MMIO_EFR_1[MARCnum] == 0, this feild is reserved." />
      <field name="PPR_Auto_resp_en" bit="7" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enable PPR auto response when PPR near overflow." />
      <field name="PRIV_ABORT_EN" bit="5" size="2" desc="Read-write. Reset: 0h. Only effective when IOMMUMMIO::IOMMU_MMIO_EFR_1[US_SUP] == 1." />
      <!-- Bit 4 reserved. -->
      <field name="DTE_SEG_EN" bit="2" size="2" desc="Read-write. Reset: 0h. DTE segment." />
      <field name="EVENTQ" bit="0" size="2" desc="Read-write. Reset: 0h. Event queue. NOTE: This register can be set on the fly." />
    </register>

    <!-- page 295 -->

    <register name="IOMMU_MMIO_EXCL_BASE_0" type="mmio" bar="IOMMUBAR" offset="0x00020" size="4" desc="IOMMUMMIO::IOMMU_MMIO_EXCL_BASE_0. Read-write. Reset: 0000_0000h.">
      <field name="EXCL_BASE_LO" bit="12" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[31:12] of the 4K byte-aligned base address of the exclusion range." />
      <!-- Bits 11:2 reserved. -->
      <field name="EX_ALLOW" bit="1" size="1" desc="Read-write. Reset: 0. 0=The EX bit in the device table entry specifies if accesses to the exclusion range are translated. 1=All accesses to the exclusion range are forwarded untranslated. Allow accesses to the exclusion range." />
      <field name="EX_EN" bit="0" size="1" desc="Read-write. Reset: 0. 0=The exclusion range is disabled. 1=The exclusion range is enabled. Exclusion range enable." />
    </register>
    <register name="IOMMU_MMIO_EXCL_BASE_1" type="mmio" bar="IOMMUBAR" offset="0x00024" size="4" desc="IOMMUMMIO::IOMMU_MMIO_EXCL_BASE_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:20 reserved. -->
      <field name="EXCL_BASE_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[51:32] of the 4K byte-aligned base address of the exclusion range." />
    </register>
    <register name="IOMMU_MMIO_EXCL_LIM_0" type="mmio" bar="IOMMUBAR" offset="0x00028" size="4" desc="IOMMUMMIO::IOMMU_MMIO_EXCL_LIM_0. Read-write. Reset: 0000_0000h.">
      <field name="EXCL_LIMIT_LO" bit="12" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[31:12] of the 4K-byte limit of the exclusion range." />
      <!-- Bits 11:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_EXCL_LIM_1" type="mmio" bar="IOMMUBAR" offset="0x0002C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_EXCL_LIM_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:20 reserved. -->
      <field name="EXCL_LIMIT_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[63:32] of the 4K-byte limit of the exclusion range." />
    </register>
    <register name="IOMMU_MMIO_EFR_0" type="mmio" bar="IOMMUBAR" offset="0x00030" size="4" desc="IOMMUMMIO::IOMMU_MMIO_EFR_0. Read-only.">
      <!-- Bits 31:30 reserved. -->
      <field name="EVENTF" bit="28" size="2" desc="Read-only. Reset: 2h. Event log dual buffer support." />
      <field name="GAF" bit="26" size="2" desc="Read-only. Reset: Fixed,0h. GA log dual buffer support." />
      <field name="PPRF" bit="24" size="2" desc="Read-only. Reset: 2h. PPR log dual buffer support." />
      <field name="GAM_SUP" bit="21" size="3" desc="Read-only. Reset: 1h. General AVIC modes supported." />
      <field name="SMIF_RC" bit="18" size="3" desc="Read-only. Reset: 2h. Number of SMI filter registers available." />
      <field name="SMIF_SUP" bit="16" size="2" desc="Read-only. Reset: 0h. Init: BIOS,1h. SMI filter register supported. Specifies that SMI interrupts may be filtered." />
      <field name="GLX_SUP" bit="14" size="2" desc="Read-only. Reset: 1h. Single-level GCR3 base table address translation is supported. When GLX_SUP == 0, GLX in the DTE is ignored. The value of GLXSup is not meaningful when GTSup == 0." />
      <field name="GATS" bit="12" size="2" desc="Read-only. Reset: Fixed,0h. The maximum number of translation levels supported for guest address translation GVA. This value is meaningful when IOMMUMMIO::IOMMU_MMIO_EFR_0[GT_SUP] == 0." />
      <field name="HATS" bit="10" size="2" desc="Read-only. Reset: 2h. The maximum number of host address translation levels supported. This value is not meaningful when IOMMUMMIO::IOMMU_MMIO_EFR_0[GT_SUP] == 0. IOMMU behavior is undefined if Next Level in a page directory entry exceeds the limit set by HATS." />
      <field name="PC_SUP" bit="9" size="1" desc="Read-only. Reset: 1. 0=No performance counters are supported. 1=Performance counters are supported. Performance counter support." />
      <field name="HE_SUP" bit="8" size="1" desc="Read-only. Reset: 0. 0=Hardware error registers do not report error information. 1=Error information is reported in hardware error registers. Hardware error register suppot." />
      <field name="GA_SUP" bit="7" size="1" desc="Read-only. Reset: 1. 0=Guest APIC supported. 1=Guest APIC not supported. Guest APIC support." />
      <field name="IA_SUP" bit="6" size="1" desc="Read-only. Reset: 1. 0=The INVALIDATE_IOMMU_ALL command is not supported and will generate an error when used. 1=The INVALIDATE_IOMMU_ALL command is supported. INVALIDATE_IOMMU_ALL command support." />
      <!-- Bit 5 reserved. -->
      <field name="GT_SUP" bit="4" size="1" desc="Read-only. Reset: 1. 0=Only nested address translation is supported. 1=Guest address translation is" />
      <field name="NX_SUP" bit="3" size="1" desc="Read-only. Reset: 1. 0=No-execute protection is not supported. 1=No-execute protection is supported. 1=No-execute protection support." />
      <field name="XT_SUP" bit="2" size="1" desc="Read-only. Reset: 0. 0=x2APIC support is disabled. 1=The interrupt remapping table is expanded to support x2APIC interrupt information. x2APIC interrupt support." />
      <field name="PPR_SUP" bit="1" size="1" desc="Read-only. Reset: 1. 0=Peripheral page service requests are not supported, the paage service request queue is not supported and the PPR interrupt is not generated by the IOMMU. 1=Indicates that IOMMU handles page service request events from peripherals, the IOMMU supports the page service request queue, and that the second IOMMU interrupt can be used to signal peripheral page service request events. Peripheral page service request support." />
      <field name="PREF_SUP" bit="0" size="1" desc="Read-only. Reset: 0. 0=IOMMU treats PREFETCH_IOMMU_PAGES commands as illegal commands. 1=Indicates that IOMMU accepts PREFETCH_IOMMU_PAGES commands. IOMMU PREFETCH_IOMMU_PAGES command acceptance." />
    </register>

    <!-- page 298 -->

    <register name="IOMMU_MMIO_EFR_1" type="mmio" bar="IOMMUBAR" offset="0x00034" size="4" desc="IOMMUMMIO::IOMMU_MMIO_EFR_1. Read-only. Reset: 000F_77EFh.">
      <!-- Bits 31:23 reserved. -->
      <field name="InvIotlbTypeSup" bit="22" size="1" desc="Read-only. Reset: 0. 0=Hardware does not support invalidate IOTLB type. 1=Hardware supports invalidate IOTLB type. Invalidate IOTLB type support." />
      <field name="V2_HD_DIS_SUP" bit="21" size="1" desc="Read-only. Reset: 0. 0=Hardware does not support disabling v2 Dirty bit updates. 1=Hardware supports disabling v2 Dirty bit updates. Support for disabling v2 Dirty bit updates by hardware." />
      <field name="HD_SUP" bit="20" size="1" desc="Read-only. Reset: 0. 0= Hardware does not support Host Dirty bit update support. 1=Hardware supports Host Dirty bit update support for v1 Page tables. Support of Host Dirty bit update support for v1 Page tables." />
      <field name="ATTRFW_SUP" bit="19" size="1" desc="Read-only. Reset: 1. 0=Hardware does not support forward page tabe memory. 1=Hardware supports forward page table memory attribute to ATC client. Support of forward page table memory attribute to ATC client." />
      <field name="EPH_SUP" bit="18" size="1" desc="Read-only. Reset: 1. 0=Hardware does not support Enhanced PPR Handling. 1=Hardware supports Enhanced PPR Handling. Support of Enhanced PPR Handling." />
      <field name="HA_SUP" bit="17" size="1" desc="Read-only. Reset: 1. 0=Hardware does not support Host Access bit update. 1=Hardware supports Host Access bit update support for v1 Page tables. Support of Host Access bit update support for v1 Page tables." />
      <field name="GIo_SUP" bit="16" size="1" desc="Read-only. Reset: 1. 0=Hardware does not support nested IO protection. 1=Hardware supports nested IO protection. Support of nested IO protection." />
      <field name="SNOOP_ATTRS_SUP" bit="15" size="1" desc="Read-only. Reset: 0. 0=Hardware does not support returning memory attributes of the guest page. 1=Hardware supports returning memory attributes of the guest page to ATS requester along with ATS completion. Support for returning memory attributes of the guest page to ATS requester along with ATS completion." />
      <field name="MMIO_MSI_CAP_SUP" bit="14" size="1" desc="Read-only. Reset: 1. 0=IOMMU does not advertise MSI Capability registers. 1=IOMMU advertises that MSI Capability registers are accessible through IOMMU MMIO Space. IOMMU advertisement of MSI Capability registers accessible through IOMMU MMIO Space." />
      <field name="GMC_IOMMU_BYPASS_SUP" bit="13" size="1" desc="Read-only. Reset: 1. 0=GMC IOMMU bypass not supported. 1=IOMMU GMC bypass supported. IOMMU Graphics Memory Controller (GMC) bypass support." />
      <field name="BLOCK_STOPMARK_SUP" bit="12" size="1" desc="Read-only. Reset: 1. 0=No blocking Stop Mark Messages supported. 1=Block Stop Mark Messages supported. Blocking Stop Mark Messages support." />
      <field name="MARCnum" bit="10" size="2" desc="Read-only. Reset: 1h. Specifies the number of MARC apertures and thus the nubmer of MARC register 3-tuples supported." />
      <field name="PPR_AUTORESP_SUP" bit="9" size="1" desc="Read-only. Reset: 1. 0=No hardware support for PPR auto response generation on log. 1=Hardware supports PPR auto response generation on log about to be full or generates auto response on reaching threshold if enabled with OVERFLOW_EARLY. Hardware support of PPR auto response generation." />
      <field name="PPR_OVERFLOW_EARLY_SUP" bit="8" size="1" desc="Read-only. Reset: 1. 0=Hardware does not support PPR_OVERFLOW_EARLY notification on threshold. 1=Hardware supports PPR_OVERFLOW_EARLY notification on threshold. PPR_OVERFLOW_EARLY notification on threshold support." />
      <field name="DTE_seg" bit="6" size="2" desc="Read-only. Reset: 3h. DTE segmentation support." />
      <field name="US_SUP" bit="5" size="1" desc="Read-only. Reset: 1. 0=Privileged page protection is not supported. 1=Privileged page protection is supported. Privileged page protection support." />
      <!-- Bit 4 reserved. -->
      <field name="PAS_MAX" bit="0" size="4" desc="Read-only. Reset: Fh. The maximum PASID value supported is calculated as 2^PAS_MAX - 1. This value is not meaningful when IOMMUMMIO::IOMMU_MMIO_EFR_0[GT_SUP] == 0." />
    </register>

    <!-- page 299 -->

    <register name="IOMMU_MMIO_PPR_BASE_0" type="mmio" bar="IOMMUBAR" offset="0x00038" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PPR_BASE_0. Read-write. Reset: 0000_0000h.">
      <field name="PPR_BASE_LO" bit="12" size="20" desc="Read-write. Reset: 0_0000h. Specifies bits[31:12] of the base address of the PPR log. The base address programmed must be aligned to 4K bytes." />
      <!-- Bits 11:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_PPR_BASE_1" type="mmio" bar="IOMMUBAR" offset="0x0003C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PPR_BASE_1. Read-write. Reset: 0800_0000h.">
      <!-- Bits 31:28 reserved. -->
      <field name="PPR_LEN" bit="24" size="4" desc="Read-write. Reset: 8h. Specifies the length of the PPR log in power of two increments. The minimum size is 256 entries (4K bytes). Values less than 8 are reserved." />
      <!-- Bits 23:20 reserved. -->
      <field name="PPR_BASE_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Specifies bits[51:32] of the base address of the PPR log. The base address programmed must be aligned to 4K bytes." />
    </register>
    <register name="IOMMU_MMIO_HW_ERR_UPPER_0" type="mmio" bar="IOMMUBAR" offset="0x00040" size="4" desc="IOMMUMMIO::IOMMU_MMIO_HW_ERR_UPPER_0. Read-only. Reset: 0000_0000h.">
      <field name="FIRST_EV_CODE_LO" bit="0" size="32" desc="Read-only. Reset: 0000_0000h. Specifies bits[31:0] of the upper 64 bits of the most recent hardware error detected by the IOMMU." />
    </register>

    <!-- page 300 -->

    <register name="IOMMU_MMIO_HW_ERR_UPPER_1" type="mmio" bar="IOMMUBAR" offset="0x00044" size="4" desc="IOMMUMMIO::IOMMU_MMIO_HW_ERR_UPPER_1. Read-only. Reset: 0000_0000h.">
      <field name="EV_CODE" bit="28" size="4" desc="Read-only. Reset: 0h. Event code for the type of error logged." />
      <field name="FIRST_EV_CODE_HI" bit="0" size="28" desc="Read-only. Reset: 000_0000h. Specifies bits[59:32] of the upper 64 bits of the most recent hardware error detected by the IOMMU." />
    </register>
    <register name="IOMMU_MMIO_HW_ERR_LOWER_0" type="mmio" bar="IOMMUBAR" offset="0x00048" size="4" desc="IOMMUMMIO::IOMMU_MMIO_HW_ERR_LOWER_0. Read-only. Reset: 0000_0000h.">
      <field name="SECOND_EV_CODE_LO" bit="0" size="32" desc="Read-only. Reset: 0000_0000h. Specifies bits[31:0] of the lower 64 bits of the most recent hardware error detected by the IOMMU." />
    </register>
    <register name="IOMMU_MMIO_HW_ERR_LOWER_1" type="mmio" bar="IOMMUBAR" offset="0x0004C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_HW_ERR_LOWER_1. Read-only. Reset: 0000_0000h.">
      <field name="SECOND_EV_CODE_HI" bit="0" size="32" desc="Read-only. Reset: 0000_0000h. Specifies bits[63:32] of the lower 64 bits of the most recent hardware error detected by the IOMMU." />
    </register>
    <register name="IOMMU_MMIO_HW_ERR_STATUS_0" type="mmio" bar="IOMMUBAR" offset="0x00050" size="4" desc="IOMMUMMIO::IOMMU_MMIO_HW_ERR_STATUS_0. Read,Write-1-to-clear. Reset: 0000_0000h.">
      <!-- Bits 31:2 reserved. -->
      <field name="HEO" bit="1" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Not overwritten. 1=Contents overwritten by new information. Defines the contents of the IOMMU hardware error registers as having beeing overwritten. HEO is not meaningful when HEV == 0." />
      <field name="HEV" bit="0" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Not valid. 1=Contents are valid. Defines the contents of the IOMMU hardware error registers as valid." />
    </register>
    <register name="IOMMU_MMIO_HW_ERR_STATUS_1" type="mmio" bar="IOMMUBAR" offset="0x00054" size="4" desc="IOMMUMMIO::IOMMU_MMIO_HW_ERR_STATUS_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="SMI_FILTER_REGISTER_0_0" type="mmio" bar="IOMMUBAR" offset="0x00060" size="4" desc="IOMMUMMIO::SMI_FILTER_REGISTER_0_0. Reset: 0000_0000h.">
      <!-- Bits 31:18 reserved. -->
      <field name="SmiFLock_0" bit="17" size="1" desc="Write-once. Reset: 0. 0=Unlocked. 1=Locked. Makes SmiDV and SmiDID Read-only. Can only be set to 0 on reset." />
      <field name="SmiDV_0" bit="16" size="1" desc="Read-write. Reset: 0. 0=Not Valid. 1=SMI filter is enabled. Valid. This SMI filter is enabled and the Device ID specified in SmiDID is valid for the SMI." />
      <field name="SmiDID_0" bit="0" size="16" desc="Read-write. Reset: 0000h. Specifies the Device ID for the SMIs which are forwarded upstream." />
    </register>

    <!-- page 301 -->

    <register name="SMI_FILTER_REGISTER_0_1" type="mmio" bar="IOMMUBAR" offset="0x00064" size="4" desc="IOMMUMMIO::SMI_FILTER_REGISTER_0_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="SMI_FILTER_REGISTER_1_0" type="mmio" bar="IOMMUBAR" offset="0x00068" size="4" desc="IOMMUMMIO::SMI_FILTER_REGISTER_1_0. Reset: 0000_0000h.">
      <!-- Bits 31:18 reserved. -->
      <field name="SmiFLock_1" bit="17" size="1" desc="Write-once. Reset: 0. 0=Unlocked. 1=Locked. Makes SmiDV and SmiDID Read-only. Can only be set to 0 on reset." />
      <field name="SmiDV_1" bit="16" size="1" desc="Read-write. Reset: 0. 0=Not valid. 1=SMI filter is enabled. Valid. This SMI filter is enabled and the Device ID specified in SmiDID is valid for the SMI." />
      <field name="SmiDID_1" bit="0" size="16" desc="Read-write. Reset: 0000h. Specifies the Device ID for the SMIs which are forwarded upstream." />
    </register>
    <register name="SMI_FILTER_REGISTER_1_1" type="mmio" bar="IOMMUBAR" offset="0x0006C" size="4" desc="IOMMUMMIO::SMI_FILTER_REGISTER_1_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="SMI_FILTER_REGISTER_2_0" type="mmio" bar="IOMMUBAR" offset="0x00070" size="4" desc="IOMMUMMIO::SMI_FILTER_REGISTER_2_0. Reset: 0000_0000h.">
      <!-- Bits 31:18 reserved. -->
      <field name="SmiFLock_2" bit="17" size="1" desc="Write-once. Reset: 0. 0=Unlocked. 1=Locked. Makes SmiDV and SmiDID Read-only. Can only be set to 0 on reset." />
      <field name="SmiDV_2" bit="16" size="1" desc="Read-write. Reset: 0. 0=Not valid. 1=SMI filter is enabled. Valid. This SMI filter is enabled and the Device ID specified in SmiDID is valid for the SMI." />
      <field name="SmiDID_2" bit="0" size="16" desc="Read-write. Reset: 0000h. Specifies the Device ID for the SMIs which are forwarded upstream." />
    </register>
    <register name="SMI_FILTER_REGISTER_2_1" type="mmio" bar="IOMMUBAR" offset="0x00074" size="4" desc="IOMMUMMIO::SMI_FILTER_REGISTER_2_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>

    <!-- page 302 -->

    <register name="SMI_FILTER_REGISTER_3_0" type="mmio" bar="IOMMUBAR" offset="0x00078" size="4" desc="IOMMUMMIO::SMI_FILTER_REGISTER_3_0. Reset: 0000_0000h.">
      <!-- Bits 31:18 reserved. -->
      <field name="SmiFLock_3" bit="17" size="1" desc="Write-once. Reset: 0. 0=Unlocked. 1=Locked. Makes SmiDV and SmiDID Read-only. Can only be set to 0 on reset." />
      <field name="SmiDV_3" bit="16" size="1" desc="Read-write. Reset: 0. 0=Not valid. 1=SMI filter is enabled. Valid. This SMI filter is enabled and the Device ID specified in SmiDID is valid for SMI." />
      <field name="SmiDID_3" bit="0" size="16" desc="Read-write. Reset: 0000h. Specifies the Device ID for the SMIs which are forwarded upstream." />
    </register>
    <register name="SMI_FILTER_REGISTER_3_1" type="mmio" bar="IOMMUBAR" offset="0x0007C" size="4" desc="IOMMUMMIO::SMI_FILTER_REGISTER_3_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_GA_LOG_BASE_0" type="mmio" bar="IOMMUBAR" offset="0x000E0" size="4" desc="IOMMUMMIO::IOMMU_MMIO_GA_LOG_BASE_0. Read-write. Reset: 0000_0000h.">
      <field name="GA_LOG_BASE_LO" bit="12" size="20" desc="Read-write. Reset: 0_0000h. Guest virtual interrupt log base addresss. Specifies bits[31:12] of the base address of the guest virtual APIC log. The base address must be aligned to 4K bytes." />
      <!-- Bits 11:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_GA_LOG_BASE_1" type="mmio" bar="IOMMUBAR" offset="0x000E4" size="4" desc="IOMMUMMIO::IOMMU_MMIO_GA_LOG_BASE_1. Read-write. Reset: 0800_0000h.">
      <!-- Bits 31:28 reserved. -->
      <field name="GA_LOG_LEN" bit="24" size="4" desc="Read-write. Reset: 8h. Guest virtual APIC log length. Specifies the length of the guest virtual APIC log in power of 2 increments. The minimum size is 512 entries (4K bytes). Values less than 8 are Reserved." />
      <!-- Bits 23:20 reserved. -->
      <field name="GA_LOG_BASE_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Guest virtual interrupt log base addresss. Specifies bits[51:32] of the base address of the guest virtual APIC log. The base address must be aligned to 4K bytes." />
    </register>

    <!-- page 303 -->

    <register name="IOMMU_MMIO_GA_LOG_TAILPTR_ADDR_0" type="mmio" bar="IOMMUBAR" offset="0x000E8" size="4" desc="IOMMUMMIO::IOMMU_MMIO_GA_LOG_TAILPTR_ADDR_0. Read-write. Reset: 0000_0000h.">
      <field name="GA_LOG_TAILPTR_ADDR_LO" bit="3" size="29" desc="Read-write. Reset: 0000_0000h. Guest virtual APIC log tail address[31:3]. Specfies the SPA of the memory location containing the tail pointer of the guest virtual APIC log. The address must be aligned to an 8-byte boundary. When GATAddr is 0, the memory location is not updated and the software must Read the tail pointer from the Guest Virtual APIC Log Tail Pointer Register." />
      <!-- Bits 2:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_GA_LOG_TAILPTR_ADDR_1" type="mmio" bar="IOMMUBAR" offset="0x000EC" size="4" desc="IOMMUMMIO::IOMMU_MMIO_GA_LOG_TAILPTR_ADDR_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:20 reserved. -->
      <field name="GA_LOG_TAILPTR_ADDR_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Guest virtual APIC log tail address[51:32]. Specfies the SPA of the memory location containing the tail pointer of the guest virtual APIC log. The address must be aligned to an 8-byte boundary. When GATAddr is 0, the memory location is not updated and the software must Read the tail pointer from the Guest Virtual APIC Log Tail Pointer Register." />
    </register>
    <register name="IOMMU_MMIO_PPR_B_BASE_0" type="mmio" bar="IOMMUBAR" offset="0x000F0" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PPR_B_BASE_0. Read-write. Reset: 0000_0000h.">
      <field name="PPR_B_BASE_LO" bit="12" size="20" desc="Read-write. Reset: 0_0000h. Specifies bits[31:12] of the base address of the PPR log B. The base address programmed must be aligned to 4K bytes." />
      <!-- Bits 11:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_PPR_B_BASE_1" type="mmio" bar="IOMMUBAR" offset="0x000F4" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PPR_B_BASE_1. Read-write. Reset: 0800_0000h.">
      <!-- Bits 31:28 reserved. -->
      <field name="PPR_B_LEN" bit="24" size="4" desc="Read-write. Reset: 8h. Specifies the length of the PPR log B in power of two increments. The minimum size is 256 entries (4K bytes). Values less than 8 are reserved." />
      <!-- Bits 23:20 reserved. -->
      <field name="PPR_B_BASE_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Specifies bits[51:32] of the base address of the PPR log B. The base address programmed must be aligned to 4K bytes." />
    </register>

    <!-- page 304 -->

    <register name="IOMMU_MMIO_EVENT_B_BASE_0" type="mmio" bar="IOMMUBAR" offset="0x000F8" size="4" desc="IOMMUMMIO::IOMMU_MMIO_EVENT_B_BASE_0. Read-write. Reset: 0000_0000h.">
      <field name="EVENT_B_BASE_LO" bit="12" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[31:12] of the base address of the event log B. The base address programmed must be aligned to 4K bytes." />
      <!-- Bits 11:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_EVENT_B_BASE_1" type="mmio" bar="IOMMUBAR" offset="0x000FC" size="4" desc="IOMMUMMIO::IOMMU_MMIO_EVENT_B_BASE_1. Read-write. Reset: 0800_0000h.">
      <!-- Bits 31:28 reserved. -->
      <field name="EVENT_B_LEN" bit="24" size="4" desc="Read-write. Reset: 8h. Specifies the length of the event log B in power of 2 increments. The minimum size is 256 entries (4K bytes). Values less than 8 are reserved." />
      <!-- Bits 23:20 reserved. -->
      <field name="EVENT_B_BASE_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[51:32] of the base address of the event log B. The base address programmed must be aligned to 4K bytes." />
    </register>
    <register name="IOMMU_MMIO_DEVTBL_1_BASE_0" type="mmio" bar="IOMMUBAR" offset="0x00100" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVTBL_1_BASE_0. Read-write. Reset: 0000_0000h.">
      <field name="DEV_TBL_1_BASE_LO" bit="12" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[31:12] of the 4K byte-aligned base address of the specific segment of the first level device table." />
      <!-- Bits 11:9 reserved. -->
      <field name="DEV_TBL_1_SIZE" bit="0" size="9" desc="Read-write. Reset: 000h. This field contains 1 less than the length of the device table, in multiples of 4K bytes. A minimum size of 0 corresponds to a 4K-byte device table and a maximum size of 1FFh corresponds to a 2M-byte device table." />
    </register>
    <register name="IOMMU_MMIO_DEVTBL_1_BASE_1" type="mmio" bar="IOMMUBAR" offset="0x00104" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVTBL_1_BASE_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:20 reserved. -->
      <field name="DEV_TBL_1_BASE_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[51:32] of the 4K byte-aligned base address of the first level device table." />
    </register>

    <!-- page 305 -->

    <register name="IOMMU_MMIO_DEVTBL_2_BASE_0" type="mmio" bar="IOMMUBAR" offset="0x00108" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVTBL_2_BASE_0. Read-write. Reset: 0000_0000h.">
      <field name="DEV_TBL_2_BASE_LO" bit="12" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[31:12] of the 4K byte-aligned base address of the specific segment of the first level device table." />
      <!-- Bits 11:9 reserved. -->
      <field name="DEV_TBL_2_SIZE" bit="0" size="9" desc="Read-write. Reset: 000h. This field contains 1 less than the length of the device table, in multiples of 4K bytes. A minimum size of 0 corresponds to a 4K-byte device table and a maximum size of 1FFh corresponds to a 2M-byte device table." />
    </register>
    <register name="IOMMU_MMIO_DEVTBL_2_BASE_1" type="mmio" bar="IOMMUBAR" offset="0x0010C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVTBL_2_BASE_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:20 reserved. -->
      <field name="DEV_TBL_2_BASE_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[51:32] of the 4K byte-aligned base address of the first level device table." />
    </register>
    <register name="IOMMU_MMIO_DEVTBL_3_BASE_0" type="mmio" bar="IOMMUBAR" offset="0x00110" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVTBL_3_BASE_0. Read-write. Reset: 0000_0000h.">
      <field name="DEV_TBL_3_BASE_LO" bit="12" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[31:12] of the 4K byte-aligned base address of the specific segment of the first level device table." />
      <!-- Bits 11:9 reserved. -->
      <field name="DEV_TBL_3_SIZE" bit="0" size="9" desc="Read-write. Reset: 000h. This field contains 1 less than the length of the device table, in multiples of 4K bytes. A minimum size of 0 corresponds to a 4K-byte device table and a maximum size of 1FFh corresponds to a 2M-byte device table." />
    </register>
    <register name="IOMMU_MMIO_DEVTBL_3_BASE_1" type="mmio" bar="IOMMUBAR" offset="0x00114" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVTBL_3_BASE_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:20 reserved. -->
      <field name="DEV_TBL_3_BASE_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[51:32] of the 4K byte-aligned base address of the first level device table." />
    </register>
    <register name="IOMMU_MMIO_DEVTBL_4_BASE_0" type="mmio" bar="IOMMUBAR" offset="0x00118" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVTBL_4_BASE_0. Read-write. Reset: 0000_0000h.">
      <field name="DEV_TBL_4_BASE_LO" bit="12" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[31:12] of the 4K byte-aligned base address of the specific segment of the first level device table." />
      <!-- Bits 11:9 reserved. -->
      <field name="DEV_TBL_4_SIZE" bit="0" size="9" desc="Read-write. Reset: 000h. This field contains 1 less than the length of the device table, in multiples of 4K bytes. A minimum size of 0 corresponds to a 4K-byte device table and a maximum size of 1FFh corresponds to a 2M-byte device table." />
    </register>

    <!-- page 306 -->

    <register name="IOMMU_MMIO_DEVTBL_4_BASE_1" type="mmio" bar="IOMMUBAR" offset="0x0011C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVTBL_4_BASE_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:20 reserved. -->
      <field name="DEV_TBL_4_BASE_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[51:32] of the 4K byte-aligned base address of the first level device table." />
    </register>
    <register name="IOMMU_MMIO_DEVTBL_5_BASE_0" type="mmio" bar="IOMMUBAR" offset="0x00120" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVTBL_5_BASE_0. Read-write. Reset: 0000_0000h.">
      <field name="DEV_TBL_5_BASE_LO" bit="12" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[31:12] of the 4K byte-aligned base address of the specific segment of the first level device table." />
      <!-- Bits 11:9 reserved. -->
      <field name="DEV_TBL_5_SIZE" bit="0" size="9" desc="Read-write. Reset: 000h. This field contains 1 less than the length of the device table, in multiples of 4K bytes. A minimum size of 0 corresponds to a 4K-byte device table and a maximum size of 1FFh corresponds to a 2M-byte device table." />
    </register>
    <register name="IOMMU_MMIO_DEVTBL_5_BASE_1" type="mmio" bar="IOMMUBAR" offset="0x00124" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVTBL_5_BASE_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:20 reserved. -->
      <field name="DEV_TBL_5_BASE_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[51:32] of the 4K byte-aligned base address of the first level device table." />
    </register>
    <register name="IOMMU_MMIO_DEVTBL_6_BASE_0" type="mmio" bar="IOMMUBAR" offset="0x00128" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVTBL_6_BASE_0. Read-write. Reset: 0000_0000h.">
      <field name="DEV_TBL_6_BASE_LO" bit="12" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[31:12] of the 4K byte-aligned base address of the specific segment of the first level device table." />
      <!-- Bits 11:9 reserved. -->
      <field name="DEV_TBL_6_SIZE" bit="0" size="9" desc="Read-write. Reset: 000h. This field contains 1 less than the length of the device table, in multiples of 4K bytes. A minimum size of 0 corresponds to a 4K-byte device table and a maximum size of 1FFh corresponds to a 2M-byte device table." />
    </register>
    <register name="IOMMU_MMIO_DEVTBL_6_BASE_1" type="mmio" bar="IOMMUBAR" offset="0x0012C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVTBL_6_BASE_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:20 reserved. -->
      <field name="DEV_TBL_6_BASE_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[51:32] of the 4K byte-aligned base address of the first level device table." />
    </register>

    <!-- page 307 -->

    <register name="IOMMU_MMIO_DEVTBL_7_BASE_0" type="mmio" bar="IOMMUBAR" offset="0x00130" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVTBL_7_BASE_0. Read-write. Reset: 0000_0000h.">
      <field name="DEV_TBL_7_BASE_LO" bit="12" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[31:12] of the 4K byte-aligned base address of the specific segment of the first level device table." />
      <!-- Bits 11:9 reserved. -->
      <field name="DEV_TBL_7_SIZE" bit="0" size="9" desc="Read-write. Reset: 000h. This field contains 1 less than the length of the device table, in multiples of 4K bytes. A minimum size of 0 corresponds to a 4K-byte device table and a maximum size of 1FFh corresponds to a 2M-byte device table." />
    </register>
    <register name="IOMMU_MMIO_DEVTBL_7_BASE_1" type="mmio" bar="IOMMUBAR" offset="0x00134" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVTBL_7_BASE_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:20 reserved. -->
      <field name="DEV_TBL_7_BASE_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Specifies address bits[51:32] of the 4K byte-aligned base address of the first level device table." />
    </register>
    <register name="IOMMU_MMIO_DSFX" type="mmio" bar="IOMMUBAR" offset="0x00138" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DSFX. Read-only. Reset: 0000_0000h.">
      <field name="REVISION_MAJOR" bit="28" size="4" desc="Read-only. Reset: 0h. Specifies the major revision." />
      <field name="REVISION_MINOR" bit="24" size="4" desc="Read-only. Reset: 0h. Specifies the minor revision." />
      <field name="DSFXSup" bit="0" size="24" desc="Read-only. Reset: 00_0000h. Specifies to software which features (bit[n]) is supported." />
    </register>
    <register name="IOMMU_MMIO_DSCX" type="mmio" bar="IOMMUBAR" offset="0x00140" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DSCX. Reset: 0000_0000h.">
      <field name="REVISION_MAJOR" bit="28" size="4" desc="Read-only. Reset: 0h. Specifies the major revision." />
      <field name="REVISION_MINOR" bit="24" size="4" desc="Read-only. Reset: 0h. Specifies the minor revision." />
      <field name="DSCX_CNTRL" bit="0" size="24" desc="Read-write. Reset: 00_0000h. Register bits to be used in hardware as controls for features. If the corresponding IOMMUMMIO::IOMMU_MMIO_DSFX[DSFXSup] bit is low the register bit in DSCX_CNTRL should be Read-only." />
    </register>
    <register name="IOMMU_MMIO_DSSX" type="mmio" bar="IOMMUBAR" offset="0x00148" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DSSX. Reset: 0000_0000h.">
      <field name="REVISION_MAJOR" bit="28" size="4" desc="Read-only. Reset: 0h. Specifies the major revision." />
      <field name="REVISION_MINOR" bit="24" size="4" desc="Read-only. Reset: 0h. Specifies the minor revision." />
      <field name="DSSX_status" bit="0" size="24" desc="Read,Write-1-to-clear. Reset: 00_0000h. Status bits used to report hardware status to software." />
    </register>

    <!-- page 308 -->

    <register name="IOMMU_MMIO_CAP_MISC" type="mmio" bar="IOMMUBAR" offset="0x00150" size="4" desc="IOMMUMMIO::IOMMU_MMIO_CAP_MISC. Read-only. Reset: 0000_0000h.">
      <field name="IOMMU_MSI_NUM_PPR" bit="27" size="5" desc="Read-only. Reset: 00h. This field must indicate which MSI vector is used for the interrupt message generated by the IOMMU for the peripheral page service request log when IOMMUMMIO::IOMMU_MMIO_EFR_0[PPR_SUP]] == 1. IOMMU_MSI_NUM_PPR must be 0 when IOMMUMMIO::IOMMU_MMIO_EFR_0[PPR_SUP] == 0. For MSI there can be only one IOMMU so this field must be 0. This interrupt is not remapped by the IOMMU." />
      <!-- Bits 26:5 reserved. -->
      <field name="IOMMU_MSI_NUM" bit="0" size="5" desc="Read-only. Reset: 00h. Indicates the MSI vector used for interrupt messages generated by the IOMMU." />
    </register>
    <register name="IOMMU_MMIO_CAP_MISC_1" type="mmio" bar="IOMMUBAR" offset="0x00154" size="4" desc="IOMMUMMIO::IOMMU_MMIO_CAP_MISC_1. Read-only. Reset: 0000_0000h.">
      <!-- Bits 31:5 reserved. -->
      <field name="IOMMU_MSI_NUM_GA" bit="0" size="5" desc="Read-only. Reset: 00h. This field must indicate which MSI vector is used for the interrupt message generated by the IOMMU." />
    </register>
    <register name="IOMMU_MMIO_MSI_CAP" type="mmio" bar="IOMMUBAR" offset="0x00158" size="4" desc="IOMMUMMIO::IOMMU_MMIO_MSI_CAP.">
      <!-- Bits 31:24 reserved. -->
      <field name="MSI_64_EN" bit="23" size="1" desc="Read-only. Reset: Fixed,1. 0=32-bit MSI address supported. 1=64-bit MSI address supported. Set to indicate that a 64-bit MSI address is supported." />
      <field name="MSI_MULT_MESS_EN" bit="20" size="3" desc="Read-write. Reset: 0h. Sets the number of MSI messages assigned to this function." />
      <field name="MSI_MULT_MESS_CAP" bit="17" size="3" desc="Read-only. Reset: 2h. Indicates the number of MSI messages requested by this function." />
      <field name="MSI_EN" bit="16" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enables MSI for this function and causes legacy interrupts to be disabled." />
      <field name="MSI_CAP_PTR" bit="8" size="8" desc="Read-only. Reset: Fixed,74h. Pointer to the next configuration space capability." />
      <field name="MSI_CAP_ID" bit="0" size="8" desc="Read-only. Reset: Fixed,05h. Indicates that this is the MSI capability." />
    </register>
    <register name="IOMMU_MMIO_MSI_ADDR_LO" type="mmio" bar="IOMMUBAR" offset="0x0015C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_MSI_ADDR_LO. Read-write. Reset: 0000_0000h.">
      <field name="MSI_ADDR_LO" bit="2" size="30" desc="Read-write. Reset: 0000_0000h. This register sets the address bits[31:2] that are used to issue MSI messages." />
      <!-- Bits 1:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_MSI_ADDR_HI" type="mmio" bar="IOMMUBAR" offset="0x00160" size="4" desc="IOMMUMMIO::IOMMU_MMIO_MSI_ADDR_HI. Read-write. Reset: 0000_0000h.">
      <field name="MSI_ADDR_HI" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. This register sets the address bits[63:32] that are used to issue MSI messages." />
    </register>
    <register name="IOMMU_MMIO_MSI_DATA" type="mmio" bar="IOMMUBAR" offset="0x00164" size="4" desc="IOMMUMMIO::IOMMU_MMIO_MSI_DATA. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="MSI_DATA" bit="0" size="16" desc="Read-write. Reset: 0000h. This register sets the data issued with MSI messages." />
    </register>
    <register name="IOMMU_MMIO_MSI_MAPPING_CAP" type="mmio" bar="IOMMUBAR" offset="0x00168" size="4" desc="IOMMUMMIO::IOMMU_MMIO_MSI_MAPPING_CAP. Read-only. Reset: Fixed,A803_0008h.">
      <field name="MSI_MAP_CAP_TYPE" bit="27" size="5" desc="Read-only. Reset: Fixed,15h. Indicates the MSI mapping Capability." />
      <!-- Bits 26:18 reserved. -->
      <field name="MSI_MAP_FIXD" bit="17" size="1" desc="Read-only. Reset: Fixed,1. 0=No interrupt address limit. 1=Address 0xFEEX_XXXX mapped to HyperTransport interrupts. Always set to 1 to indicate that this device only maps MSI interrupts with address 0xFEEX_XXXX onto HyperTransport interrupts and that the mapping range is not programmable." />
      <field name="MSI_MAP_EN" bit="16" size="1" desc="Read-only. Reset: Fixed,1. 0=Disabled. 1=Enabled. Always set to 1 to indicate that the MSI Mapping Capability is always enabled." />
      <field name="MSI_MAP_CAP_PTR" bit="8" size="8" desc="Read-only. Reset: Fixed,00h. Points to the next capability list item." />
      <field name="MSI_MAP_CAP_ID" bit="0" size="8" desc="Read-only. Reset: Fixed,08h. Indicates a HyperTransport capability list item." />
    </register>
    <register name="IOMMU_MMIO_CONTROL_W" type="mmio" bar="IOMMUBAR" offset="0x0016C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_CONTROL_W. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:14 reserved. -->
      <field name="GMC_IOMMU_BYPASS" bit="13" size="1" desc="Read-write. Reset: 0. 0=Bypass disabled. 1=Bypass enabled. Set to 1 whenever IOMMU is not performing HOST translations or checks (INTGFX only). IOMMU indicates to Graphics Memory Controller (GMC) that the IOMMU is disabled, and GMC will bypass the IOMMU." />
      <!-- Bits 12:0 reserved. -->
    </register>
    <register name="IOMMU_MARC_BASE_LO_2" type="mmio" bar="IOMMUBAR" offset="0x00230" size="4" desc="IOMMUMMIO::IOMMU_MARC_BASE_LO_2. Read-write. Reset: 0000_0000h.">
      <field name="MARCBaseAddr_L_2" bit="12" size="20" desc="Read-write. Reset: 0_0000h. MARC aperture base address. Specifies bits[31:12] of the 4K byte aligned base addresss of a MARC memory aperture in the device's address space." />
      <!-- Bits 11:0 reserved. -->
    </register>

    <!-- page 310 -->

    <register name="IOMMU_MMIO_CMD_BUF_HDPTR_0" type="mmio" bar="IOMMUBAR" offset="0x02000" size="4" desc="IOMMUMMIO::IOMMU_MMIO_CMD_BUF_HDPTR_0. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:19 reserved. -->
      <field name="CMD_HDPTR" bit="4" size="15" desc="Read-write. Reset: 0000h. Specifies the 128-bit aligned offset from the command buffer base address register of the next command to be fetched by the IOMMU. The IOMMU increments this register, rolling over to zero at the end of the buffer and after fetching and validating the command in the command buffer. After incrementing this register, the IOMMU cannot re-fetch the command from the buffer. If this register is Written to by software while IOMMUMMIO::IOMMU_MMIO_STATUS_0[CMD_BUFRUN] == 1, the IOMMU behavior is undefined. If this register is set by software to a value outside the length specified by IOMMUMMIO::IOMMU_MMIO_CMD_BASE_1[COM_LEN], the IOMMU behavior is undefined." />
      <!-- Bits 3:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_CMD_BUF_HDPTR_1" type="mmio" bar="IOMMUBAR" offset="0x02004" size="4" desc="IOMMUMMIO::IOMMU_MMIO_CMD_BUF_HDPTR_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_CMD_BUF_TAILPTR_0" type="mmio" bar="IOMMUBAR" offset="0x02008" size="4" desc="IOMMUMMIO::IOMMU_MMIO_CMD_BUF_TAILPTR_0. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:19 reserved. -->
      <field name="CMD_TAILPTR" bit="4" size="15" desc="Read-write. Reset: 0000h. Specifies the 128-bit aligned offset from the command buffer base address register of the next command to be Written by the software. Software must increment this field, rolling over to zero at the end of the buffer and after Writing a command to the command buffer. If software advances the tail pointer equal to or beyond the head pointer after adding one or more commands to the buffer, the IOMMU behavior is undefined. If software sets the command buffer tail pointer to an offset beyond the length of the command buffer, the IOMMU behavior is undefined." />
      <!-- Bits 3:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_CMD_BUF_TAILPTR_1" type="mmio" bar="IOMMUBAR" offset="0x0200C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_CMD_BUF_TAILPTR_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_EVENT_BUF_HDPTR_0" type="mmio" bar="IOMMUBAR" offset="0x02010" size="4" desc="IOMMUMMIO::IOMMU_MMIO_EVENT_BUF_HDPTR_0. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:19 reserved. -->
      <field name="EVENT_HDPTR" bit="4" size="15" desc="Read-write. Reset: 0000h. Specifies the 128-bit aligned offset from the event log base address register that is Read next by software. Software must increment this field, rolling over at the end of the buffer and after Reading an event from the event log. If software advances the head pointer beyond the tail pointer, the   IOMMU behavior is undefined. If software sets the event log head pointer to an offset beyond the length of the event log, the IOMMU behavior is undefined." />
      <!-- Bits 3:0 reserved. -->
    </register>

    <!-- page 311 -->

    <register name="IOMMU_MMIO_EVENT_BUF_HDPTR_1" type="mmio" bar="IOMMUBAR" offset="0x02014" size="4" desc="IOMMUMMIO::IOMMU_MMIO_EVENT_BUF_HDPTR_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_EVENT_BUF_TAILPTR_0" type="mmio" bar="IOMMUBAR" offset="0x02018" size="4" desc="IOMMUMMIO::IOMMU_MMIO_EVENT_BUF_TAILPTR_0. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:19 reserved. -->
      <field name="EVENT_TAILPTR" bit="4" size="15" desc="Read-write. Reset: 0000h. Specifies the 128-bit aligned offset from the event log base address register that is Written next by the IOMMU when an event is detected. The IOMMU increments this register, rolling over at the end of the buffer and after Writing an event to the event log. If this register is Written while IOMMUMMIO::IOMMU_MMIO_STATUS_0[EVENT_LOGRUN] == 1, the IOMMU behavior is undefined. If this register is set by software to a value outside the length specified by IOMMUMMIO::IOMMU_MMIO_EVENT_BASE_1[EVENT_LEN], the IOMMU behavior is undefined." />
      <!-- Bits 3:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_EVENT_BUF_TAILPTR_1" type="mmio" bar="IOMMUBAR" offset="0x0201C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_EVENT_BUF_TAILPTR_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_STATUS_0" type="mmio" bar="IOMMUBAR" offset="0x02020" size="4" desc="IOMMUMMIO::IOMMU_MMIO_STATUS_0. Reset: 0000_0000h.">
      <!-- Bits 31:19 reserved. -->
      <field name="PPR_OVERFLOW_EARLY" bit="18" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=No early overflow reached. 1=IOMMU event log A has reached early overflow threshold. This bit is set when the respected PPR log has reached the programmable threshold and when IOMMUMMIO::IOMMU_MMIO_PPR_OVERFLOW_EARLY_0[PPR_Overflow_early_en] == 1. When IOMMUMMIO::IOMMU_MMIO_CNTRL_1[PPR_Auto_resp_en] == 1, hardware generates auto responses for the last PPR request and let Stop marker PPR msg through the log. Cleared on Writing to 1." />
      <field name="PPR_B_OVERFLOW_EARLY" bit="17" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=No early overflow reached. 1=IOMMU event log B has reached early overflow threshold. This bit is set when the respected PPR log has reached the programmable threshold and when IOMMUMMIO::IOMMU_MMIO_PPR_OVERFLOW_EARLY_0[PPR_Overflow_early_en] == 1. When IOMMUMMIO::IOMMU_MMIO_CNTRL_1[PPR_Auto_resp_en] == 1, hardware generates auto responses for the last PPR request and let Stop marker PPR msg through the log. Cleared on Writing to 1." />
      <field name="EVENT_BUF_ACTIVE" bit="16" size="1" desc="Read-only. Reset: 0. 0=EVENT default buffer being used by hardware. 1=EVENT buffer B being used by hardware. EVENT buffer active." />
      <field name="EVENT_B_OVERFLOW" bit="15" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=No event log B overflow. 1=IOMMU event log B overflow has occurred. This bit is set when a new event is to be Written to the event log and there is no usable entry in the event log, causing the new event information to be discarded. An interrupt is generated when EVENT_B_OVERFLOW == 1 and IOMMUMMIO::IOMMU_MMIO_CNTRL_0[EVENT_INT_EN] == 1. No new event log entries are Written while this bit is set. Cleared on Writing to 1." />
      <!-- Bits 14:13 reserved. -->
      <field name="PPR_BUF_ACTIVE" bit="12" size="1" desc="Read-only. Reset: 0. 0=PPR default buffer being used by hardware. 1=PPR buffer B being used by hardware. PPR active buffer." />
      <field name="PPR_B_OVERFLOW" bit="11" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=No PPR log B overflow. 1=IOMMU PPR log B overflow has occurred. This bit is set when a new peripheral page service request is to be Written to the PPR log and there is no usable entry in the PPR log, causing the new information to be discarded. An interrupt is generated when PPR_B_OVERFLOW == 1 and IOMMUMMIO::IOMMU_MMIO_CNTRL_0[PPR_INT_EN] == 1. No new PPR log entries are Written while this bit is set. Cleared on Writing to 1." />
      <field name="GA_INT" bit="10" size="1" desc="Read-write. Reset: 0. 0=No GA entry Written to the GA log by the IOMMU. 1=GA request entry Written to the GA log by the IOMMU. An interrupt is generated when GA_INT == 1 and IOMMUMMIO::IOMMU_MMIO_CNTRL_0[GA_INT_EN] == 1. Cleared on Writing to 1." />
      <field name="GA_OVERFLOW" bit="9" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=No GA log overflow has occurred.IOMMU GA log overflow has occurred." />
      <field name="GA_RUN" bit="8" size="1" desc="Read-only. Reset: 0. 0=GA requests are discarded without logging. 1=GA requests are logged as they occur. When GA_OVERFLOW == 1, the IOMMU does not Write new GA log entries even when GA_RUN == 1. When halted, GA request logging is restarted by using IOMMUMMIO::IOMMU_MMIO_CNTRL_0[GA_LOG_EN]." />
      <field name="PPR_RUN" bit="7" size="1" desc="Read-only. Reset: 0. 0=PPR requests are discarded without logging. 1=PPR requests are logged as they occur. When PPR_OVERFLOW == 1, the IOMMU does not Write new PPR log entries even when PPR_RUN == 1. When halted, PPR request logging is restarted by using IOMMUMMIO::IOMMU_MMIO_CNTRL_0[PPR_LOG_EN]." />
      <field name="PPR_INT" bit="6" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=No PPR entry Written to the PPR log by the IOMMU. 1=PPR request entry Written to the PPR log by the IOMMU.. An interrupt is generated when PPR_INT == 1 and IOMMUMMIO::IOMMU_MMIO_CNTRL_0[PPR_INT_EN] == 1. Cleared on Writing to 1." />
      <field name="PPR_OVERFLOW" bit="5" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=No PPR log overflow has occurred. 1=IOMMU PPR log overflow has occurred. This bit is set when a new peripheral page service request is to be Written to the PPR log and there is no usable entry in the PPR log, causing the new information to be discarded. An interrupt is generated when PPR_OVERFLOW == 1 and IOMMUMMIO::IOMMU_MMIO_CNTRL_0[PPR_INT_EN] == 1. No new PPR log entries are Written while this bit is set. Cleared on Writing to 1." />
      <field name="CMD_BUFRUN" bit="4" size="1" desc="Read-only. Reset: 0. 0=IOMMU has stopped fetching new commands. 1=Commands may be fetched from the command buffer. The IOMMU freezes command processing after COMMAND_HARDWARE_ERROR or ILLEGAL_COMMAND_ERROR errors. When frozen, command fetching is restarted by using IOMMUMMIO::IOMMU_MMIO_CNTRL_0[CMD_BUF_EN]." />
      <field name="EVENT_LOGRUN" bit="3" size="1" desc="Read-only. Reset: 0. 0=Event reports are discarded without logging. 1=Events are logged as they occur. When EVENT_OVERFLOW == 1, the IOMMU does not Write new event log entries even when EVENT_LOGRUN == 1. When halted, event logging is restarted by using IOMMUMMIO::IOMMU_MMIO_CNTRL_0[EVENT_LOG_EN]." />
      <field name="COMWAIT_INT" bit="2" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=COMPLETION_WAIT command not run or not completed. 1=1=COMPLETION_WAIT command completed. This bit is only set if the [i] bit is set in the COMPLETION_WAIT command. An interrupt is generated when COMWAIT_INT == 1 and IOMMUMMIO::IOMMU_MMIO_CNTRL_0[COM_WAIT_INTEN] == 1. Cleared on Writing to 1." />
      <field name="EVENT_LOGINT" bit="1" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=No event entry Written to the event log by the IOMMU. 1=Event entry Written to the event log by the IOMMU. An interrupt is generated when EVENT_LOGINT == 1 and IOMMUMMIO::IOMMU_MMIO_CNTRL_0[EVENT_INT_EN] == 1. Cleared on Writing to 1." />
      <field name="EVENT_OVERFLOW" bit="0" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=No IOMMU event log overflow has occurred.  1=IOMMU event log overflow has occurred. This bit is set when a new event is to be Written to the event log and there is no usable entry in the event log, causing the new event information to be discarded. An interrupt is generated when EVENT_OVERFLOW == 1 and IOMMUMMIO::IOMMU_MMIO_CNTRL_0[EVENT_INT_EN] == 1. No new event log entries are Written while this bit is set. Cleared on Writing to 1." />
    </register>

    <!-- page 313 -->

    <register name="IOMMU_MMIO_STATUS_1" type="mmio" bar="IOMMUBAR" offset="0x02024" size="4" desc="IOMMUMMIO::IOMMU_MMIO_STATUS_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_PPR_BUF_HDPTR_0" type="mmio" bar="IOMMUBAR" offset="0x02030" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PPR_BUF_HDPTR_0. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:19 reserved. -->
      <field name="PPR_HDPTR" bit="4" size="15" desc="Read-write. Reset: 0000h. Specifies the 128-bit aligned offset from the PPR log base address register that is Read next by software. Software must increment this field, rolling over at the end of the buffer and after Reading a PPR request entry from the PPR event log. If software advances the head pointer beyond the tail pointer, the IOMMU behavior is undefined. If software sets the PPR log head pointer to an offset beyond the length of the PPR log, the IOMMU behavior is undefined." />
      <!-- Bits 3:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_PPR_BUF_HDPTR_1" type="mmio" bar="IOMMUBAR" offset="0x02034" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PPR_BUF_HDPTR_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_PPR_BUF_TAILPTR_0" type="mmio" bar="IOMMUBAR" offset="0x02038" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PPR_BUF_TAILPTR_0. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:19 reserved. -->
      <field name="PPR_TAILPTR" bit="4" size="15" desc="Read-write. Reset: 0000h. Specifies the 128-bit aligned offset from the PPR log base address register that is Written next by the IOMMU when a PPR request is detected. The IOMMU increments this register, rolling over at the end of the buffer and after Writing a PPR request to the PPR log. If this register is Written while IOMMUMMIO::IOMMU_MMIO_STATUS_0[PPR_RUN] == 1, the IOMMU behavior is undefined. If software sets the PPR log tail pointer to an offset beyond the length of the PPR log, defined by iIOMMUMMIO::IOMMU_MMIO_PPR_BASE_1[PPR_LEN], the IOMMU behavior is undefined." />
      <!-- Bits 3:0 reserved. -->
    </register>

    <!-- page 314 -->

    <register name="IOMMU_MMIO_PPR_BUF_TAILPTR_1" type="mmio" bar="IOMMUBAR" offset="0x0203C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PPR_BUF_TAILPTR_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_GA_BUF_HDPTR_0" type="mmio" bar="IOMMUBAR" offset="0x02040" size="4" desc="IOMMUMMIO::IOMMU_MMIO_GA_BUF_HDPTR_0. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="GA_HDPTR" bit="3" size="13" desc="Read-write. Reset: 0000h. Specifies the 128-bit aligned offset from the GA log base address register that is Read next by software. Software must increment this field, rolling over at the end of the buffer, after Reading a GA request entry from the GA event log. If software advances the head pointer beyond the tail pointer, the IOMMU behavior is undefined. If software sets the GA log head pointer to an offset beyond the length of the GA log, the IOMMU behavior is undefined." />
      <!-- Bits 2:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_GA_BUF_HDPTR_1" type="mmio" bar="IOMMUBAR" offset="0x02044" size="4" desc="IOMMUMMIO::IOMMU_MMIO_GA_BUF_HDPTR_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_GA_BUF_TAILPTR_0" type="mmio" bar="IOMMUBAR" offset="0x02048" size="4" desc="IOMMUMMIO::IOMMU_MMIO_GA_BUF_TAILPTR_0. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="GA_TAILPTR" bit="3" size="13" desc="Read-write. Reset: 0000h. Guest virtual APIC log tail pointer. Specifies the 8-byte aligned offset from IOMMUMMIO::IOMMU_MMIO_GA_LOG_BASE_0 that is Written next by the IOMMU when an undelivered virtual interrup request needs to be entered into the log. The IOMMU increments this register, rolling over at the end of the buffer and after Writing an entry into the log." />
      <!-- Bits 2:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_GA_BUF_TAILPTR_1" type="mmio" bar="IOMMUBAR" offset="0x0204C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_GA_BUF_TAILPTR_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_PPR_B_BUF_HDPTR_0" type="mmio" bar="IOMMUBAR" offset="0x02050" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PPR_B_BUF_HDPTR_0. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:19 reserved. -->
      <field name="PPR_B_HDPTR" bit="4" size="15" desc="Read-write. Reset: 0000h. Specifies the 128-bit aligned offset from the PPR log base address   register that is Read next by software. Software must increment this field, rolling over at the end of the buffer and after Reading a PPR request entry from the PPR event log. If software advances the head pointer beyond the tail pointer, the IOMMU behavior is undefined. If software sets the PPR log head pointer to an offset beyond the length of the PPR log, the IOMMU behavior is undefined." />
      <!-- Bits 3:0 reserved. -->
    </register>

    <!-- page 315 -->

    <register name="IOMMU_MMIO_PPR_B_BUF_HDPTR_1" type="mmio" bar="IOMMUBAR" offset="0x02054" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PPR_B_BUF_HDPTR_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_PPR_B_BUF_TAILPTR_0" type="mmio" bar="IOMMUBAR" offset="0x02058" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PPR_B_BUF_TAILPTR_0. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:19 reserved. -->
      <field name="PPR_B_TAILPTR" bit="4" size="15" desc="Read-write. Reset: 0000h. Specifies the 128-bit aligned offset from the PPR log base address register that is Written next by the IOMMU when a PPR request is detected. The IOMMU increments this register, rolling over at the end of the buffer and after Writing a PPR request to the PPR log. If this register is Written while IOMMUMMIO::IOMMU_MMIO_STATUS_0[PPR_RUN] == 1, the IOMMU behavior is undefined. If software sets the PPR log tail pointer to an offset beyond the length of the PPR log, defined by IOMMUMMIO::IOMMU_MMIO_PPR_BASE_1[PPR_LEN], the IOMMU behavior is undefined." />
      <!-- Bits 3:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_PPR_B_BUF_TAILPTR_1" type="mmio" bar="IOMMUBAR" offset="0x0205C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PPR_B_BUF_TAILPTR_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_EVENT_B_BUF_HDPTR_0" type="mmio" bar="IOMMUBAR" offset="0x02070" size="4" desc="IOMMUMMIO::IOMMU_MMIO_EVENT_B_BUF_HDPTR_0. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:19 reserved. -->
      <field name="EVENT_B_HDPTR" bit="4" size="15" desc="Read-write. Reset: 0000h. Specifies the 128-bit aligned offset from the event log B base address register that is Read next by software. Software must increment this field, rolling over at the end of the buffer and after Reading an event from the event log. If software advances the head pointer beyond the tail pointer, the IOMMU behavior is undefined. If software sets the event log head pointer to an offset beyond the length of the event log, the IOMMU behavior is undefined." />
      <!-- Bits 3:0 reserved. -->
    </register>

    <!-- page 316 -->

    <register name="IOMMU_MMIO_EVENT_B_BUF_HDPTR_1" type="mmio" bar="IOMMUBAR" offset="0x02074" size="4" desc="IOMMUMMIO::IOMMU_MMIO_EVENT_B_BUF_HDPTR_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_EVENT_B_BUF_TAILPTR_0" type="mmio" bar="IOMMUBAR" offset="0x02078" size="4" desc="IOMMUMMIO::IOMMU_MMIO_EVENT_B_BUF_TAILPTR_0. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:19 reserved. -->
      <field name="EVENT_B_TAILPTR" bit="4" size="15" desc="Read-write. Reset: 0000h. Specifies the 128-bit aligned offset from the event log B base address register that is Written next by the IOMMU when an event is detected. The IOMMU increments this register, rolling over at the end of the buffer and after Writing an event to the event log. If this register is Written while IOMMUMMIO::IOMMU_MMIO_STATUS_0[EVENT_LOGRUN] == 1, the IOMMU behavior is undefined. If this register is set by software to a value outside the length specified by IOMMUMMIO::IOMMU_MMIO_EVENT_BASE_1[EVENT_LEN], the IOMMU behavior is undefined." />
      <!-- Bits 3:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_EVENT_B_BUF_TAILPTR_1" type="mmio" bar="IOMMUBAR" offset="0x0207C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_EVENT_B_BUF_TAILPTR_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_PPR_AUTORESP_0" type="mmio" bar="IOMMUBAR" offset="0x02080" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PPR_AUTORESP_0. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:5 reserved. -->
      <field name="PPR_Auto_resp_mask_gn" bit="4" size="1" desc="Read-write. Reset: 0. 0=No Mask. 1=1=Mask GN bit and PASID to 0. Mask GN bit and PASID to 0 for Auto Response, or else return fields from PPR request." />
      <field name="PPR_Auto_resp_code" bit="0" size="4" desc="Read-write. Reset: 0h. Programable PPR code for Auto Response. 0=SUCCESSFUL on Default." />
    </register>
    <register name="IOMMU_MMIO_PPR_OVERFLOW_EARLY_0" type="mmio" bar="IOMMUBAR" offset="0x02088" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PPR_OVERFLOW_EARLY_0. Read-write. Reset: 0000_0000h.">
      <field name="PPR_Overflow_early_en" bit="31" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enable PPR early overflow mechanism in hardware." />
      <field name="PPR_Overflow_early_int_en" bit="30" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enable PPR early overflow interrupt." />
      <!-- Bits 29:15 reserved. -->
      <field name="PPR_Overflow_early_threshold" bit="0" size="15" desc="Read-write. Reset: 0000h. Number of entries prior to overflow that hardware should signal early overflow." />
    </register>
    <register name="IOMMU_MMIO_PPR_B_OVERFLOW_EARLY_0" type="mmio" bar="IOMMUBAR" offset="0x02090" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PPR_B_OVERFLOW_EARLY_0. Read-write. Reset: 0000_0000h.">
      <field name="PPR_B_Overflow_early_en" bit="31" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enable PPR early overflow mechanism in hardware." />
      <field name="PPR_B_Overflow_early_int_en" bit="30" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enable PPR early overflow interrupt." />
      <!-- Bits 29:15 reserved. -->
      <field name="PPR_B_Overflow_early_threshold" bit="0" size="15" desc="Read-write. Reset: 0000h. Number of entries prior to overflow that hardware should signal early overflow." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_CONFIG_0" type="mmio" bar="IOMMUBAR" offset="0x04000" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_CONFIG_0. Read-only. Reset: Fixed,0000_2200h.">
      <!-- Bits 31:18 reserved. -->
      <field name="N_COUNTER_BANKS" bit="12" size="6" desc="Read-only. Reset: Fixed,02h. Description: The number of counter banks supported by the IOMMU. Each bank contains two or more counter and control registers as specified by NCounter. For each counter bank, a corresponding control bit is in IOMMU Counter PASID Bank-Lock Register IOMMUMMIO::IOMMU_MMIO_COUNTER_PASID_BANK_LOCK_0, IOMMU Counter Domain Bank-Lock Register IOMMUMMIO::IOMMU_MMIO_COUNTER_DOMAIN_BANK_LOCK_0 and IOMMU Counter DeviceID Bank-Lock Register IOMMUMMIO::IOMMU_MMIO_COUNTER_DEVID_BANK_LOCK_0. Each supported event counter bank is in a distinct, consecutive 4K-byte page. NOTE: IOMMU event counter banks are numbered starting with 0." />
      <!-- Bit 11 reserved. -->
      <field name="N_COUNTER" bit="7" size="4" desc="Read-only. Reset: Fixed,4h. Description: Reports the number of individual counters in each IOMMU counter bank. Each counter bank contains the same number of counters. 0=No counters supported. 1=Reserved 2-15=number of counters in each counter bank." />
      <!-- Bits 6:0 reserved. -->
    </register>

    <!-- page 318 -->

    <register name="IOMMU_MMIO_COUNTER_CONFIG_1" type="mmio" bar="IOMMUBAR" offset="0x04004" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_CONFIG_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>

    <!-- page 319 -->

    <register name="IOMMU_MMIO_COUNTER_PASID_BANK_LOCK_0" type="mmio" bar="IOMMUBAR" offset="0x04008" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_PASID_BANK_LOCK_0. Read-write. Reset: 0000_0000h.">
      <field name="PASID_LOCK_LO" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Description: PASID lock enable. For each bit in PASID_LOCK_LO, the corresponding PASID-match registers in an IOMMU counter bank may be changed. See IOMMU PASID Match Registers  - IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_0_0 and IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_0_1,  - IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_1_0 and IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_1_1,  - IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_2_0 and IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_2_1,  - IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_3_0 and IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_3_1,  - IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_0_0 and IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_0_1,  - IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_1_0 and IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_1_1,  - IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_2_0 and IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_2_1,  - IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_3_0 and IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_3_1.  Bit positions above the value reported in IOMMUMMIO::IOMMU_MMIO_COUNTER_CONFIG_0[N_COUNTER_BANKS] are ignored when Written and return zero when Read. The counter banks are numbered starting with zero (See IOMMUMMIO::IOMMU_MMIO_COUNTER_CONFIG_0[N_COUNTER_BANKS]), are ignored when Written and return zero when Read. The counter banks are numbered starting with zero; PASID_LOCK_LO[0] controls bank 0, etc." />
    </register>

    <!-- page 320 -->

    <register name="IOMMU_MMIO_COUNTER_PASID_BANK_LOCK_1" type="mmio" bar="IOMMUBAR" offset="0x0400C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_PASID_BANK_LOCK_1. Read-write. Reset: 0000_0000h.">
      <field name="PASID_LOCK_HI" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Description: PASID lock enable. For each bit in PASID_LOCK_HI, the corresponding PASID-match registers in an IOMMU counter bank may be changed. See IOMMU PASID Match Registers  - IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_0_0 and IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_0_1,  - IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_1_0 and IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_1_1,  - IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_2_0 and IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_2_1,  - IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_3_0 and IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_3_1,  - IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_0_0 and IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_0_1,  - IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_1_0 and IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_1_1,    - IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_2_0 and IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_2_1,  - IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_3_0 and IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_3_1.  Bit positions above the value reported in IOMMUMMIO::IOMMU_MMIO_COUNTER_CONFIG_0[N_COUNTER_BANKS] are ignored when Written and return zero when Read. The counter banks are numbered starting with 32 (See IOMMUMMIO::IOMMU_MMIO_COUNTER_CONFIG_0[N_COUNTER_BANKS]), are ignored when Written and return zero when Read. The counter banks are numbered starting with 32; PASID_LOCK_HI[0] controls bank 32, etc." />
    </register>

    <!-- page 323 -->

    <register name="IOMMU_MMIO_COUNTER_DOMAIN_BANK_LOCK_0" type="mmio" bar="IOMMUBAR" offset="0x04010" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_DOMAIN_BANK_LOCK_0. Read-write. Reset: 0000_0000h.">
      <field name="DOMAIN_LOCK_LO" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Description: Domain lock enable. For each bit in DOMAIN_LOCK_LO, the corresponding Domain-match registers in an IOMMU counter bank may be changed. See IOMMU Domain Match Registers  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_0_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_0_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_1_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_1_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_2_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_2_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_3_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_3_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_0_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_0_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_1_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_1_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_2_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_2_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_3_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_3_1.  Bit positions above the value reported in IOMMUMMIO::IOMMU_MMIO_COUNTER_CONFIG_0[N_COUNTER_BANKS] are ignored when Written and return zero when Read. The counter banks are numbered starting with zero (See IOMMUMMIO::IOMMU_MMIO_COUNTER_CONFIG_0[N_COUNTER_BANKS]), are ignored when Written and return zero when Read. The counter banks are numbered starting with zero; DOMAIN_LOCK_LO[0] controls bank 0, etc." />
    </register>

    <!-- page 325 -->

    <register name="IOMMU_MMIO_COUNTER_DOMAIN_BANK_LOCK_1" type="mmio" bar="IOMMUBAR" offset="0x04014" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_DOMAIN_BANK_LOCK_1. Read-write. Reset: 0000_0000h.">
      <field name="DOMAIN_LOCK_HI" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Description: Domain lock enable. For each bit in DOMAIN_LOCK_HI, the corresponding Domain-match registers in an IOMMU counter bank may be changed. See IOMMU Domain Match Registers  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_0_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_0_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_1_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_1_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_2_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_2_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_3_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_3_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_0_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_0_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_1_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_1_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_2_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_2_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_3_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_3_1.  Bit positions above the value reported in IOMMUMMIO::IOMMU_MMIO_COUNTER_CONFIG_0[N_COUNTER_BANKS] are ignored when Written and return zero when Read. The counter banks are numbered starting with 32 (See IOMMUMMIO::IOMMU_MMIO_COUNTER_CONFIG_0[N_COUNTER_BANKS]), are ignored when Written and return zero when Read. The counter banks are numbered starting with 32; DOMAIN_LOCK_HI[0] controls bank 32, etc." />
    </register>

    <!-- page 327 -->

    <register name="IOMMU_MMIO_COUNTER_DEVID_BANK_LOCK_0" type="mmio" bar="IOMMUBAR" offset="0x04018" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_DEVID_BANK_LOCK_0. Read-write. Reset: 0000_0000h.">
      <field name="DEVID_LOCK_LO" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Description: DeviceID lock enable. For each bit in DEVID_LOCK_LO, the corresponding DeviceID-match registers in an IOMMU counter bank may be changed. See IOMMU DeviceID Match Registers  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_0_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_0_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_1_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_1_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_2_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_2_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_3_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_3_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_0_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_0_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_1_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_1_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_2_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_2_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_3_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_3_1.  Bit positions above the value reported in IOMMUMMIO::IOMMU_MMIO_COUNTER_CONFIG_0[N_COUNTER_BANKS] are ignored when Written and return zero when Read. The counter banks are numbered starting with zero (See IOMMUMMIO::IOMMU_MMIO_COUNTER_CONFIG_0[N_COUNTER_BANKS]), are ignored when Written and return zero when Read. The counter banks are numbered starting with zero; DEVID_LOCK_LO[0] controls bank 0, etc." />
    </register>

    <!-- page 329 -->

    <register name="IOMMU_MMIO_COUNTER_DEVID_BANK_LOCK_1" type="mmio" bar="IOMMUBAR" offset="0x0401C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_DEVID_BANK_LOCK_1. Read-write. Reset: 0000_0000h.">
      <field name="DEVID_LOCK_HI" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Description: DeviceID lock enable. For each bit in DEVID_LOCK_HI, the corresponding DeviceID-match registers in an IOMMU counter bank may be changed. See IOMMU DeviceID Match Registers  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_0_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_0_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_1_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_1_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_2_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_2_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_3_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_3_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_0_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_0_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_1_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_1_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_2_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_2_1,  - IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_3_0 and IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_3_1.  Bit positions above the value reported in IOMMUMMIO::IOMMU_MMIO_COUNTER_CONFIG_0[N_COUNTER_BANKS] are ignored when Written and return zero when Read. The counter banks are numbered starting with 32 (See IOMMUMMIO::IOMMU_MMIO_COUNTER_CONFIG_0[N_COUNTER_BANKS]), are ignored when Written and return zero when Read. The counter banks are numbered starting with 32; DEVID_LOCK_HI[0] controls bank 32, etc." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_BANK_0_CNT_0_0" type="mmio" bar="IOMMUBAR" offset="0x40000" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_0_CNT_0_0. Read-write. Reset: 0000_0000h.">
      <field name="ICOUNTER_0_0_LO" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Reports the counter value (bits[31:0]). The counter counts up continuously, wrapping at the maximum value. There is no overflow indicator." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_BANK_0_CNT_0_1" type="mmio" bar="IOMMUBAR" offset="0x40004" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_0_CNT_0_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="ICOUNTER_0_0_HI" bit="0" size="16" desc="Read-write. Reset: 0000h. Reports the counter value (bits[47:32]). The counter counts up continuously, wrapping at the maximum value. There is no overflow indicator. See also IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_0_CNT_0_0." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_SRC_BANK_0_CNT_0_0" type="mmio" bar="IOMMUBAR" offset="0x40008" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_SRC_BANK_0_CNT_0_0. Read-write. Reset: 0000_0000h.">
      <field name="CAC_0_0" bit="31" size="1" desc="Read-write. Reset: 0. 0=Architectural counter input group. 1=Custom input group. Counter source architectural or custom." />
      <field name="COUNT_UNITS_0_0" bit="30" size="1" desc="Read-write. Reset: 0. 0=Counter counts events (level). 1=Counter counts clocks (edges). Count Units." />
      <!-- Bits 29:8 reserved. -->
      <field name="CSOURCE_0_0" bit="0" size="8" desc="Read-write. Reset: 00h. Counter source. Selects event counter input from the choices provided." />
    </register>

    <!-- page 330 -->

    <register name="IOMMU_MMIO_COUNTER_SRC_BANK_0_CNT_0_1" type="mmio" bar="IOMMUBAR" offset="0x4000C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_SRC_BANK_0_CNT_0_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_0_0" type="mmio" bar="IOMMUBAR" offset="0x40010" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_0_0. Read-write. Reset: 0000_0000h.">
      <field name="PASMEN_0_0" bit="31" size="1" desc="Read-write. Reset: 0. 0=PASID is ignored. 1=Filtered PASID must match to count an event. PASID Match enable. An event with no PASID tag is only counted when PASMEN_0_0 == 0." />
      <!-- Bits 30:16 reserved. -->
      <field name="PASID_MATCH_0_0" bit="0" size="16" desc="Read-write. Reset: 0000h. PASID match. This value is compared with the masked (filtered) value of the incoming PASID of the transaction to decide to count the corresponding event. The event is counted if PASID_MATCH_0_0 is exactly equal to the masked incoming PASID. The event is not counted if they are not equal." />
    </register>
    <register name="IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_0_1" type="mmio" bar="IOMMUBAR" offset="0x40014" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_0_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="PASID_MASK_0_0" bit="0" size="16" desc="Read-write. Reset: 0000h. PASID Mask. This bit-mask is ANDed with the PASID of the transaction to decide to count the corresponding event." />
    </register>
    <register name="IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_0_0" type="mmio" bar="IOMMUBAR" offset="0x40018" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_0_0. Read-write. Reset: 0000_0000h.">
      <field name="DOMMEN_0_0" bit="31" size="1" desc="Read-write. Reset: 0. 0=Domain is ignored. 1=Filtered Domain must match to count an event. Domain Match enable." />
      <!-- Bits 30:16 reserved. -->
      <field name="DOMAIN_MATCH_0_0" bit="0" size="16" desc="Read-write. Reset: 0000h. Domain Match. This value is compared with the masked (filtered) value of the incoming Domain of the transaction to decide to count the corresponding event. The event is counted if DOMAIN_MATCH_0_0 is exactly equal to the masked incoming Domain. The event is not counted if they are not equal." />
    </register>
    <register name="IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_0_1" type="mmio" bar="IOMMUBAR" offset="0x4001C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_0_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="DOMAIN_MASK_0_0" bit="0" size="16" desc="Read-write. Reset: 0000h. Domain Mask. This bit-mask is ANDed with the Domain of the transaction to decide to count the corresponding event." />
    </register>

    <!-- page 331 -->

    <register name="IOMMU_MMIO_DEVICEID_MATCH_BANK_0_CNT_0_0" type="mmio" bar="IOMMUBAR" offset="0x40020" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVICEID_MATCH_BANK_0_CNT_0_0. Read-write. Reset: 0000_0000h.">
      <field name="DIDMEN_0_0" bit="31" size="1" desc="Read-write. Reset: 0. 0=DeviceID is ignored. 1=Filtered DeviceID must match to count an event. DeviceID Match enable." />
      <!-- Bits 30:16 reserved. -->
      <field name="DEVICEID_MATCH_0_0" bit="0" size="16" desc="Read-write. Reset: 0000h. DeviceID Match. This value is compared with the masked (filtered) value of the incoming DeviceID of the transaction to decide to count the corresponding event. The event is counted if DEVICEID_MATCH_0_0 is exactly equal to the masked incoming DeviceID. The event is not counted if they are not equal." />
    </register>
    <register name="IOMMU_MMIO_DEVICEID_MATCH_BANK_0_CNT_0_1" type="mmio" bar="IOMMUBAR" offset="0x40024" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVICEID_MATCH_BANK_0_CNT_0_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="DEVICEID_MASK_0_0" bit="0" size="16" desc="Read-write. Reset: 0000h. DeviceID Mask. This bit-mask is ANDed with the DeviceID of the transaction to decide to count the corresponding event." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_0_0" type="mmio" bar="IOMMUBAR" offset="0x40028" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_0_0. Read-write. Reset: 0000_0000h.">
      <field name="EVENT_NOTE_0_0_LO" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Event Note (bits[31:0]). When IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_0_1[CERE_0_0] == 1 and the corresponding counter is incremented and wraps to zero, EVENT_NOTE_0_0[51:0] is reported in the EVENT_COUNTER_ZERO event log entry. EVENT_NOTE_0_0[51:0] = {EVENT_NOTE_0_0_LO,IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_0_ 1[EVENT_NOTE_0_0_HI]}" />
    </register>

    <!-- page 332 -->

    <register name="IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_0_1" type="mmio" bar="IOMMUBAR" offset="0x4002C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_0_1. Read-write. Reset: 0000_0000h.">
      <field name="CERE_0_0" bit="31" size="1" desc="Read-write. Reset: 0. 0=No event report when counter wraps to zero. 1=IOMMU Writes an EVENT_COUNTER_ZERO event log entry when the counter wraps to zero.   Description: Counter Event Report Enable. The counter-wrap event is treated like any other event. SOFTWARE NOTE: The counter-wrap event is delivered promptly but there is no defined latency expectation." />
      <!-- Bits 30:20 reserved. -->
      <field name="EVENT_NOTE_0_0_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Event Note (bits[51:32]). When CERE_0_0 == 1 and the corresponding counter is incremented and wraps to zero, EVENT_NOTE_0_0[51:0] is reported in the EVENT_COUNTER_ZERO event log entry. See also IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_0_0." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_BANK_0_CNT_1_0" type="mmio" bar="IOMMUBAR" offset="0x40100" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_0_CNT_1_0. Read-write. Reset: 0000_0000h.">
      <field name="ICOUNTER_0_1_LO" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Reports the counter value (bits[31:0]). The counter counts up continuously, wrapping at the maximum value. There is no overflow indicator." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_BANK_0_CNT_1_1" type="mmio" bar="IOMMUBAR" offset="0x40104" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_0_CNT_1_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="ICOUNTER_0_1_HI" bit="0" size="16" desc="Read-write. Reset: 0000h. Reports the counter value (bits[47:32]). The counter counts up continuously, wrapping at the maximum value. There is no overflow indicator. See also IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_0_CNT_1_0." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_SRC_BANK_0_CNT_1_0" type="mmio" bar="IOMMUBAR" offset="0x40108" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_SRC_BANK_0_CNT_1_0. Read-write. Reset: 0000_0000h.">
      <field name="CAC_0_1" bit="31" size="1" desc="Read-write. Reset: 0. 0=Architectural counter input group. 1=Custom input group. Counter source architectural or custom." />
      <field name="COUNT_UNITS_0_1" bit="30" size="1" desc="Read-write. Reset: 0. 0=Counter counts events (level). 1=Counter counts clocks (edges). Count Units." />
      <!-- Bits 29:8 reserved. -->
      <field name="CSOURCE_0_1" bit="0" size="8" desc="Read-write. Reset: 00h. Counter source. Selects event counter input from the choices provided." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_SRC_BANK_0_CNT_1_1" type="mmio" bar="IOMMUBAR" offset="0x4010C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_SRC_BANK_0_CNT_1_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>

    <!-- page 333 -->

    <register name="IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_1_0" type="mmio" bar="IOMMUBAR" offset="0x40110" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_1_0. Read-write. Reset: 0000_0000h.">
      <field name="PASMEN_0_1" bit="31" size="1" desc="Read-write. Reset: 0. 0=PASID is ignored. 1=Filtered PASID must match to count an event. PASID Match enable. An event with no PASID tag is only counted when PASMEN_0_1 == 0." />
      <!-- Bits 30:16 reserved. -->
      <field name="PASID_MATCH_0_1" bit="0" size="16" desc="Read-write. Reset: 0000h. PASID match. This value is compared with the masked (filtered) value of the incoming PASID of the transaction to decide to count the corresponding event. The event is counted if PASID_MATCH_0_1 is exactly equal to the masked incoming PASID. The event is not counted if they are not equal." />
    </register>
    <register name="IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_1_1" type="mmio" bar="IOMMUBAR" offset="0x40114" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_1_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="PASID_MASK_0_1" bit="0" size="16" desc="Read-write. Reset: 0000h. PASID Mask. This bit-mask is ANDed with the PASID of the transaction to decide to count the corresponding event." />
    </register>
    <register name="IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_1_0" type="mmio" bar="IOMMUBAR" offset="0x40118" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_1_0. Read-write. Reset: 0000_0000h.">
      <field name="DOMMEN_0_1" bit="31" size="1" desc="Read-write. Reset: 0. 0=Domain is ignored. 1=Filtered Domain must match to count an event. Domain Match enable." />
      <!-- Bits 30:16 reserved. -->
      <field name="DOMAIN_MATCH_0_1" bit="0" size="16" desc="Read-write. Reset: 0000h. Domain Match. This value is compared with the masked (filtered) value of the incoming Domain of the transaction to decide to count the corresponding event. The event is counted if DOMAIN_MATCH_0_1 is exactly equal to the masked incoming Domain. The event is not counted if they are not equal." />
    </register>
    <register name="IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_1_1" type="mmio" bar="IOMMUBAR" offset="0x4011C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_1_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="DOMAIN_MASK_0_1" bit="0" size="16" desc="Read-write. Reset: 0000h. Domain Mask. This bit-mask is ANDed with the Domain of the transaction to decide to count the corresponding event." />
    </register>

    <!-- page 334 -->

    <register name="IOMMU_MMIO_DEVICEID_MATCH_BANK_0_CNT_1_0" type="mmio" bar="IOMMUBAR" offset="0x40120" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVICEID_MATCH_BANK_0_CNT_1_0. Read-write. Reset: 0000_0000h.">
      <field name="DIDMEN_0_1" bit="31" size="1" desc="Read-write. Reset: 0. 0=DeviceID is ignored. 1=Filtered DeviceID must match to count an event. DeviceID Match enable." />
      <!-- Bits 30:16 reserved. -->
      <field name="DEVICEID_MATCH_0_1" bit="0" size="16" desc="Read-write. Reset: 0000h. DeviceID Match. This value is compared with the masked (filtered) value of the incoming DeviceID of the transaction to decide to count the corresponding event. The event is counted if DEVICEID_MATCH_0_1 is exactly equal to the masked incoming DeviceID. The event is not counted if they are not equal." />
    </register>
    <register name="IOMMU_MMIO_DEVICEID_MATCH_BANK_0_CNT_1_1" type="mmio" bar="IOMMUBAR" offset="0x40124" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVICEID_MATCH_BANK_0_CNT_1_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="DEVICEID_MASK_0_1" bit="0" size="16" desc="Read-write. Reset: 0000h. DeviceID Mask. This bit-mask is ANDed with the DeviceID of the transaction to decide to count the corresponding event." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_1_0" type="mmio" bar="IOMMUBAR" offset="0x40128" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_1_0. Read-write. Reset: 0000_0000h.">
      <field name="EVENT_NOTE_0_1_LO" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Event Note (bits[31:0]). When IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_1_1[CERE_0_1] == 1 and the corresponding counter is incremented and wraps to zero, EVENT_NOTE_0_1[51:0] is reported in the EVENT_COUNTER_ZERO event log entry. EVENT_NOTE_0_1[51:0] = {EVENT_NOTE_0_1_LO,IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_1_ 1[EVENT_NOTE_0_1_HI]}" />
    </register>
    <register name="IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_1_1" type="mmio" bar="IOMMUBAR" offset="0x4012C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_1_1. Read-write. Reset: 0000_0000h.">
      <field name="CERE_0_1" bit="31" size="1" desc="Read-write. Reset: 0. 0=No event report when counter wraps to zero. 1=IOMMU Writes an EVENT_COUNTER_ZERO event log entry when the counter wraps to zero. Description: Counter Event Report Enable. The counter-wrap event is treated like any other event. SOFTWARE NOTE: The counter-wrap event is delivered promptly but there is no defined latency expectation." />
      <!-- Bits 30:20 reserved. -->
      <field name="EVENT_NOTE_0_1_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Event Note (bits[51:32]). When CERE_0_1 == 1 and the corresponding counter is incremented and wraps to zero, EVENT_NOTE_0_1[51:0] is reported in the   EVENT_COUNTER_ZERO event log entry. See also IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_1_0." />
    </register>

    <!-- page 335 -->

    <register name="IOMMU_MMIO_COUNTER_BANK_0_CNT_2_0" type="mmio" bar="IOMMUBAR" offset="0x40200" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_0_CNT_2_0. Read-write. Reset: 0000_0000h.">
      <field name="ICOUNTER_0_2_LO" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Reports the counter value (bits[31:0]). The counter counts up continuously, wrapping at the maximum value. There is no overflow indicator." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_BANK_0_CNT_2_1" type="mmio" bar="IOMMUBAR" offset="0x40204" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_0_CNT_2_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="ICOUNTER_0_2_HI" bit="0" size="16" desc="Read-write. Reset: 0000h. Reports the counter value (bits[47:32]). The counter counts up continuously, wrapping at the maximum value. There is no overflow indicator. See also IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_0_CNT_2_0." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_SRC_BANK_0_CNT_2_0" type="mmio" bar="IOMMUBAR" offset="0x40208" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_SRC_BANK_0_CNT_2_0. Read-write. Reset: 0000_0000h.">
      <field name="CAC_0_2" bit="31" size="1" desc="Read-write. Reset: 0. 0=Architectural counter input group. 1=Custom input group. Counter source architectural or custom." />
      <field name="COUNT_UNITS_0_2" bit="30" size="1" desc="Read-write. Reset: 0. 0=Counter counts events (level). 1=Counter counts clocks (edges). Count Units." />
      <!-- Bits 29:8 reserved. -->
      <field name="CSOURCE_0_2" bit="0" size="8" desc="Read-write. Reset: 00h. Counter source. Selects event counter input from the choices provided." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_SRC_BANK_0_CNT_2_1" type="mmio" bar="IOMMUBAR" offset="0x4020C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_SRC_BANK_0_CNT_2_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_2_0" type="mmio" bar="IOMMUBAR" offset="0x40210" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_2_0. Read-write. Reset: 0000_0000h.">
      <field name="PASMEN_0_2" bit="31" size="1" desc="Read-write. Reset: 0. 0=PASID is ignored. 1=Filtered PASID must match to count an event. PASID Match enable. An event with no PASID tag is only counted when PASMEN_0_2 == 0." />
      <!-- Bits 30:16 reserved. -->
      <field name="PASID_MATCH_0_2" bit="0" size="16" desc="Read-write. Reset: 0000h. PASID match. This value is compared with the masked (filtered) value of the incoming PASID of the transaction to decide to count the corresponding event. The event is   counted if PASID_MATCH_0_2 is exactly equal to the masked incoming PASID. The event is not counted if they are not equal." />
    </register>

    <!-- page 336 -->

    <register name="IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_2_1" type="mmio" bar="IOMMUBAR" offset="0x40214" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_2_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="PASID_MASK_0_2" bit="0" size="16" desc="Read-write. Reset: 0000h. PASID Mask. This bit-mask is ANDed with the PASID of the transaction to decide to count the corresponding event." />
    </register>
    <register name="IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_2_0" type="mmio" bar="IOMMUBAR" offset="0x40218" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_2_0. Read-write. Reset: 0000_0000h.">
      <field name="DOMMEN_0_2" bit="31" size="1" desc="Read-write. Reset: 0. 0=Domain is ignored. 1=Filtered Domain must match to count an event. Domain Match enable." />
      <!-- Bits 30:16 reserved. -->
      <field name="DOMAIN_MATCH_0_2" bit="0" size="16" desc="Read-write. Reset: 0000h. Domain Match. This value is compared with the masked (filtered) value of the incoming Domain of the transaction to decide to count the corresponding event. The event is counted if DOMAIN_MATCH_0_2 is exactly equal to the masked incoming Domain. The event is not counted if they are not equal." />
    </register>
    <register name="IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_2_1" type="mmio" bar="IOMMUBAR" offset="0x4021C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_2_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="DOMAIN_MASK_0_2" bit="0" size="16" desc="Read-write. Reset: 0000h. Domain Mask. This bit-mask is ANDed with the Domain of the transaction to decide to count the corresponding event." />
    </register>

    <!-- page 337 -->

    <register name="IOMMU_MMIO_DEVICEID_MATCH_BANK_0_CNT_2_0" type="mmio" bar="IOMMUBAR" offset="0x40220" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVICEID_MATCH_BANK_0_CNT_2_0. Read-write. Reset: 0000_0000h.">
      <field name="DIDMEN_0_2" bit="31" size="1" desc="Read-write. Reset: 0. 0=DeviceID is ignored. 1=Filtered DeviceID must match to count an event.   DeviceID Match enable." />
      <!-- Bits 30:16 reserved. -->
      <field name="DEVICEID_MATCH_0_2" bit="0" size="16" desc="Read-write. Reset: 0000h. DeviceID Match. This value is compared with the masked (filtered) value of the incoming DeviceID of the transaction to decide to count the corresponding event. The event is counted if DEVICEID_MATCH_0_2 is exactly equal to the masked incoming DeviceID. The event is not counted if they are not equal." />
    </register>
    <register name="IOMMU_MMIO_DEVICEID_MATCH_BANK_0_CNT_2_1" type="mmio" bar="IOMMUBAR" offset="0x40224" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVICEID_MATCH_BANK_0_CNT_2_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="DEVICEID_MASK_0_2" bit="0" size="16" desc="Read-write. Reset: 0000h. DeviceID Mask. This bit-mask is ANDed with the DeviceID of the transaction to decide to count the corresponding event." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_2_0" type="mmio" bar="IOMMUBAR" offset="0x40228" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_2_0. Read-write. Reset: 0000_0000h.">
      <field name="EVENT_NOTE_0_2_LO" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Event Note (bits[31:0]). When IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_2_1[CERE_0_2] == 1 and the corresponding counter is incremented and wraps to zero, EVENT_NOTE_0_2[51:0] is reported in the EVENT_COUNTER_ZERO event log entry. EVENT_NOTE_0_2[51:0] = {EVENT_NOTE_0_2_LO,IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_2_ 1[EVENT_NOTE_0_2_HI]}" />
    </register>
    <register name="IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_2_1" type="mmio" bar="IOMMUBAR" offset="0x4022C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_2_1. Read-write. Reset: 0000_0000h.">
      <field name="CERE_0_2" bit="31" size="1" desc="Read-write. Reset: 0. 0=No event report when counter wraps to zero. 1=IOMMU Writes an EVENT_COUNTER_ZERO event log entry when the counter wraps to zero. Description: Counter Event Report Enable. The counter-wrap event is treated like any other event. SOFTWARE NOTE: The counter-wrap event is delivered promptly but there is no defined latency expectation." />
      <!-- Bits 30:20 reserved. -->
      <field name="EVENT_NOTE_0_2_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Event Note (bits[51:32]). When CERE_0_2 == 1 and the corresponding counter is incremented and wraps to zero, EVENT_NOTE_0_2[51:0] is reported in the EVENT_COUNTER_ZERO event log entry. See also IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_2_0." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_BANK_0_CNT_3_0" type="mmio" bar="IOMMUBAR" offset="0x40300" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_0_CNT_3_0. Read-write. Reset: 0000_0000h.">
      <field name="ICOUNTER_0_3_LO" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Reports the counter value (bits[31:0]). The counter counts up continuously, wrapping at the maximum value. There is no overflow indicator." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_BANK_0_CNT_3_1" type="mmio" bar="IOMMUBAR" offset="0x40304" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_0_CNT_3_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="ICOUNTER_0_3_HI" bit="0" size="16" desc="Read-write. Reset: 0000h. Reports the counter value (bits[47:32]). The counter counts up continuously, wrapping at the maximum value. There is no overflow indicator. See also IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_0_CNT_3_0." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_SRC_BANK_0_CNT_3_0" type="mmio" bar="IOMMUBAR" offset="0x40308" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_SRC_BANK_0_CNT_3_0. Read-write. Reset: 0000_0000h.">
      <field name="CAC_0_3" bit="31" size="1" desc="Read-write. Reset: 0. 0=Architectural counter input group. 1=Custom input group. Counter source architectural or custom." />
      <field name="COUNT_UNITS_0_3" bit="30" size="1" desc="Read-write. Reset: 0. 0=Counter counts events (level). 1=Counter counts clocks (edges). Count Units." />
      <!-- Bits 29:8 reserved. -->
      <field name="CSOURCE_0_3" bit="0" size="8" desc="Read-write. Reset: 00h. Counter source. Selects event counter input from the choices provided." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_SRC_BANK_0_CNT_3_1" type="mmio" bar="IOMMUBAR" offset="0x4030C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_SRC_BANK_0_CNT_3_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_3_0" type="mmio" bar="IOMMUBAR" offset="0x40310" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_3_0. Read-write. Reset: 0000_0000h.">
      <field name="PASMEN_0_3" bit="31" size="1" desc="Read-write. Reset: 0. 0=PASID is ignored. 1=Filtered PASID must match to count an event. PASID Match enable. An event with no PASID tag is only counted when PASMEN_0_3 == 0." />
      <!-- Bits 30:16 reserved. -->
      <field name="PASID_MATCH_0_3" bit="0" size="16" desc="Read-write. Reset: 0000h. PASID match. This value is compared with the masked (filtered) value of the incoming PASID of the transaction to decide to count the corresponding event. The event is counted if PASID_MATCH_0_3 is exactly equal to the masked incoming PASID. The event is not counted if they are not equal." />
    </register>
    <register name="IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_3_1" type="mmio" bar="IOMMUBAR" offset="0x40314" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_0_CNT_3_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="PASID_MASK_0_3" bit="0" size="16" desc="Read-write. Reset: 0000h. PASID Mask. This bit-mask is ANDed with the PASID of the transaction to decide to count the corresponding event." />
    </register>
    <register name="IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_3_0" type="mmio" bar="IOMMUBAR" offset="0x40318" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_3_0. Read-write. Reset: 0000_0000h.">
      <field name="DOMMEN_0_3" bit="31" size="1" desc="Read-write. Reset: 0. 0=Domain is ignored. 1=Filtered Domain must match to count an event. Domain Match enable." />
      <!-- Bits 30:16 reserved. -->
      <field name="DOMAIN_MATCH_0_3" bit="0" size="16" desc="Read-write. Reset: 0000h. Domain Match. This value is compared with the masked (filtered) value of the incoming Domain of the transaction to decide to count the corresponding event. The event is counted if DOMAIN_MATCH_0_3 is exactly equal to the masked incoming Domain. The event is not counted if they are not equal." />
    </register>
    <register name="IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_3_1" type="mmio" bar="IOMMUBAR" offset="0x4031C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_0_CNT_3_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="DOMAIN_MASK_0_3" bit="0" size="16" desc="Read-write. Reset: 0000h. Domain Mask. This bit-mask is ANDed with the Domain of the transaction to decide to count the corresponding event." />
    </register>
    <register name="IOMMU_MMIO_DEVICEID_MATCH_BANK_0_CNT_3_0" type="mmio" bar="IOMMUBAR" offset="0x40320" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVICEID_MATCH_BANK_0_CNT_3_0. Read-write. Reset: 0000_0000h.">
      <field name="DIDMEN_0_3" bit="31" size="1" desc="Read-write. Reset: 0. 0=DeviceID is ignored. 1=Filtered DeviceID must match to count an event. DeviceID Match enable." />
      <!-- Bits 30:16 reserved. -->
      <field name="DEVICEID_MATCH_0_3" bit="0" size="16" desc="Read-write. Reset: 0000h. DeviceID Match. This value is compared with the masked (filtered) value of the incoming DeviceID of the transaction to decide to count the corresponding event. The event is counted if DEVICEID_MATCH_0_3 is exactly equal to the masked incoming DeviceID. The event is not   counted if they are not equal." />
    </register>

    <!-- page 340 -->

    <register name="IOMMU_MMIO_DEVICEID_MATCH_BANK_0_CNT_3_1" type="mmio" bar="IOMMUBAR" offset="0x40324" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVICEID_MATCH_BANK_0_CNT_3_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="DEVICEID_MASK_0_3" bit="0" size="16" desc="Read-write. Reset: 0000h. DeviceID Mask. This bit-mask is ANDed with the DeviceID of the transaction to decide to count the corresponding event." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_3_0" type="mmio" bar="IOMMUBAR" offset="0x40328" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_3_0. Read-write. Reset: 0000_0000h.">
      <field name="EVENT_NOTE_0_3_LO" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Event Note (bits[31:0]). When IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_3_1[CERE_0_3] == 1 and the corresponding counter is incremented and wraps to zero, EVENT_NOTE_0_3[51:0] is reported in the EVENT_COUNTER_ZERO event log entry. EVENT_NOTE_0_3[51:0] = {EVENT_NOTE_0_3_LO,IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_3_ 1[EVENT_NOTE_0_3_HI]}" />
    </register>
    <register name="IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_3_1" type="mmio" bar="IOMMUBAR" offset="0x4032C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_3_1. Read-write. Reset: 0000_0000h.">
      <field name="CERE_0_3" bit="31" size="1" desc="Read-write. Reset: 0. 0=No event report when counter wraps to zero. 1=IOMMU Writes an EVENT_COUNTER_ZERO event log entry when the counter wraps to zero. Description: Counter Event Report Enable. The counter-wrap event is treated like any other event. SOFTWARE NOTE: The counter-wrap event is delivered promptly but there is no defined latency expectation." />
      <!-- Bits 30:20 reserved. -->
      <field name="EVENT_NOTE_0_3_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Event Note (bits[51:32]). When CERE_0_3 == 1 and the corresponding counter is incremented and wraps to zero, EVENT_NOTE_0_3[51:0] is reported in the EVENT_COUNTER_ZERO event log entry. See also IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_0_CNT_3_0." />
    </register>

    <!-- page 341 -->

    <register name="IOMMU_MMIO_COUNTER_BANK_1_CNT_0_0" type="mmio" bar="IOMMUBAR" offset="0x41000" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_1_CNT_0_0. Read-write. Reset: 0000_0000h.">
      <field name="ICOUNTER_1_0_LO" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Reports the counter value (bits[31:0]). The counter counts up continuously, wrapping at the maximum value. There is no overflow indicator." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_BANK_1_CNT_0_1" type="mmio" bar="IOMMUBAR" offset="0x41004" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_1_CNT_0_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="ICOUNTER_1_0_HI" bit="0" size="16" desc="Read-write. Reset: 0000h. Reports the counter value (bits[47:32]). The counter counts up continuously, wrapping at the maximum value. There is no overflow indicator. See also IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_1_CNT_0_0." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_SRC_BANK_1_CNT_0_0" type="mmio" bar="IOMMUBAR" offset="0x41008" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_SRC_BANK_1_CNT_0_0. Read-write. Reset: 0000_0000h.">
      <field name="CAC_1_0" bit="31" size="1" desc="Read-write. Reset: 0. 0=Architectural counter input group. 1=Custom input group. Counter source architectural or custom." />
      <field name="COUNT_UNITS_1_0" bit="30" size="1" desc="Read-write. Reset: 0. 0=Counter counts events (level). 1=Counter counts clocks (edges). Count Units." />
      <!-- Bits 29:8 reserved. -->
      <field name="CSOURCE_1_0" bit="0" size="8" desc="Read-write. Reset: 00h. Counter source. Selects event counter input from the choices provided." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_SRC_BANK_1_CNT_0_1" type="mmio" bar="IOMMUBAR" offset="0x4100C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_SRC_BANK_1_CNT_0_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_0_0" type="mmio" bar="IOMMUBAR" offset="0x41010" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_0_0. Read-write. Reset: 0000_0000h.">
      <field name="PASMEN_1_0" bit="31" size="1" desc="Read-write. Reset: 0. 0=PASID is ignored. 1=Filtered PASID must match to count an event. PASID Match enable. An event with no PASID tag is only counted when PASMEN_1_0 == 0." />
      <!-- Bits 30:16 reserved. -->
      <field name="PASID_MATCH_1_0" bit="0" size="16" desc="Read-write. Reset: 0000h. PASID match. This value is compared with the masked (filtered) value of the incoming PASID of the transaction to decide to count the corresponding event. The event is counted if PASID_MATCH_1_0 is exactly equal to the masked incoming PASID. The event is not counted if they are not equal." />
    </register>
    <register name="IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_0_1" type="mmio" bar="IOMMUBAR" offset="0x41014" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_0_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="PASID_MASK_1_0" bit="0" size="16" desc="Read-write. Reset: 0000h. PASID Mask. This bit-mask is ANDed with the PASID of the transaction to decide to count the corresponding event. " />
    </register>

    <!-- page 342 -->

    <register name="IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_0_0" type="mmio" bar="IOMMUBAR" offset="0x41018" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_0_0. Read-write. Reset: 0000_0000h.">
      <field name="DOMMEN_1_0" bit="31" size="1" desc="Read-write. Reset: 0. 0=Domain is ignored. 1=Filtered Domain must match to count an event. Domain Match enable." />
      <!-- Bits 30:16 reserved. -->
      <field name="DOMAIN_MATCH_1_0" bit="0" size="16" desc="Read-write. Reset: 0000h. Domain Match. This value is compared with the masked (filtered) value of the incoming Domain of the transaction to decide to count the corresponding event. The event is counted if DOMAIN_MATCH_1_0 is exactly equal to the masked incoming Domain. The event is not counted if they are not equal." />
    </register>
    <register name="IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_0_1" type="mmio" bar="IOMMUBAR" offset="0x4101C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_0_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="DOMAIN_MASK_1_0" bit="0" size="16" desc="Read-write. Reset: 0000h. Domain Mask. This bit-mask is ANDed with the Domain of the transaction to decide to count the corresponding event." />
    </register>
    <register name="IOMMU_MMIO_DEVICEID_MATCH_BANK_1_CNT_0_0" type="mmio" bar="IOMMUBAR" offset="0x41020" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVICEID_MATCH_BANK_1_CNT_0_0. Read-write. Reset: 0000_0000h.">
      <field name="DIDMEN_1_0" bit="31" size="1" desc="Read-write. Reset: 0. 0=DeviceID is ignored. 1=Filtered DeviceID must match to count an event. DeviceID Match enable." />
      <!-- Bits 30:16 reserved. -->
      <field name="DEVICEID_MATCH_1_0" bit="0" size="16" desc="Read-write. Reset: 0000h. DeviceID Match. This value is compared with the masked (filtered) value of the incoming DeviceID of the transaction to decide to count the corresponding event. The event is counted if DEVICEID_MATCH_1_0 is exactly equal to the masked incoming DeviceID. The event is not counted if they are not equal." />
    </register>

    <!-- page 343 -->

    <register name="IOMMU_MMIO_DEVICEID_MATCH_BANK_1_CNT_0_1" type="mmio" bar="IOMMUBAR" offset="0x41024" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVICEID_MATCH_BANK_1_CNT_0_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="DEVICEID_MASK_1_0" bit="0" size="16" desc="Read-write. Reset: 0000h. DeviceID Mask. This bit-mask is ANDed with the DeviceID of the transaction to decide to count the corresponding event." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_0_0" type="mmio" bar="IOMMUBAR" offset="0x41028" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_0_0. Read-write. Reset: 0000_0000h.">
      <field name="EVENT_NOTE_1_0_LO" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Event Note (bits[31:0]). When IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_0_1[CERE_1_0] == 1 and the corresponding counter is incremented and wraps to zero, EVENT_NOTE_1_0[51:0] is reported in the EVENT_COUNTER_ZERO event log entry. EVENT_NOTE_1_0[51:0] = {EVENT_NOTE_1_0_LO,IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_0_ 1[EVENT_NOTE_1_0_HI]}" />
    </register>
    <register name="IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_0_1" type="mmio" bar="IOMMUBAR" offset="0x4102C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_0_1. Read-write. Reset: 0000_0000h.">
      <field name="CERE_1_0" bit="31" size="1" desc="Read-write. Reset: 0. 0=No event report when counter wraps to zero. 1=IOMMU Writes an EVENT_COUNTER_ZERO event log entry when the counter wraps to zero. Description: Counter Event Report Enable. The counter-wrap event is treated like any other event. SOFTWARE NOTE: The counter-wrap event is delivered promptly but there is no defined latency expectation." />
      <!-- Bits 30:20 reserved. -->
      <field name="EVENT_NOTE_1_0_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Event Note (bits[51:32]). When CERE_1_0 == 1 and the corresponding counter is incremented and wraps to zero, EVENT_NOTE_1_0[51:0] is reported in the EVENT_COUNTER_ZERO event log entry. See also IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_0_0." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_BANK_1_CNT_1_0" type="mmio" bar="IOMMUBAR" offset="0x41100" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_1_CNT_1_0. Read-write. Reset: 0000_0000h.">
      <field name="ICOUNTER_1_1_LO" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Reports the counter value (bits[31:0]). The counter counts up continuously, wrapping at the maximum value. There is no overflow indicator." />
    </register>

    <!-- page 344 -->

    <register name="IOMMU_MMIO_COUNTER_BANK_1_CNT_1_1" type="mmio" bar="IOMMUBAR" offset="0x41104" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_1_CNT_1_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="ICOUNTER_1_1_HI" bit="0" size="16" desc="Read-write. Reset: 0000h. Reports the counter value (bits[47:32]). The counter counts up continuously, wrapping at the maximum value. There is no overflow indicator. See also IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_1_CNT_1_0." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_SRC_BANK_1_CNT_1_0" type="mmio" bar="IOMMUBAR" offset="0x41108" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_SRC_BANK_1_CNT_1_0. Read-write. Reset: 0000_0000h.">
      <field name="CAC_1_1" bit="31" size="1" desc="Read-write. Reset: 0. 0=Architectural counter input group. 1=Custom input group. Counter source architectural or custom." />
      <field name="COUNT_UNITS_1_1" bit="30" size="1" desc="Read-write. Reset: 0. 0=Counter counts events (level). 1=Counter counts clocks (edges). Count Units." />
      <!-- Bits 29:8 reserved. -->
      <field name="CSOURCE_1_1" bit="0" size="8" desc="Read-write. Reset: 00h. Counter source. Selects event counter input from the choices provided." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_SRC_BANK_1_CNT_1_1" type="mmio" bar="IOMMUBAR" offset="0x4110C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_SRC_BANK_1_CNT_1_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_1_0" type="mmio" bar="IOMMUBAR" offset="0x41110" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_1_0. Read-write. Reset: 0000_0000h.">
      <field name="PASMEN_1_1" bit="31" size="1" desc="Read-write. Reset: 0. 0=PASID is ignored. 1=Filtered PASID must match to count an event. PASID Match enable. An event with no PASID tag is only counted when PASMEN_1_1 == 0." />
      <!-- Bits 30:16 reserved. -->
      <field name="PASID_MATCH_1_1" bit="0" size="16" desc="Read-write. Reset: 0000h. PASID match. This value is compared with the masked (filtered) value of the incoming PASID of the transaction to decide to count the corresponding event. The event is counted if PASID_MATCH_1_1 is exactly equal to the masked incoming PASID. The event is not counted if they are not equal." />
    </register>
    <register name="IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_1_1" type="mmio" bar="IOMMUBAR" offset="0x41114" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_1_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="PASID_MASK_1_1" bit="0" size="16" desc="Read-write. Reset: 0000h. PASID Mask. This bit-mask is ANDed with the PASID of the transaction to decide to count the corresponding event." />
    </register>

    <!-- page 345 -->

    <register name="IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_1_0" type="mmio" bar="IOMMUBAR" offset="0x41118" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_1_0. Read-write. Reset: 0000_0000h.">
      <field name="DOMMEN_1_1" bit="31" size="1" desc="Read-write. Reset: 0. 0=Domain is ignored. 1=Filtered Domain must match to count an event. Domain Match enable." />
      <!-- Bits 30:16 reserved. -->
      <field name="DOMAIN_MATCH_1_1" bit="0" size="16" desc="Read-write. Reset: 0000h. Domain Match. This value is compared with the masked (filtered) value of the incoming Domain of the transaction to decide to count the corresponding event. The event is counted if DOMAIN_MATCH_1_1 is exactly equal to the masked incoming Domain. The event is not counted if they are not equal." />
    </register>
    <register name="IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_1_1" type="mmio" bar="IOMMUBAR" offset="0x4111C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_1_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="DOMAIN_MASK_1_1" bit="0" size="16" desc="Read-write. Reset: 0000h. Domain Mask. This bit-mask is ANDed with the Domain of the transaction to decide to count the corresponding event." />
    </register>
    <register name="IOMMU_MMIO_DEVICEID_MATCH_BANK_1_CNT_1_0" type="mmio" bar="IOMMUBAR" offset="0x41120" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVICEID_MATCH_BANK_1_CNT_1_0. Read-write. Reset: 0000_0000h.">
      <field name="DIDMEN_1_1" bit="31" size="1" desc="Read-write. Reset: 0. 0=DeviceID is ignored. 1=Filtered DeviceID must match to count an event. DeviceID Match enable." />
      <!-- Bits 30:16 reserved. -->
      <field name="DEVICEID_MATCH_1_1" bit="0" size="16" desc="Read-write. Reset: 0000h. DeviceID Match. This value is compared with the masked (filtered) value of the incoming DeviceID of the transaction to decide to count the corresponding event. The event is counted if DEVICEID_MATCH_1_1 is exactly equal to the masked incoming DeviceID. The event is not counted if they are not equal." />
    </register>
    <register name="IOMMU_MMIO_DEVICEID_MATCH_BANK_1_CNT_1_1" type="mmio" bar="IOMMUBAR" offset="0x41124" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVICEID_MATCH_BANK_1_CNT_1_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="DEVICEID_MASK_1_1" bit="0" size="16" desc="Read-write. Reset: 0000h. DeviceID Mask. This bit-mask is ANDed with the DeviceID of the transaction to decide to count the corresponding event." />
    </register>

    <!-- page 346 -->

    <register name="IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_1_0" type="mmio" bar="IOMMUBAR" offset="0x41128" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_1_0. Read-write. Reset: 0000_0000h.">
      <field name="EVENT_NOTE_1_1_LO" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Event Note (bits[31:0]). When IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_1_1[CERE_1_1] == 1 and the corresponding counter is incremented and wraps to zero, EVENT_NOTE_1_1[51:0] is reported in the EVENT_COUNTER_ZERO event log entry. EVENT_NOTE_1_1[51:0] = {EVENT_NOTE_1_1_LO,IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_1_ 1[EVENT_NOTE_1_1_HI]}" />
    </register>
    <register name="IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_1_1" type="mmio" bar="IOMMUBAR" offset="0x4112C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_1_1. Read-write. Reset: 0000_0000h.">
      <field name="CERE_1_1" bit="31" size="1" desc="Read-write. Reset: 0. 0=No event report when counter wraps to zero. 1=IOMMU Writes an EVENT_COUNTER_ZERO event log entry when the counter wraps to zero. Description: Counter Event Report Enable. The counter-wrap event is treated like any other event. SOFTWARE NOTE: The counter-wrap event is delivered promptly but there is no defined latency expectation." />
      <!-- Bits 30:20 reserved. -->
      <field name="EVENT_NOTE_1_1_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Event Note (bits[51:32]). When CERE_1_1 == 1 and the corresponding counter is incremented and wraps to zero, EVENT_NOTE_1_1[51:0] is reported in the EVENT_COUNTER_ZERO event log entry. See also IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_1_0." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_BANK_1_CNT_2_0" type="mmio" bar="IOMMUBAR" offset="0x41200" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_1_CNT_2_0. Read-write. Reset: 0000_0000h.">
      <field name="ICOUNTER_1_2_LO" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Reports the counter value (bits[31:0]). The counter counts up continuously, wrapping at the maximum value. There is no overflow indicator." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_BANK_1_CNT_2_1" type="mmio" bar="IOMMUBAR" offset="0x41204" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_1_CNT_2_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="ICOUNTER_1_2_HI" bit="0" size="16" desc="Read-write. Reset: 0000h. Reports the counter value (bits[47:32]). The counter counts up continuously, wrapping at the maximum value. There is no overflow indicator. See also IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_1_CNT_2_0." />
    </register>

    <!-- page 347 -->

    <register name="IOMMU_MMIO_COUNTER_SRC_BANK_1_CNT_2_0" type="mmio" bar="IOMMUBAR" offset="0x41208" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_SRC_BANK_1_CNT_2_0. Read-write. Reset: 0000_0000h.">
      <field name="CAC_1_2" bit="31" size="1" desc="Read-write. Reset: 0. 0=Architectural counter input group. 1=Custom input group. Counter source architectural or custom." />
      <field name="COUNT_UNITS_1_2" bit="30" size="1" desc="Read-write. Reset: 0. 0=Counter counts events (level). 1=Counter counts clocks (edges). Count Units." />
      <!-- Bits 29:8 reserved. -->
      <field name="CSOURCE_1_2" bit="0" size="8" desc="Read-write. Reset: 00h. Counter source. Selects event counter input from the choices provided." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_SRC_BANK_1_CNT_2_1" type="mmio" bar="IOMMUBAR" offset="0x4120C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_SRC_BANK_1_CNT_2_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_2_0" type="mmio" bar="IOMMUBAR" offset="0x41210" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_2_0. Read-write. Reset: 0000_0000h.">
      <field name="PASMEN_1_2" bit="31" size="1" desc="Read-write. Reset: 0. 0=PASID is ignored. 1=Filtered PASID must match to count an event. PASID Match enable. An event with no PASID tag is only counted when PASMEN_1_2 == 0." />
      <!-- Bits 30:16 reserved. -->
      <field name="PASID_MATCH_1_2" bit="0" size="16" desc="Read-write. Reset: 0000h. PASID match. This value is compared with the masked (filtered) value of the incoming PASID of the transaction to decide to count the corresponding event. The event is counted if PASID_MATCH_1_2 is exactly equal to the masked incoming PASID. The event is not counted if they are not equal." />
    </register>
    <register name="IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_2_1" type="mmio" bar="IOMMUBAR" offset="0x41214" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_2_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="PASID_MASK_1_2" bit="0" size="16" desc="Read-write. Reset: 0000h. PASID Mask. This bit-mask is ANDed with the PASID of the transaction to decide to count the corresponding event." />
    </register>

    <!-- page 348 -->

    <register name="IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_2_0" type="mmio" bar="IOMMUBAR" offset="0x41218" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_2_0. Read-write. Reset: 0000_0000h.">
      <field name="DOMMEN_1_2" bit="31" size="1" desc="Read-write. Reset: 0. 0=Domain is ignored. 1=Filtered Domain must match to count an event.  Domain Match enable." />
      <!-- Bits 30:16 reserved. -->
      <field name="DOMAIN_MATCH_1_2" bit="0" size="16" desc="Read-write. Reset: 0000h. Domain Match. This value is compared with the masked (filtered) value of the incoming Domain of the transaction to decide to count the corresponding event. The event is counted if DOMAIN_MATCH_1_2 is exactly equal to the masked incoming Domain. The event is not counted if they are not equal." />
    </register>
    <register name="IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_2_1" type="mmio" bar="IOMMUBAR" offset="0x4121C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_2_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="DOMAIN_MASK_1_2" bit="0" size="16" desc="Read-write. Reset: 0000h. Domain Mask. This bit-mask is ANDed with the Domain of the transaction to decide to count the corresponding event." />
    </register>
    <register name="IOMMU_MMIO_DEVICEID_MATCH_BANK_1_CNT_2_0" type="mmio" bar="IOMMUBAR" offset="0x41220" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVICEID_MATCH_BANK_1_CNT_2_0. Read-write. Reset: 0000_0000h.">
      <field name="DIDMEN_1_2" bit="31" size="1" desc="Read-write. Reset: 0. 0=DeviceID is ignored. 1=Filtered DeviceID must match to count an event. DeviceID Match enable." />
      <!-- Bits 30:16 reserved. -->
      <field name="DEVICEID_MATCH_1_2" bit="0" size="16" desc="Read-write. Reset: 0000h. DeviceID Match. This value is compared with the masked (filtered) value of the incoming DeviceID of the transaction to decide to count the corresponding event. The event is counted if DEVICEID_MATCH_1_2 is exactly equal to the masked incoming DeviceID. The event is not counted if they are not equal." />
    </register>
    <register name="IOMMU_MMIO_DEVICEID_MATCH_BANK_1_CNT_2_1" type="mmio" bar="IOMMUBAR" offset="0x41224" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVICEID_MATCH_BANK_1_CNT_2_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="DEVICEID_MASK_1_2" bit="0" size="16" desc="Read-write. Reset: 0000h. DeviceID Mask. This bit-mask is ANDed with the DeviceID of the transaction to decide to count the corresponding event." />
    </register>

    <!-- page 349 -->

    <register name="IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_2_0" type="mmio" bar="IOMMUBAR" offset="0x41228" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_2_0. Read-write. Reset: 0000_0000h.">
      <field name="EVENT_NOTE_1_2_LO" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Event Note (bits[31:0]). When IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_2_1[CERE_1_2] == 1 and the corresponding counter is incremented and wraps to zero, EVENT_NOTE_1_2[51:0] is reported in the EVENT_COUNTER_ZERO event log entry. EVENT_NOTE_1_2[51:0] = {EVENT_NOTE_1_2_LO,IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_2_ 1[EVENT_NOTE_1_2_HI]}" />
    </register>
    <register name="IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_2_1" type="mmio" bar="IOMMUBAR" offset="0x4122C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_2_1. Read-write. Reset: 0000_0000h.">
      <field name="CERE_1_2" bit="31" size="1" desc="Read-write. Reset: 0. 0=No event report when counter wraps to zero. 1=IOMMU Writes an EVENT_COUNTER_ZERO event log entry when the counter wraps to zero. Description: Counter Event Report Enable. The counter-wrap event is treated like any other event. SOFTWARE NOTE: The counter-wrap event is delivered promptly but there is no defined latency expectation." />
      <!-- Bits 30:20 reserved. -->
      <field name="EVENT_NOTE_1_2_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Event Note (bits[51:32]). When CERE_1_2 == 1 and the corresponding counter is incremented and wraps to zero, EVENT_NOTE_1_2[51:0] is reported in the EVENT_COUNTER_ZERO event log entry. See also IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_2_0." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_BANK_1_CNT_3_0" type="mmio" bar="IOMMUBAR" offset="0x41300" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_1_CNT_3_0. Read-write. Reset: 0000_0000h.">
      <field name="ICOUNTER_1_3_LO" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Reports the counter value (bits[31:0]). The counter counts up continuously, wrapping at the maximum value. There is no overflow indicator." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_BANK_1_CNT_3_1" type="mmio" bar="IOMMUBAR" offset="0x41304" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_1_CNT_3_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="ICOUNTER_1_3_HI" bit="0" size="16" desc="Read-write. Reset: 0000h. Reports the counter value (bits[47:32]). The counter counts up continuously, wrapping at the maximum value. There is no overflow indicator. See also IOMMUMMIO::IOMMU_MMIO_COUNTER_BANK_1_CNT_3_0." />
    </register>

    <!-- page 350 -->

    <register name="IOMMU_MMIO_COUNTER_SRC_BANK_1_CNT_3_0" type="mmio" bar="IOMMUBAR" offset="0x41308" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_SRC_BANK_1_CNT_3_0. Read-write. Reset: 0000_0000h.">
      <field name="CAC_1_3" bit="31" size="1" desc="Read-write. Reset: 0. 0=Architectural counter input group. 1=Custom input group. Counter source architectural or custom." />
      <field name="COUNT_UNITS_1_3" bit="30" size="1" desc="Read-write. Reset: 0. 0=Counter counts events (level). 1=Counter counts clocks (edges). Count Units." />
      <!-- Bits 29:8 reserved. -->
      <field name="CSOURCE_1_3" bit="0" size="8" desc="Read-write. Reset: 00h. Counter source. Selects event counter input from the choices provided." />
    </register>
    <register name="IOMMU_MMIO_COUNTER_SRC_BANK_1_CNT_3_1" type="mmio" bar="IOMMUBAR" offset="0x4130C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_SRC_BANK_1_CNT_3_1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_3_0" type="mmio" bar="IOMMUBAR" offset="0x41310" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_3_0. Read-write. Reset: 0000_0000h.">
      <field name="PASMEN_1_3" bit="31" size="1" desc="Read-write. Reset: 0. 0=PASID is ignored. 1=Filtered PASID must match to count an event. PASID Match enable. An event with no PASID tag is only counted when PASMEN_1_3 == 0." />
      <!-- Bits 30:16 reserved. -->
      <field name="PASID_MATCH_1_3" bit="0" size="16" desc="Read-write. Reset: 0000h. PASID match. This value is compared with the masked (filtered) value of the incoming PASID of the transaction to decide to count the corresponding event. The event is counted if PASID_MATCH_1_3 is exactly equal to the masked incoming PASID. The event is not counted if they are not equal." />
    </register>
    <register name="IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_3_1" type="mmio" bar="IOMMUBAR" offset="0x41314" size="4" desc="IOMMUMMIO::IOMMU_MMIO_PASID_MATCH_BANK_1_CNT_3_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="PASID_MASK_1_3" bit="0" size="16" desc="Read-write. Reset: 0000h. PASID Mask. This bit-mask is ANDed with the PASID of the transaction to decide to count the corresponding event." />
    </register>
    <register name="IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_3_0" type="mmio" bar="IOMMUBAR" offset="0x41318" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_3_0. Read-write. Reset: 0000_0000h.">
      <field name="DOMMEN_1_3" bit="31" size="1" desc="Read-write. Reset: 0. 0=Domain is ignored. 1=Filtered Domain must match to count an event. Domain Match enable." />
      <!-- Bits 30:16 reserved. -->
      <field name="DOMAIN_MATCH_1_3" bit="0" size="16" desc="Read-write. Reset: 0000h. Domain Match. This value is compared with the masked (filtered) value of the incoming Domain of the transaction to decide to count the corresponding event. The event is counted if DOMAIN_MATCH_1_3 is exactly equal to the masked incoming Domain. The event is not counted   if they are not equal." />
    </register>

    <!-- page 351 -->

    <register name="IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_3_1" type="mmio" bar="IOMMUBAR" offset="0x4131C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DOMAIN_MATCH_BANK_1_CNT_3_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="DOMAIN_MASK_1_3" bit="0" size="16" desc="Read-write. Reset: 0000h. Domain Mask. This bit-mask is ANDed with the Domain of the transaction to decide to count the corresponding event." />
    </register>
    <register name="IOMMU_MMIO_DEVICEID_MATCH_BANK_1_CNT_3_0" type="mmio" bar="IOMMUBAR" offset="0x41320" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVICEID_MATCH_BANK_1_CNT_3_0. Read-write. Reset: 0000_0000h.">
      <field name="DIDMEN_1_3" bit="31" size="1" desc="Read-write. Reset: 0. 0=DeviceID is ignored. 1=Filtered DeviceID must match to count an event. DeviceID Match enable." />
      <!-- Bits 30:16 reserved. -->
      <field name="DEVICEID_MATCH_1_3" bit="0" size="16" desc="Read-write. Reset: 0000h. DeviceID Match. This value is compared with the masked (filtered) value of the incoming DeviceID of the transaction to decide to count the corresponding event. The event is counted if DEVICEID_MATCH_1_3 is exactly equal to the masked incoming DeviceID. The event is not counted if they are not equal." />
    </register>
    <register name="IOMMU_MMIO_DEVICEID_MATCH_BANK_1_CNT_3_1" type="mmio" bar="IOMMUBAR" offset="0x41324" size="4" desc="IOMMUMMIO::IOMMU_MMIO_DEVICEID_MATCH_BANK_1_CNT_3_1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="DEVICEID_MASK_1_3" bit="0" size="16" desc="Read-write. Reset: 0000h. DeviceID Mask. This bit-mask is ANDed with the DeviceID of the transaction to decide to count the corresponding event." />
    </register>

    <!-- page 352 -->

    <register name="IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_3_0" type="mmio" bar="IOMMUBAR" offset="0x41328" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_3_0. Read-write. Reset: 0000_0000h.">
      <field name="EVENT_NOTE_1_3_LO" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Event Note (bits[31:0]). When IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_3_1[CERE_1_3] == 1 and the   corresponding counter is incremented and wraps to zero, EVENT_NOTE_1_3[51:0] is reported in the EVENT_COUNTER_ZERO event log entry. EVENT_NOTE_1_3[51:0] = {EVENT_NOTE_1_3_LO,IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_3_ 1[EVENT_NOTE_1_3_HI]}" />
    </register>
    <register name="IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_3_1" type="mmio" bar="IOMMUBAR" offset="0x4132C" size="4" desc="IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_3_1. Read-write. Reset: 0000_0000h.">
      <field name="CERE_1_3" bit="31" size="1" desc="Read-write. Reset: 0. 0=No event report when counter wraps to zero. 1=IOMMU Writes an EVENT_COUNTER_ZERO event log entry when the counter wraps to zero. Description: Counter Event Report Enable. The counter-wrap event is treated like any other event. SOFTWARE NOTE: The counter-wrap event is delivered promptly but there is no defined latency expectation." />
      <!-- Bits 30:20 reserved. -->
      <field name="EVENT_NOTE_1_3_HI" bit="0" size="20" desc="Read-write. Reset: 0_0000h. Event Note (bits[51:32]). When CERE_1_3 == 1 and the corresponding counter is incremented and wraps to zero, EVENT_NOTE_1_3[51:0] is reported in the EVENT_COUNTER_ZERO event log entry. See also IOMMUMMIO::IOMMU_MMIO_COUNTER_RPT_BANK_1_CNT_3_0." />
    </register>

    <!-- 9.2.1.1 Registers -->

    <!-- page 361 -->

    <register name="DmaCh0" type="io" port="0x0000" size="2" desc="Dma_Ch 0. Read-write. Reset: 0000h.">
      <field name="DmaCh0" bit="0" size="16" desc="Read-write. Reset: 0000h. DMA1 channel 0 base and current address." />
    </register>
    <register name="DmaCh1" type="io" port="0x0002" size="2" desc="Dma_Ch 1. Read-write. Reset: 0000h.">
      <field name="DmaCh1" bit="0" size="16" desc="Read-write. Reset: 0000h. DMA1 channel 1 base and current address." />
    </register>
    <register name="DmaCh2" type="io" port="0x0004" size="2" desc="Dma_Ch 2. Read-write. Reset: 0000h.">
      <field name="DmaCh2" bit="0" size="16" desc="Read-write. Reset: 0000h. DMA1 channel 2 base and current address." />
    </register>
    <register name="DmaCh3" type="io" port="0x0006" size="2" desc="Dma_Ch 3. Read-write. Reset: 0000h.">
      <field name="DmaCh3" bit="0" size="16" desc="Read-write. Reset: 0000h. DMA1 channel 3 base and current address." />
    </register>

    <!-- page 362 -->

    <register name="DmaStat" type="io" port="0x0008" size="1" desc="Dma_Status. Read-write. Reset: 00h.">
      <field name="DmaStatus" bit="0" size="8" desc="Read-write. Reset: 00h. Specifies the DMA status register for channels[3:0] for reads and specifies the DMA control register for channels[3:0] for writes." />
    </register>
    <register name="DmaWriteRequest" type="io" port="0x0009" size="1" desc="Dma_WriteRequest. Read-write. Reset: 00h.">
      <field name="DmaWriteRequest" bit="0" size="8" desc="Read-write. Reset: 00h. Request register." />
    </register>
    <register name="DmaWriteMask" type="io" port="0x000A" size="1" desc="Dma_WriteMask. Read-write. Reset: 00h.">
      <field name="DmaWriteMask" bit="0" size="8" desc="Read-write. Reset: 00h. DMA channel mask register." />
    </register>
    <register name="DmaWriteMode" type="io" port="0x000B" size="1" desc="Dma_WriteMode. Read-write. Reset: 00h.">
      <field name="DmaWriteMode" bit="0" size="8" desc="Read-write. Reset: 00h. DMA mode register." />
    </register>
    <register name="DmaClear" type="io" port="0x000C" size="1" desc="Dma_Clear. Read-write. Reset: 00h.">
      <field name="DmaClear" bit="0" size="8" desc="Read-write. Reset: 00h. Channel[3:0] DMA clear byte pointer." />
    </register>
    <register name="DmaMasClr" type="io" port="0x000D" size="1" desc="Dma_MasterClr. Read-write. Reset: 00h. Dma_MasterClr register">
      <field name="DmaMasterClr" bit="0" size="8" desc="Read-write. Reset: 00h. Write: Channel[3:0] master clear register. Read: Intermediate register." />
    </register>
    <register name="DmaClrMask" type="io" port="0x000E" size="1" desc="Dma_ClrMask. Read-write. Reset: 00h.">
      <field name="DmaClrmask" bit="0" size="8" desc="Read-write. Reset: 00h. Channel[3:0] DMA clear mask." />
    </register>
    <register name="DmaAllMask" type="io" port="0x000F" size="1" desc="Dma_AllMask. Read-write. Reset: 00h.">
      <field name="DmaAllMask" bit="0" size="8" desc="Read-write. Reset: 00h. General mask register." />
    </register>

    <!-- page 363 -->

    <register name="IntrCntrl1Reg1" type="io" port="0x0020" size="1" desc="IntrCntrl1Reg1. Read-write. Reset: 00h.">
      <field name="IntrCntrl1Reg1" bit="0" size="8" desc="Read-write. Reset: 00h. IRQ[7:0] status and control. Read: IRR, ISR. Write: ICW1, OCW2, OCW3." />
    </register>
    <register name="IntrCntrl1Reg2" type="io" port="0x0021" size="1" desc="IntrCntrl1Reg2. Read-write. Reset: 00h.">
      <field name="IntrCntrl1Reg2" bit="0" size="8" desc="Read-write. Reset: 00h. IRQ[7:0] status and control. Read: IMR. Write: ICW2, ICW3, ICW4, OCW1." />
    </register>
    <register name="IMCRIndex" type="io" port="0x0022" size="1" desc="IMCR_Index. Read-write. Reset: 00h.">
      <field name="ImcrIndex" bit="0" size="8" desc="Read-write. Reset: 00h. Index port for IMCR register. See FCH::IO::IMCRData." />
    </register>
    <register name="IMCRData" type="io" port="0x0023" size="1" desc="IMCR_Data. Read-write. Reset: 00h.">
      <field name="ImcrData" bit="0" size="8" desc="Read-write. Reset: 00h. Data port for IMCR register. The actual IMCR register is located at index 70h and it is at bit[0]." />
    </register>
    <register name="SmnIndex" type="pcicfg" device="ROOT" offset="0x0060" size="4" desc="IMCR_Index. Read-write. Reset: 00h.">
      <field name="SmnIndex" bit="0" size="32" desc="Read-write. Reset: 00h. Index port for IMCR register. See FCH::IO::IMCRData." />
    </register>
    <register name="SmnData" type="pcicfg" device="ROOT" offset="0x0064" size="4" desc="IMCR_Data. Read-write. Reset: 00h.">
      <field name="SmnData" bit="0" size="32" desc="Read-write. Reset: 00h. Data port for IMCR register. The actual IMCR register is located at index 70h and it is at bit[0]." />
    </register>
    <register name="TimerCh0" type="io" port="0x0040" size="1" desc="TimerCh0. Read-write. Reset: 00h.">
      <field name="TimerCh0" bit="0" size="8" desc="Read-write. Reset: 00h. 8254 Timer 1 Counter 0 Data Port." />
    </register>
    <register name="TimerCh1" type="io" port="0x0041" size="1" desc="TimerCh1. Read-write. Reset: 00h.">
      <field name="TimerCh1" bit="0" size="8" desc="Read-write. Reset: 00h. 8254 Timer 1 Counter 1 Data Port." />
    </register>
    <register name="TimerCh2" type="io" port="0x0042" size="1" desc="TimerCh2. Read-write. Reset: 00h.">
      <field name="TimerCh2" bit="0" size="8" desc="Read-write. Reset: 00h. 8254 Timer 1 Counter 2 Data Port." />
    </register>

    <!-- page 364 -->

    <register name="Tmr1CntrlWord" type="io" port="0x0043" size="1" desc="Tmr1CntrlWord. Write-only. Reset: 00h. This is the control register for 8254 timer 1. If a counter is programmed to read or write two-byte counts, the following precaution applies: Software must not transfer control between writing the first and second byte to another routine which also writes into that same counter; otherwise, the counter is be loaded with an incorrect value. The count must always be completely loaded with both bytes. Reads of this register always returns 0xFF.">
      <field name="CounterSelect" bit="6" size="2" desc="Write-only. Reset: 0h." />
      <field name="CommandSelect" bit="4" size="2" desc="Write-only. Reset: 0h." />
      <field name="ModeSelect" bit="1" size="3" desc="Write-only. Reset: 0h." />
      <field name="CntDownSelect" bit="0" size="1" desc="Write-only. Reset: 0. 0=Binary countdown. 1=BCD countdown." />
    </register>
    <register name="NmiStat" type="io" port="0x0061" size="1" desc="Nmi Status.">
      <field name="ParityErrNmi" bit="7" size="1" desc="Read-only. Reset: X. NMI is caused by parity error (either PERR# or SERR#)." />
      <field name="IoChkNmi" bit="6" size="1" desc="Read-only. Reset: X. NMI is triggered by serial IOCHK." />
      <field name="SpkrClk" bit="5" size="1" desc="Read-only. Reset: X. The output of 8254 timer counter 2." />
      <field name="RefClk" bit="4" size="1" desc="Read-only. Reset: X. The output of 8254 timer counter 1." />
      <field name="IoChkNmiEn" bit="3" size="1" desc="Read-write. Reset: 1. 0=Enable IoChk to NMI generation. 1=Disable IoChk to NMI generation." />
      <field name="ParityErrNmiEn" bit="2" size="1" desc="Read-write. Reset: 1. 0=Enable Parity Error to NMI generation (from SERR# or PERR#). 1=Disable Parity Error to NMI generation and clear bit[7]." />
      <field name="SpkrTmrEnable" bit="1" size="1" desc="Read-write. Reset: 0. 0=Speaker timer off. 1=Speaker timer on." />
      <field name="SpkrEnable" bit="0" size="1" desc="Read-write. Reset: 0. 0=Disable counter 2. 1=Enable counter 2." />
    </register>
    <register name="RtcAddrPortNmiMask" type="io" port="0x0070" size="1" desc="RtcAddrPort and NmiMask. Reset: 00h.">
      <field name="NmiMask" bit="7" size="1" desc="Write-only. Reset: 0. 0=NMI enabled. 1=NMI masked." />
      <field name="RtcAddrPort" bit="0" size="7" desc="RTC Address Port. Read-write. Reset: 00h. This is used with either the internal RTC or external RTC. This port specifies the index to access RTC time registers and the CMOS RAM space. FCH::IO::RTCA[DV0] should be programmed first to select bank when accessing the CMOS RAM space. See FCH::IO::RTCSeconds." />
    </register>
    <register name="RtcDataPort" type="io" port="0x0071" size="1" desc="RtcDataPort. Read-write. Reset: 00h.">
      <field name="RtcDataPort" bit="0" size="8" desc="RTC Data Port. Read-write. Reset: 00h. This is used with either the internal RTC or external RTC in conjunction with FCH::IO::RtcAddrPortNmiMask." />
    </register>

    <!-- page 365 -->

    <register name="AltRTCAddrPort" type="io" port="0x0072" size="1" desc="Alternate RTC AddrPort. Read-write. Reset: 00h.">
      <field name="AlternatRTCAddrPort" bit="0" size="8" desc="Read-write. Reset: 00h. This is used with the internal RTC. This port allows the user to specify the full 8-bit address (instead of bank0/bank1 indexing) to access the 256 bytes of RTC RAM." />
    </register>
    <register name="AltRTCDataPort" type="io" port="0x0073" size="1" desc="Alternate RTC DataPort. Read-write. Reset: 00h.">
      <field name="AlternatRTCDataPort" bit="0" size="8" desc="Read-write. Reset: 00h. This is used with the internal RTC in conjunction with FCH::IO::AltRTCAddrPort." />
    </register>
    <register name="RTCSeconds" type="io" port="0x00073" size="1" desc="RTC Seconds. Read-write. Precondition (data port): AltRTCAddrPort = x00.">
      <field name="Seconds" bit="0" size="8" desc="Read-write. Reset: XXh. BCD format. The value range for this register is 00 through 59. If (FCH::IO::RTCB[SET] == 1), this register is programmed by software and hardware updating is disabled. If (FCH::IO::RTCB[SET] == 0), this register is updated by the RTC logic once per second. The value of this register is undefined/non-deterministic when powered up for the first time." />
    </register>
    <register name="RtcSecAlarm" type="io" port="0x00073" size="1" desc="RTC Seconds Alarm. Read-write. Precondition (data port): AltRTCAddrPort = x01.">
      <field name="SecondsAlarm" bit="0" size="8" desc="Seconds Alarm. Read-write. Reset: XXh. BCD format. If (FCH::IO::RTCB[SET] == 1), the Seconds Alarm register never matches FCH::IO::RTCSeconds. Else, if (bits[7:6] == 11b) the RTC Seconds Alarm register always matches RTC Seconds register and causes an RTC alarm event to be generated once per second. See FCH::IO::RTCC[AF]. The value of this register is undefined/non-deterministic when power up first time." />
    </register>
    <register name="RTCMinutes" type="io" port="0x00073" size="1" desc="RTC Minutes. Read-write. Precondition (data port): AltRTCAddrPort = x02.">
      <field name="Minutes" bit="0" size="8" desc="Read-write. Reset: XXh. BCD format. The value range for this register is 00 through 59. If (FCH::IO::RTCB[SET] == 1), this register is programmed by software and hardware updating is disabled. If (FCH::IO::RTCB[SET] == 0), this register is updated by the RTC logic, once per second. The value of this register is undefined/non-deterministic when powered up for the first time." />
    </register>

    <!-- page 366 -->

    <register name="RTCMinutesAlarm" type="io" port="0x00073" size="1" desc="RTC Minutes Alarm. Read-write. Precondition (data port): AltRTCAddrPort = x03.">
      <field name="MinutesAlarm" bit="0" size="8" desc="Minutes Alarm. Read-write. Reset: XXh. BCD format. If (FCH::IO::RTCB[SET] == 1), the RTC Minutes Alarm register never matches FCH::IO::RTCMinutes. Else, if (bits[7:6] == 11b), the RTC Minutes Alarm register always matches RTC Minutes register and causes an RTC alarm event to be generated once per minute. See FCH::IO::RTCC[AF]. The value of this register is undefined/non-deterministic when powered up for the first time." />
    </register>
    <register name="RTCHours" type="io" port="0x00073" size="1" desc="RTC Hours. Read-write. Precondition (data port): AltRTCAddrPort = x04.">
      <field name="Hours" bit="0" size="8" desc="Read-write. Reset: XXh. BCD format. The value range for this register is 00 through 23. If (FCH::IO::RTCB[SET] == 1), this register can be set by software and hardware updating is disabled. If (FCH::IO::RTCB[SET] == 0), this register is updated by the RTC logic once per second. The value of this register is undefined/non-deterministic when powered up for the first time." />
    </register>
    <register name="RTCHoursAlarm" type="io" port="0x00073" size="1" desc="RTC Hours Alarm. Read-write. Precondition (data port): AltRTCAddrPort = x05.">
      <field name="HoursAlarm" bit="0" size="8" desc="Hours Alarm. Read-write. Reset: XXh. BCD format. If (FCH::IO::RTCB[SET] == 1), the RTC Hours Alarm register never matches FCH::IO::RTCHours. Else, if (bits[7:6] == 11b) the RTC Hours Alarm register always matches with the RTC Hours register and causes an RTC alarm event to be generated once per hour. See FCH::IO::RTCC[AF]. The value of this register is undefined/non-deterministic when powered up for the first time." />
    </register>
    <register name="RTCDayofWeek" type="io" port="0x00073" size="1" desc="RTC Day of Week. Read-write. Precondition (data port): AltRTCAddrPort = x06.">
      <field name="DayOfWeek" bit="0" size="8" desc="Day of Week. Read-write. Reset: XXh. BCD format. The value range for this register is 01 through 07 (Sunday = 1). Leap year correction is performed by software. If (FCH::IO::RTCB[SET] == 1), this register is programmed by software and hardware updating is disabled. If (FCH::IO::RTCB[SET] == 0), this register is updated by hardware. The value of this register is undefined/non-deterministic when powered up for the first time." />
    </register>
    <register name="RTCDateofMonth" type="io" port="0x00073" size="1" desc="RTC Date of Month. Read-write. Precondition (data port): AltRTCAddrPort = x07.">
      <field name="DateOfMonth" bit="0" size="8" desc="Date of Month. Read-write. Reset: XXh. BCD format. The range is 01 through 31. Leap year correction is performed by software. If (FCH::IO::RTCB[SET] == 1), this register is programmed by software and hardware updating is disabled. If (FCH::IO::RTCB[SET] == 0), this register is updated by hardware. The value of this register is undefined/non-deterministic when powered up for the first time." />
    </register>
    <register name="RTCMonth" type="io" port="0x00073" size="1" desc="RTC Month. Read-write. Precondition (data port): AltRTCAddrPort = x08.">
      <field name="Month" bit="0" size="8" desc="Read-write. Reset: XXh. BCD format. The range is 01 through 12. Leap year correction is performed by software. If (FCH::IO::RTCB[SET] == 1), this register is programmed by software and hardware updating is disabled. If (FCH::IO::RTCB[SET] == 0), this register is updated by hardware. The value of this register is undefined/non-deterministic when powered up for the first time." />
    </register>

    <!-- page 367 -->

    <register name="RTCYear" type="io" port="0x00073" size="1" desc="RTC Year. Read-write. Precondition (data port): AltRTCAddrPort = x09.">
      <field name="Year" bit="0" size="8" desc="Read-write. Reset: XXh. BCD format. Range is 00 through 99. No leap year correction capability. Leap year correction must be done by software. If (FCH::IO::RTCB[SET] == 1), this register is programmed by software and hardware updating is disabled. If (FCH::IO::RTCB[SET] == 0), this register is updated by hardware. The value of this register is undefined/non-deterministic when powered up for the first time." />
    </register>
    <register name="RTCA" type="io" port="0x00073" size="1" desc="RTC Register A. Precondition (data port): AltRTCAddrPort = x0A.">
      <field name="UIP" bit="7" size="1" desc="Update In Progress. Read-only. Reset: X. 0=The update transfer does not occur for at least 244 us. 1=The update transfer occurs soon. If (FCH::IO::RTCB[SET] == 1), UIP is cleared. The value of this register is undefined/non-deterministic when powered up for the first time." />
      <!-- Bits 6:5 reserved. -->
      <field name="DV0" bit="4" size="1" desc="Bank Selection. Read-write. Reset: X. 0=Select bank 0 when accessing the RTC CMOS RAM space through FCH::IO::RtcAddrPortNmiMask and FCH::IO::RtcDataPort. 1=Select bank 1 when accessing the RTC CMOS RAM space through FCH::IO::RtcAddrPortNmiMask and FCH::IO::RtcDataPort. The FCH has an alternate way to access the RAM without the use of bank select bit. FCH::IO::AltRTCAddrPort and FCH::IO::AltRTCDataPort provides indexed access to the full 256 bytes of RAM. The value of this register is undefined/non-deterministic when powered up for the first time." />
      <field name="RS[3:0]" bit="0" size="4" desc="Rate Selection. Read-write. Reset: Xh. These four rate selection bits select one of the 13 taps on the 15- stage frequency divider or disable the divider output (flat output signal). The tap selected can be used to generate a periodic interrupt. See the following table for the frequency selection. The value of this register is undefined/non-deterministic when powered up for the first time." />
    </register>

    <!-- page 368 -->

    <register name="RTCB" type="io" port="0x00073" size="1" desc="RTC Register B. Read-write. Precondition (data port): AltRTCAddrPort = x0B.">
      <field name="SET" bit="7" size="1" desc="Set new time. Read-write. Reset: X. 0=The RTC time registers are updated every second. 1=No internal updating for RTC time registers occurs. The value of this register is undefined/non-deterministic when powered  up for the first time." />
      <field name="PIE" bit="6" size="1" desc="Periodic Interrupt Enable. Read-write. Reset: X. 1=Enable the FCH::IO::RTCC[PF] bit to assert the IRQ. The value of this register is undefined/non-deterministic when powered up for the first time." />
      <field name="AIE" bit="5" size="1" desc="Alarm Interrupt Enable. Read-write. Reset: X. 1=Enable the FCH::IO::RTCC[AF] bit to assert the IRQ. When the alarm time is written in the appropriate hours, minutes, and seconds alarm registers, the alarm interrupt is initiated at the specified time each day if AIE == 1. The value of this register is undefined/non-deterministic when powered up for the first time." />
      <field name="UIE" bit="4" size="1" desc="Update Ended Interrupt Enable. Read-write. Reset: X. 1=Enable the FCH::IO::RTCC[UF] bit to assert the IRQ. If [SET] == 1, UIE is cleared. The value of this register is undefined/non-deterministic when powered up for the first time." />
      <!-- Bits 3:2 reserved. -->
      <field name="HourMode" bit="1" size="1" desc="Read-write. Reset: X. 0=12 hour mode. 1=24 hour mode. The value of this register is undefined/non- deterministic when powered up for the first time." />
      <field name="DaylightSavingEnable" bit="0" size="1" desc="Read-write. Reset: X. Init: BIOS,0. 1=RTC daylight saving is enabled. The value of this register is undefined/non-deterministic when powered up for the first time." />
    </register>
    <register name="RTCC" type="io" port="0x00073" size="1" desc="RTC Register C. Read-only. Precondition (data port): AltRTCAddrPort = x0C.">
      <field name="IRQF" bit="7" size="1" desc="Interrupt Request Flag. Read-only. Reset: X. 1=The IRQ# pin is driven low. IRQF=(PF*PIE)+ (AF*AIE)+(UF*UIE). Reading RTC Register C clears the IRQF bit. The value of this register is undefined/non- deterministic when powered up for the first time." />
      <field name="PF" bit="6" size="1" desc="Periodic Interrupt Flag. Read-only. Reset: X. 1=An edge is detected on the selected tap (through RS3 to RS0) of the frequency divider. Reading RTC Register C clears PF bit. The value of this register is undefined/non- deterministic when powered up for the first time." />
      <field name="AF" bit="5" size="1" desc="Alarm Interrupt Flag. Read-only. Reset: X. 1=FCH::IO::RTCSeconds, FCH::IO::RTCMinutes, FCH::IO::RTCHours and FCH::IO::RTCDateofMonth match FCH::IO::RtcSecAlarm, FCH::IO::RTCMinutesAlarm, FCH::IO::RTCHoursAlarm, and FCH::IO::RTCDateAlarm respectively. Reading RTC Register C clears AF bit. The value of this register is undefined/non-deterministic when powered up for the first time." />
      <field name="UF" bit="4" size="1" desc="Update Ended Interrupt Flag. Read-only. Reset: X. 1=Update cycle complete. Reading RTC Register C clears UF. The value of this register is undefined/non-deterministic when powered up for the first time." />
      <!-- Bits 3:0 reserved. -->
    </register>
    <register name="RTCDateAlarm" type="io" port="0x00073" size="1" desc="RTC Date Alarm. Precondition (data port): AltRTCAddrPort = x0D.">
      <field name="VRT" bit="7" size="1" desc="Valid RAM and Time. Read-only. Reset: X. 0=RTC date, time, and CMOS RAM are invalid due to low RTC battery being monitored. 1=RTC date, time, and CMOS RAM are valid. See FCH::PM::VRT_T1 and FCH::PM::VRT_T2. The value of this register is undefined/non-deterministic when powered up for the first time." />
      <field name="ScratchBit" bit="6" size="1" desc="Read-write. Reset: X. Scratch bit.The value of this register is undefined/non-deterministic when powered up for the first time." />
      <field name="DateAlarm" bit="0" size="6" desc="Read-write. Reset: XXXXXXb. If (DateAlarm != 0), then DateAlarm is considered for alarm generation. DateAlarm is in BCD format. 0=DateAlarm is not compared for alarm generation. 1=DateAlarm is compared for alarm generation. The value of this register is undefined/non-deterministic when powered up for the first time." />
    </register>

    <!-- page 369 -->

    <register name="RTCAltCentury" type="io" port="0x00073" size="1" desc="RTC AltCentury. Read-write. Precondition (data port): AltRTCAddrPort = x32.">
      <field name="AltCentury" bit="0" size="8" desc="Read-write. Reset: XXh. BCD format. Leap year correction is performed by hardware. This register is accessed only when (FCH::IO::RTCA[DV0] == 0) and (FCH::PM::RTCCtl[CenturyEn] == 1). If (FCH::IO::RTCB[SET] == 1), this register is programmed by software and hardware updating is disabled. If (FCH::IO::RTCB[SET] == 0), this register is automatically updated by hardware every century. The value of this register is undefined/non-deterministic when powered up for the first time." />
    </register>
    <register name="RTCCentury" type="io" port="0x00073" size="1" desc="RTC Century. Read-write. Precondition (data port): AltRTCAddrPort = x48.">
      <field name="Century" bit="0" size="8" desc="Read-write. Reset: XXh. BCD format. Leap year correction is done through hardware. This register is accessed only when (FCH::IO::RTCA[DV0] == 1). If (FCH::IO::RTCB[SET] == 1), this register is programmed by software and hardware updating is disabled. If (FCH::IO::RTCB[SET] == 0), this register is automatically updated by hardware every century. The value of this register is undefined/non-deterministic when powered up for the first time." />
    </register>
    <register name="RTCExtRAMAddrPort" type="io" port="0x00073" size="1" desc="RTC Extended RAM Address Port. Read-write. Precondition (data port): AltRTCAddrPort = x50.">
      <!-- Bit 7 reserved. -->
      <field name="ExtendedRamAddrPort" bit="0" size="7" desc="Read-write. Reset: XXXXXXXb. Because only 7 address bits are used in FCH::IO::RtcAddrPortNmiMask[RtcAddrPort], only the lower 128 bytes at offset 7Fh:00h are accessible through FCH::IO::RtcDataPort. Extended RAMs are physically located at addresses 80h to FFh. In order to access these addresses, an address offset should be programmed into this register and access to them is done through FCH::IO::RTCExtRAMDataPort. An offset of 80h is automatically added to this 7-bit address. The value of this register is undefined/non-deterministic when powered up for the first time." />
    </register>
    <register name="RTCExtRAMDataPort" type="io" port="0x00073" size="1" desc="RTC Extended RAM Data Port. Read-write. Precondition (data port): AltRTCAddrPort = x53.">
      <field name="ExtendedRamDataPort" bit="0" size="8" desc="Read-write. Reset: XXh. Extended RAM data port. The value of this register is undefined/non-deterministic when powered up for the first time." />
    </register>

    <!-- page 370 -->

    <register name="RTCTimeClear" type="io" port="0x00073" size="1" desc="RTC Time Clear. Read-write. Precondition (data port): AltRTCAddrPort = x7E.">
      <!-- Bits 7:1 reserved. -->
      <field name="RtcTimeClear" bit="0" size="1" desc="Read-write. Reset: X. 1=Clear the RTC second and stop RTC time. The value of this register is undefined/non-deterministic when powered up for the first time." />
    </register>
    <register name="RTCRAMEn" type="io" port="0x00073" size="1" desc="RTC RAM Enable. Read-write. Precondition (data port): AltRTCAddrPort = x7F.">
      <!-- Bits 7:1 reserved. -->
      <field name="RtcRamEnable" bit="0" size="1" desc="Read-write. Reset: X. 1=Enable access to the RTC RAM. The value of this register is undefined/non-deterministic when powered up for the first time." />
    </register>
    <register name="PostCode0" type="io" port="0x0080" size="1" desc="PostCode 0. Read-write. Reset: 00h.">
      <field name="PostCode[7:0]" bit="0" size="8" desc="BIOS post code. Read-write. Reset: 00h. BIOS post code register. This can be 32 bits for Writes (using IOx008[3:1]) and 8 bits for Reads." />
    </register>
    <register name="FastInit" type="io" port="0x0092" size="1" desc="FastInit. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="A20EnB" bit="1" size="1" desc="A20 Enable Bar bit. Read-write. Reset: 0. 1=A20M# function is disabled." />
      <field name="FastInit" bit="0" size="1" desc="Read-write. Reset: 0. 0=Before another INIT pulse can be generated via this register, this bit must be written back to a 0. 1=Generate INIT assertion for approximately 4 ms. This bit provides a fast software executed processor reset function." />
    </register>
    <register name="IntrCntrl2Reg1" type="io" port="0x00A0" size="1" desc="IntrCntrl2Reg1. Read-write. Reset: 00h.">
      <field name="IntrCntrl2Reg1" bit="0" size="8" desc="Read-write. Reset: 00h. IRQ[15:8] status and control. Read: IRR, ISR. Write: ICW1, OCW2, OCW3." />
    </register>
    <register name="IntrCntrl2Reg2" type="io" port="0x00A1" size="1" desc="IntrCntrl2Reg2. Read-write. Reset: 00h.">
      <field name="IntrCntrl2Reg2" bit="0" size="8" desc="Read-write. Reset: 00h. IRQ[15:8] status and control. Read: IMR. Write: ICW2, ICW3, ICW4, OCW1." />
    </register>
    <register name="Dma2Ch4Addr" type="io" port="0x00C0" size="1" desc="Dma2_Ch4Addr. Read-write. Reset: 00h.">
      <field name="Dma2Ch4Addr" bit="0" size="8" desc="Read-write. Reset: 00h. DMA2 channel[4] base and current address." />
    </register>

    <!-- page 371 -->

    <register name="Dma2Ch4Cnt" type="io" port="0x00C2" size="1" desc="Dma2_Ch4Cnt. Read-write. Reset: 00h.">
      <field name="Dma2Ch4Cnt" bit="0" size="8" desc="Read-write. Reset: 00h. DMA2 channel[4] base and current count." />
    </register>
    <register name="Dma2Ch5Addr" type="io" port="0x00C4" size="1" desc="Dma2_Ch5Addr. Read-write. Reset: 00h.">
      <field name="Dma2Ch5Addr" bit="0" size="8" desc="Read-write. Reset: 00h. DMA2 channel[5] base and current address." />
    </register>
    <register name="Dma2Ch5Cnt" type="io" port="0x00C6" size="1" desc="Dma2_Ch5Cnt. Read-write. Reset: 00h.">
      <field name="Dma2Ch5Cnt" bit="0" size="8" desc="Read-write. Reset: 00h. DMA2 channel[5] base and current count." />
    </register>
    <register name="Dma2Ch6Addr" type="io" port="0x00C8" size="1" desc="Dma2_Ch6Addr. Read-write. Reset: 00h.">
      <field name="Dma2Ch6Addr" bit="0" size="8" desc="Read-write. Reset: 00h. DMA2 channel[6] base and current address." />
    </register>
    <register name="Dma2Ch6Cnt" type="io" port="0x00CA" size="1" desc="Dma2_Ch6Cnt. Read-write. Reset: 00h.">
      <field name="Dma2Ch6Cnt" bit="0" size="8" desc="Read-write. Reset: 00h. DMA2 channel[6] base and current count." />
    </register>
    <register name="Dma2Ch7Addr" type="io" port="0x00CC" size="1" desc="Dma2_Ch7Addr. Read-write. Reset: 00h.">
      <field name="Dma2Ch7Addr" bit="0" size="8" desc="Read-write. Reset: 00h. DMA2 channel[7] base and current address." />
    </register>
    <register name="DmaCh7Cnt" type="io" port="0x00CE" size="1" desc="Dma_Ch7Cnt. Read-write. Reset: 00h.">
      <field name="Dma2Ch7Cnt" bit="0" size="8" desc="Read-write. Reset: 00h. DMA2 channel[7] base and current count." />
    </register>
    <register name="Dma2Stat" type="io" port="0x00D0" size="1" desc="Dma2_Status. Read-write. Reset: 00h.">
      <field name="Dma2Status" bit="0" size="8" desc="Read-write. Reset: 00h. DMA2 status register." />
    </register>
    <register name="Dma2WriteReq" type="io" port="0x00D2" size="1" desc="Dma2_WriteRequest. Read-write. Reset: 00h.">
      <field name="Dma2WriteRequest" bit="0" size="8" desc="Read-write. Reset: 00h. DMA2 request register." />
    </register>

    <!-- page 372 -->

    <register name="Dma2WriteMask" type="io" port="0x00D4" size="1" desc="Dma2_WriteMask. Read-write. Reset: 00h.">
      <field name="Dma2WriteMask" bit="0" size="8" desc="Read-write. Reset: 00h. DMA2 channel mask register." />
    </register>
    <register name="Dma2WriteMode" type="io" port="0x00D6" size="1" desc="Dma2_WriteMode. Read-write. Reset: 00h.">
      <field name="Dma2WriteMode" bit="0" size="8" desc="Read-write. Reset: 00h. DMA2 mode register." />
    </register>
    <register name="Dma2Clear" type="io" port="0x00D8" size="1" desc="Dma2_Clear. Read-write. Reset: 00h.">
      <field name="Dma2Clear" bit="0" size="8" desc="Read-write. Reset: 00h. Channel[7:4] clear byte pointer." />
    </register>
    <register name="Dma2MasClr" type="io" port="0x00DA" size="1" desc="Dma2_MasterClr. Read-write. Reset: 00h.">
      <field name="Dma2MasterClear" bit="0" size="8" desc="Read-write. Reset: 00h. Write: Channel[7:4] DMA master clear. Read: Intermediate register." />
    </register>
    <register name="Dma2ClrMask" type="io" port="0x00DC" size="1" desc="Dma2_ClrMask. Read-write. Reset: 00h.">
      <field name="Dma2ClrMask" bit="0" size="8" desc="Read-write. Reset: 00h. Channel[7:4] DMA clear mask." />
    </register>
    <register name="Dma2AllMask" type="io" port="0x00DE" size="1" desc="Dma2_AllMask. Read-write. Reset: 00h.">
      <field name="Dma2AllMask" bit="0" size="8" desc="Read-write. Reset: 00h. DMA2 mask register." />
    </register>
    <register name="NCPErr" type="io" port="0x00F0" size="1" desc="NCP Error. Read,Write-once. Reset: Cold,00h. Writes to this port assert IGNNE# if FERR# is TRUE. If FERR# is FALSE, writes to this port do not assert IGNNE#. The first write sets WarmBoot.">
      <field name="WarmBoot" bit="7" size="1" desc="Read,Write-once. Reset: Cold,0. 0=Cold. 1=Warm. Warm or cold boot indicator." />
      <!-- Bits 6:0 reserved. -->
    </register>
    <register name="IntrEdgeCtl" type="io" port="0x04D0" size="2" desc="IntrEdgeControl. Reset: 0000h.">
      <field name="IRQ15Control" bit="15" size="1" desc="Read-write. Reset: 0. 0=Edge. 1=Level." />
      <field name="IRQ14Control" bit="14" size="1" desc="Read-write. Reset: 0. 0=Edge. 1=Level." />
      <!-- Bit 13 reserved. -->
      <field name="IRQ12Control" bit="12" size="1" desc="Read-write. Reset: 0. 0=Edge. 1=Level." />
      <field name="IRQ11Control" bit="11" size="1" desc="Read-write. Reset: 0. 0=Edge. 1=Level." />
      <field name="IRQ10Control" bit="10" size="1" desc="Read-write. Reset: 0. 0=Edge. 1=Level." />
      <field name="IRQ9Control" bit="9" size="1" desc="Read-write. Reset: 0. 0=Edge. 1=Level." />
      <field name="IRQ8Control" bit="8" size="1" desc="Read-only. Reset: 0. Always edge." />
      <field name="IRQ7Control" bit="7" size="1" desc="Read-write. Reset: 0. 0=Edge. 1=Level." />
      <field name="IRQ6Control" bit="6" size="1" desc="Read-write. Reset: 0. 0=Edge. 1=Level." />
      <field name="IRQ5Control" bit="5" size="1" desc="Read-write. Reset: 0. 0=Edge. 1=Level." />
      <field name="IRQ4Control" bit="4" size="1" desc="Read-write. Reset: 0. 0=Edge. 1=Level." />
      <field name="IRQ3Control" bit="3" size="1" desc="Read-write. Reset: 0. 0=Edge. 1=Level." />
      <!-- Bit 2 reserved. -->
      <field name="IRQ1Control" bit="1" size="1" desc="Read-write. Reset: 0. 0=Edge. 1=Level." />
      <field name="IRQ0Control" bit="0" size="1" desc="Read-write. Reset: 0. 0=Edge. 1=Level." />
    </register>

    <!-- page 373 -->

    <register name="PciIntrIndex" type="io" port="0x0C00" size="1" desc="Pci_Intr_Index. Read-write. Reset: 00h.">
      <field name="PciIntrApic" bit="7" size="1" desc="Read-write. Reset: 0. 0=IRQ routing to PIC. 1=IRQ routing to IOAPIC." />
      <field name="PciIntrIndex" bit="0" size="7" desc="Read-write. Reset: 00h. PCI interrupt index. Selects which PCI interrupt to map." />
    </register>

    <!-- page 374 -->

    <register name="PciIntrData" type="io" port="0x0C01" size="1" desc="Pci_Intr_Data. Read-write. Reset: 00h.">
      <field name="PciIntrData" bit="0" size="8" desc="Read-write. Reset: 00h. PCI interrupt data." />
    </register>
    <register name="PciIntMap" type="io" port="0x00C01" size="1" desc="PCI INT[H#,G#,F#,E#,D#,C#,B#,A#] Map. Read-write. Reset: 1Fh. Precondition (data port): PciIntrIndex = x00.">
      <!-- Bits 7:5 reserved. -->
      <field name="Pci2IntrMap" bit="0" size="5" desc="Read-write. Reset: 1Fh. If (FCH::IO::PciIntrIndex[PciIntrApic] == 1), then Pci2IntrMap specifies mapping of INT[H#:A#] to APIC interrupt number. If (FCH::IO::PciIntrIndex[PciIntrApic] == 0), then Pci2IntrMap specifies mapping of INT[H#:A#] to PIC interrupt number." />
    </register>
    <register name="IntrMiscMap" type="io" port="0x00C01" size="1" desc="Intr_Misc_Map. Read-write. Reset: 00h. Precondition (data port): PciIntrIndex = x08.">
      <field name="Pci2Intr15Map" bit="6" size="2" desc="Read-write. Reset: 0h." />
      <field name="Pci2Intr14Map" bit="4" size="2" desc="Read-write. Reset: 0h." />
      <field name="PciIntrIrq12" bit="3" size="1" desc="Read-write. Reset: 0. 0=IMC as IRQ12 input source. 1=Serial IRQ or PCI devices as IRQ12 input source." />
      <field name="PciIntrIrq8" bit="2" size="1" desc="Read-write. Reset: 0. 0=RTC is IRQ8 input source. 1=Serial IRQ or PCI devices as IRQ8 input source." />
      <field name="PciIntrIrq1" bit="1" size="1" desc="Read-write. Reset: 0. 0=IMC as IRQ1 input source. 1=Serial IRQ or PCI devices as IRQ1 input source." />
      <field name="PciIntrIrq0" bit="0" size="1" desc="Read-write. Reset: 0. 0=8254 timer as IRQ0 input source. 1=Serial IRQ or PCI devices as IRQ0 input source." />
    </register>

    <!-- page 375 -->

    <register name="IntrMisc0Map" type="io" port="0x00C01" size="1" desc="Intr_Misc0Map. Read-write. Reset: E7h. Precondition (data port): PciIntrIndex = x09.">
      <field name="IntrDelay" bit="7" size="1" desc="Read-write. Reset: 1. INTR 600 ns delay." />
      <field name="IRQ12FilterEnable" bit="6" size="1" desc="Read-write. Reset: 1. IRQ12 filter enable." />
      <field name="IRQ1FilterEnable" bit="5" size="1" desc="Read-write. Reset: 1. IRQ1 filter enable." />
      <field name="IrqInputEn" bit="4" size="1" desc="Read-write. Reset: 0. 0=Mask off IRQ input. 1=Enable IRQ input." />
      <field name="MaskIrq1Irq12" bit="3" size="1" desc="Read-write. Reset: 0. 0=Enable IRQ1 and IRQ12. 1=Mask off IRQ1 and IRQ12." />
      <field name="Merge_Ec_irq12" bit="2" size="1" desc="Read-write. Reset: 1. 0=Route serial IRQ12 to USB IRQ12 input. 1=Route IMC IRQ12 to USB IRQ12 input." />
      <field name="Merge_Ec_irq1" bit="1" size="1" desc="Read-write. Reset: 1. 0=Route serial IRQ1 to USB IRQ1 input. 1=Route IMC IRQ1 to USB IRQ1 input." />
      <field name="IntMap" bit="0" size="1" desc="Read-write. Reset: 1. 0=INT0 in IOAPIC comes from IRQ0 in PIC, INT2 in IOAPIC comes from INTR in PIC. 1=INT2 in IOAPIC comes from IRQ0 in PIC, INT0 in IOAPIC comes from INTR in PIC." />
    </register>
    <register name="IntrMisc1Map" type="io" port="0x00C01" size="1" desc="Intr_Misc1Map. Read-write. Reset: 00h. Precondition (data port): PciIntrIndex = x0A.">
      <field name="HPET" bit="0" size="8" desc="Read-write. Reset: 00h. FCH::IO::IntrMisc1Map updates the lower 8 bits. FCH::IO::IntrMisc2Map updates the upper 8 bits." />
    </register>
    <register name="IntrMisc2Map" type="io" port="0x00C01" size="1" desc="Intr_Misc2Map. Read-write. Reset: 00h. Precondition (data port): PciIntrIndex = x0B.">
      <field name="HPET" bit="0" size="8" desc="Read-write. Reset: 00h. FCH::IO::IntrMisc1Map updates the lower 8 bits, FCH::IO::IntrMisc2Map updates the upper 8 bits." />
    </register>
    <register name="PCIInterruptMap" type="io" port="0x00C01" size="1" desc="PCIInterruptMap. Read-write. Reset: 1Fh. Precondition (data port): PciIntrIndex = x0C.">
      <!-- Bits 7:5 reserved. -->
      <field name="Pci2IntrMap" bit="0" size="5" desc="Read-write. Reset: 1Fh. If (FCH::IO::PciIntrIndex[PciIntrApic] == 1), then Pci2IntrMap specifies the APIC interrupt number that the corresponding PCI interrupt maps to. If (FCH::IO::PciIntrIndex[PciIntrApic] == 0), then Pci2IntrMap specifies the PIC interrupt number that the corresponding PCI interrupt maps to. See FCH::IO::PciIntrIndex for the PCI interrupt list." />
    </register>
    <register name="PciErr" type="io" port="0x0C14" size="1" desc="Pci_Error.">
      <!-- Bits 7:4 reserved. -->
      <field name="PerrNmi" bit="3" size="1" desc="Read-write. Reset: 1. 0=Enable. 1=Disable. Enable NMI generation from PERR#." />
      <field name="SerrNmi" bit="2" size="1" desc="Read-write. Reset: 1. 0=Enable. 1=Disable. Enable NMI generation from SERR#." />
      <field name="PerrNmiStatus" bit="1" size="1" desc="Read-only. Reset: X. 1=NMI generation is enabled and PERR# is asserted due to a PCI data parity error. This bit is cleared by writing FCH::IO::NmiStat[2] = 1." />
      <field name="SerrNmiStatus" bit="0" size="1" desc="Read-only. Reset: X. 1=NMI generation is enabled and SERR# is asserted due to a PCI error.   This bit is cleared by writing FCH::IO::NmiStat[2] = 1." />
    </register>

    <!-- page 376 -->

    <register name="PM2Index" type="io" port="0x0CD0" size="1" desc="PM2_Index. Read-write. Reset: 00h.">
      <field name="Pm2Index" bit="0" size="8" desc="Power management 2 index register. Read-write. Reset: 00h. This register specifies the index of the power management 2 register." />
    </register>
    <register name="PM2Data" type="io" port="0x0CD1" size="1" desc="PM2_Data. Read-write. Reset: 00h.">
      <field name="Pm2Data" bit="0" size="8" desc="Power management 2 data register. Read-write. Reset: 00h. This register specifies the data Read from/Written to the power management 2 register pointed by FCH::IO::PM2Index." />
    </register>
    <register name="BiosRAMIndex" type="io" port="0x0CD4" size="1" desc="BIOSRAM Index. Read-write. Reset: 00h.">
      <field name="BiosRamIndex" bit="0" size="8" desc="BIOS RAM index register. Read-write. Reset: 00h. This register specifies the index in the 256- byte BIOS RAM. Data in this RAM is preserved until RSMRST# is asserted or S5 power is lost." />
    </register>
    <register name="BiosRAMData" type="io" port="0x0CD5" size="1" desc="BIOSRAM Data. Read-write. Reset: 00h.">
      <field name="BiosRamData" bit="0" size="8" desc="BIOS RAM data register. Read-write. Reset: 00h. This register specifies the data Read from/Written to the BIOS RAM pointed by FCH::IO::BiosRAMIndex." />
    </register>
    <register name="PmIndex" type="io" port="0x0CD6" size="1" desc="PM_Index. Read-write. Reset: 00h.">
      <field name="PmIndex" bit="0" size="8" desc="Power management index register. Read-write. Reset: 00h. This register specifies the index of the power management register. See 9.2.10.2 [Power Management (PM) Registers]." />
    </register>
    <register name="PmData" type="io" port="0x0CD7" size="1" desc="PM_Data. Read-write. Reset: 00h.">
      <field name="PmData" bit="0" size="8" desc="Power management data register. Read-write. Reset: 00h. This register specifies the data Read from or Written to the power management register pointed by FCH::IO::PmIndex. See 9.2.1 [Legacy Block Configuration Registers (IO)]." />
    </register>
    <register name="SysReset" type="io" port="0x0CF9" size="1" desc="System Reset Register. Reset: 00h. This register can be accessed through FCH::PM::CF9Shadow.">
      <!-- Bits 7:4 reserved. -->
      <field name="FullRst" bit="3" size="1" desc="Read-write. Reset: 0. 0=Assert reset signals only. 1=Place system in S5 state for 3 to 5 seconds." />
      <field name="RstCmd" bit="2" size="1" desc="Read-write,Volatile. Reset: 0. 1=Generate reset as specified by FullRst and SysRst." />
      <field name="SysRst" bit="1" size="1" desc="Read-write. Reset: 0. 0=Send an INIT HT message. 1=Reset as specified by FullRst." />
      <!-- Bit 0 reserved. -->
    </register>

    <!-- 9.2.2.1 eMMC Configuration Registers -->

    <!-- page 377 -->

    <register name="EMMC_DEV_VEN_ID" type="memory" device="EMMCCFG" offset="0x00000000" size="4" desc="FCH::EMMC::EMMC_DEV_VEN_ID. Read-only. Reset: 7813_1022h.">
      <field name="DEV_ID" bit="16" size="16" desc="Read-only. Reset: 7813h. Device ID." />
      <field name="VEND_ID" bit="0" size="16" desc="Read-only. Reset: 1022h. Vendor ID." />
    </register>
    <register name="EMMC_CMD_STS" type="memory" device="EMMCCFG" offset="0x00000004" size="4" desc="FCH::EMMC::EMMC_CMD_STS.">
      <field name="Det_Perr" bit="31" size="1" desc="Read-only. Reset: 0. This bit is set by the device whenever it detects a parity error, even if parity error handling is disabled (as controlled by bit[6] in the Command register)." />
      <field name="Sig_SysErr" bit="30" size="1" desc="Read-only. Reset: 0. Set whenever the device asserts SERR#." />
      <field name="Rec_Mabort" bit="29" size="1" desc="Read-only. Reset: 0. This bit is set by a master device whenever its transaction (except for Special Cycle) is terminated with Master-Abort." />
      <field name="Rec_Tabort" bit="28" size="1" desc="Read-only. Reset: 0. This bit is set by a master device whenever its transaction is terminated with Target-Abort." />
      <field name="Sig_Tabort" bit="27" size="1" desc="Read-only. Reset: 0. This bit is set by a target device whenever it terminates a transaction with Target-Abort." />
      <field name="DEVSEL_Timing" bit="25" size="2" desc="Read-only. Reset: Fixed,1h. Medium timing." />
      <field name="Master_DPerr" bit="24" size="1" desc="Read-only. Reset: 0. Master Data Parity Error." />
      <field name="Fast_B2B_Cap" bit="23" size="1" desc="Read-only. Reset: Fixed,0. 0=Disallow. 1=Allow. Allow Fast Back-to-Back capability." />
      <field name="PCI_ST_Reserved2" bit="22" size="1" desc="Read-only. Reset: Fixed,0. Reserved." />
      <field name="En_66MHz" bit="21" size="1" desc="Read-only. Reset: Fixed,1. Indicating 66MHz capable." />
      <field name="Cap_List" bit="20" size="1" desc="Read-only. Reset: 1. Indicating no Capabilities Linked List available." />
      <field name="Int_status" bit="19" size="1" desc="Read-only. Reset: 0. Reflects the state of the interrupt in the device/function." />
      <field name="PCI_ST_Reserved1" bit="16" size="3" desc="Read-only. Reset: Fixed,0h. Reserved." />
      <field name="PCI_CMD_Reserved2" bit="11" size="5" desc="Read-write. Reset: Fixed,00h. Reserved." />
      <field name="Int_Dis" bit="10" size="1" desc="Read-write. Reset: 0. 0=Enables the assertion of the device/function's INTx# signal. 1=Disable. INTx# signal enable." />
      <field name="Fast_B2B_En" bit="9" size="1" desc="Read-only. Reset: Fixed,0. Hard-wired to 0, indicating fast back-to-back transactions only to the same agent are allowed." />
      <field name="SERRB_En" bit="8" size="1" desc="Read-write. Reset: 0. 0=Disable the SERR# driver. 1=Enable the SERR# driver. SERR# driver enable." />
      <field name="PCI_CMD_Reserved1" bit="7" size="1" desc="Read-only. Reset: Fixed,0. Reserved." />
      <field name="Parity_En" bit="6" size="1" desc="Read-write. Reset: 0. 0=Parity check disabled. 1=Device must take action when a parity error is dected. Parity check enabled." />
      <field name="VGA_Pal_Access" bit="5" size="1" desc="Read-only. Reset: Fixed,0. 0=Disallow. 1=Allow. Allow snoop VGA palette cycles." />
      <field name="MemWr_Inv_Cmd" bit="4" size="1" desc="Read-only. Reset: Fixed,0. 0=Disallow. 1=Allow. Allow Memory Write and Invalidate command." />
      <field name="Special_Cycle" bit="3" size="1" desc="Read-only. Reset: Fixed,0. 0=Disable. 1=Enable. Special cycle recognition enable." />
      <field name="Bus_Master" bit="2" size="1" desc="Read-write. Reset: 0. 0=Disallow. 1=Allow. Allow the device to behave as a bus master." />
      <field name="Mem_Space_Access" bit="1" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Memory Space access enable." />
      <field name="IO_Space_Access" bit="0" size="1" desc="Read-only. Reset: Fixed,0. 0=Disable. 1=Enable. IO Space access enable." />
    </register>

    <!-- page 378 -->

    <register name="EMMC_REV_ID" type="memory" device="EMMCCFG" offset="0x00000008" size="4" desc="FCH::EMMC::EMMC_REV_ID.">
      <field name="BC" bit="24" size="8" desc="Read-write. Reset: 08h. Base Class Code. Hard-wired to 08h, indicating general peripheral." />
      <field name="SC" bit="16" size="8" desc="Read-write. Reset: 05h. Sub Class Code. Hard-wired to 05h, indicating SD Host controller." />
      <field name="PI" bit="8" size="8" desc="Read-only. Reset: 01h. Programming Interface Code. Hard-wired to 01h for Standard host supporting DMA." />
      <field name="Revision_ID" bit="0" size="8" desc="Read-only. Reset: Fixed,01h. Revision ID." />
    </register>
    <register name="EMMC_MISC" type="memory" device="EMMCCFG" offset="0x0000000C" size="4" desc="FCH::EMMC::EMMC_MISC.">
      <field name="BIST" bit="24" size="8" desc="Read-only. Reset: Fixed,00h. Hard-wired to 00h, indicating no built-in BIST support." />
      <field name="Header_Type" bit="16" size="8" desc="Read-only. Reset: Fixed,80h. Bit[23] hard-wired to 1, indicating a single-function device. Bits[22:16] are hard-wired to 00h." />
      <field name="Latency_Timer" bit="11" size="5" desc="Read-write. Reset: 00h. Latency_Timer_HW (bits[10:8]) is hard-wired to 000b, resulting in a timer granularity of at least eight clocks. This field specifies, in units of PCI bus clocks, the value of the Latency Timer for this PCI bus master." />
      <field name="Latency_Timer_HW" bit="8" size="3" desc="Read-only. Reset: Fixed,0h. Specifies the value of the Latency Timer in units of PCICLKs." />
      <field name="Cache_Size" bit="0" size="8" desc="Read-write. Reset: 00h. This Read-write field specifies the system cacheline size in units of DWORDs and must be initialized to 00h." />
    </register>
    <register name="EMMC_BAR" type="memory" device="EMMCCFG" offset="0x00000010" size="4" desc="FCH::EMMC::EMMC_BAR.">
      <field name="BAR" bit="8" size="24" desc="Read-write. Reset: 00_0000h. Base Address. Specifies the upper 15 bits of the 32-bit starting base address." />
      <field name="BAR_Reserved" bit="4" size="4" desc="Read-only. Reset: Fixed,0h. Reserved." />
      <field name="PM" bit="3" size="1" desc="Read-only. Reset: Fixed,0. Prefetch memory. A constant value of 0 indicates that there is no support for prefetchable memory." />
      <field name="TP" bit="1" size="2" desc="Read-only. Reset: 2h. 10b indicates that the base register has a 64-bit width." />
      <field name="IND" bit="0" size="1" desc="Read-only. Reset: Fixed,0. Resource Type Indicator. A constant value of 0 indicates that the operational registers of the device are mapped into memory space of the main memory of the PC host system." />
    </register>
    <register name="EMMC_UPPER_BAR" type="memory" device="EMMCCFG" offset="0x00000014" size="4" desc="FCH::EMMC::EMMC_UPPER_BAR. Read-write. Reset: 0000_0000h.">
      <field name="UBAR" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Upper 32 bits of the Base Address." />
    </register>
    <register name="EMMC_SUB_VEN_SYS_ID" type="memory" device="EMMCCFG" offset="0x0000002C" size="4" desc="FCH::EMMC::EMMC_SUB_VEN_SYS_ID. Read-write. Reset: 7806_1022h.">
      <field name="Sub_System_ID" bit="16" size="16" desc="Read-write. Reset: 7806h. Can only be written once by software." />
      <field name="Sub_Vendor_ID" bit="0" size="16" desc="Read-write. Reset: 1022h. Can only be written once by software." />
    </register>

    <!-- page 379 -->

    <register name="EMMC_CAP_PTR" type="memory" device="EMMCCFG" offset="0x00000034" size="1" desc="FCH::EMMC::EMMC_CAP_PTR. Read-only. Reset: 80h.">
      <field name="CAP_PTR" bit="0" size="8" desc="Read-only. Reset: 80h. The first pointer of Capability block. Points to the FLR register." />
    </register>
    <register name="EMMC_INT_LINE" type="memory" device="EMMCCFG" offset="0x0000003C" size="4" desc="FCH::EMMC::EMMC_INT_LINE. Reset: 0000_0100h.">
      <field name="MAX_LAT" bit="24" size="8" desc="Read-only. Reset: 00h. Hardwired to 00h to indicate no major requirements for the settings of Latency Timers." />
      <field name="MIN_GNT" bit="16" size="8" desc="Read-only. Reset: 00h. Hardwired to 00h to indicate no major requirements for the settings of Latency Timers." />
      <field name="Int_Pin" bit="8" size="8" desc="Read-write. Reset: 01h. Hard-wired to 01h, corresponding to using INTA#." />
      <field name="Int_Line" bit="0" size="8" desc="Read-write. Reset: 00h. The Interrupt Line register used to communicate interrupt line routing information." />
    </register>
    <register name="EMMC_SLOT_IMFORMATION" type="memory" device="EMMCCFG" offset="0x00000040" size="4" desc="FCH::EMMC::EMMC_SLOT_IMFORMATION. Read-only.">
      <!-- Bits 31:8 reserved. -->
      <field name="Slot_Reserved2" bit="7" size="1" desc="Read-only. Reset: Fixed,0. Reserved." />
      <field name="Num_Of_Slot" bit="4" size="3" desc="Read-only. Reset: Fixed,0h. Hardwired to 000h to indicate only 1 slot." />
      <field name="Slot_Reserved1" bit="3" size="1" desc="Read-only. Reset: Fixed,0. Reserved." />
      <field name="First_BAR" bit="0" size="3" desc="Read-only. Reset: 0h. Hardwired to 000b to indicate BAR0 (Base address 10h)." />
    </register>
    <register name="EMMC_MSI_CAP_HEADER" type="memory" device="EMMCCFG" offset="0x00000080" size="2" desc="FCH::EMMC::EMMC_MSI_CAP_HEADER. Read-only. Reset: 9005h.">
      <field name="CAP_NXT_PTR" bit="8" size="8" desc="Read-only. Reset: 90h. Pointer to the next item in the capabilities list." />
      <field name="CAP_ID" bit="0" size="8" desc="Read-only. Reset: 05h. 05h indicates MSI." />
    </register>
    <register name="EMMC_MSI_CTRL" type="memory" device="EMMCCFG" offset="0x00000082" size="2" desc="FCH::EMMC::EMMC_MSI_CTRL.">
      <field name="MSI_CTRL_Reserved" bit="8" size="8" desc="Read-only. Reset: Fixed,00h. Reserved." />
      <field name="Extend_Addr_En" bit="7" size="1" desc="Read-only. Reset: 1. 64-bit address capable." />
      <field name="Mul_Msg_En" bit="4" size="3" desc="Read-write. Reset: 0h. Multiple message enable." />
      <field name="Mul_Msg_Cap" bit="1" size="3" desc="Read-only. Reset: Fixed,0h. Multiple message capable." />
      <field name="MSI_Enable" bit="0" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. MSI enable." />
    </register>
    <register name="EMMC_MSI_ADDR" type="memory" device="EMMCCFG" offset="0x00000084" size="4" desc="FCH::EMMC::EMMC_MSI_ADDR.">
      <field name="Msg_Addr" bit="2" size="30" desc="Read-write. Reset: 0000_0000h. Message address." />
      <field name="MSI_ADDR_Reserved" bit="0" size="2" desc="Read-only. Reset: Fixed,0h. Reserved." />
    </register>

    <!-- page 380 -->

    <register name="EMMC_MSI_U_ADDR" type="memory" device="EMMCCFG" offset="0x00000088" size="4" desc="FCH::EMMC::EMMC_MSI_U_ADDR. Read-write. Reset: 0000_0000h.">
      <field name="Msg_Upper_Addr" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Message upper address. Msg_Addr={Msg_Upper_Addr,FCH::EMMC::EMMC_MSI_ADDR[Msg_Addr]}" />
    </register>
    <register name="EMMC_MSI_DATA" type="memory" device="EMMCCFG" offset="0x0000008C" size="2" desc="FCH::EMMC::EMMC_MSI_DATA. Read-write. Reset: 0000h.">
      <field name="Msg_Data" bit="0" size="16" desc="Read-write. Reset: 0000h. Message data." />
    </register>
    <register name="EMMC_PMC_CAP_HEADER" type="memory" device="EMMCCFG" offset="0x00000090" size="2" desc="FCH::EMMC::EMMC_PMC_CAP_HEADER. Read-only. Reset: 0001h.">
      <field name="CAP_NXT_PTR" bit="8" size="8" desc="Read-only. Reset: 00h. Pointer to the next item in the capabilities list." />
      <field name="CAP_ID" bit="0" size="8" desc="Read-only. Reset: 01h. Power management." />
    </register>
    <register name="EMMC_PMC_CAP" type="memory" device="EMMCCFG" offset="0x00000092" size="2" desc="FCH::EMMC::EMMC_PMC_CAP. Read-only. Reset: Fixed,8003h.">
      <field name="PME_Support" bit="11" size="5" desc="Read-only. Reset: Fixed,10h. This 5-bit field indicates the power states in which the function may assert PME#. A value of 0 for any bits indicates that the function is not capable of asserting the PME# signal while in that power state." />
      <field name="D2_Support" bit="10" size="1" desc="Read-only. Reset: Fixed,0. D2 Power Management state." />
      <field name="D1_Support" bit="9" size="1" desc="Read-only. Reset: Fixed,0. D1 Power Management state." />
      <field name="Aux_Current" bit="6" size="3" desc="Read-only. Reset: Fixed,0h. 3.3 Vaux auxiliary current requirements." />
      <field name="DSI" bit="5" size="1" desc="Read-only. Reset: Fixed,0. Device specific initialization." />
      <field name="PMC_Reserved" bit="4" size="1" desc="Read-only. Reset: Fixed,0. Reserved." />
      <field name="PME_Clock" bit="3" size="1" desc="Read-only. Reset: Fixed,0. If PME depends on PCI clock." />
      <field name="PMC_Version" bit="0" size="3" desc="Read-only. Reset: Fixed,3h. 011b indicates compliance with revision 1.2 of the PCI PM Interface specification." />
    </register>
    <register name="EMMC_PMCSR" type="memory" device="EMMCCFG" offset="0x00000094" size="2" desc="FCH::EMMC::EMMC_PMCSR.">
      <field name="PME_Status" bit="15" size="1" desc="Read-write. Reset: 0. Set when the function normally asserts the PME# signal independent of the state of PME# Enable." />
      <field name="Data_Scale" bit="13" size="2" desc="Read-only. Reset: Fixed,0h. Indicates the scaling factor to be used when interpreting the value of the Data register. The value and meaning of this field varries depending on which data value has been selected by the DataSelect field." />
      <field name="Data_Select" bit="9" size="4" desc="Read-write. Reset: 0h. Selects which data is to be reported through the Data register and DataScale field." />
      <field name="PME_EN" bit="8" size="1" desc="Read-write. Reset: 0. 0=PME# assertion is disabled. 1=Enable the function to assert PME#. PME# Enable." />
      <field name="PMCSR_Reserved2" bit="4" size="4" desc="Read-only. Reset: Fixed,0h. Reserved." />
      <field name="No_Soft_Reset" bit="3" size="1" desc="Read-only. Reset: Fixed,1. 1=Indicates that devices transitioning from D3hot to D0 because of power state commands do not perform an internal reset." />
      <field name="PMCSR_Reserved1" bit="2" size="1" desc="Read-only. Reset: Fixed,0. Reserved." />
      <field name="PowerState" bit="0" size="2" desc="Read-write. Reset: 0h. Initiates power state." />
    </register>

    <!-- page 381 -->

    <register name="EMMC_PMC_BSE" type="memory" device="EMMCCFG" offset="0x00000096" size="1" desc="FCH::EMMC::EMMC_PMC_BSE. Read-only. Reset: Fixed,00h.">
      <field name="BPCC_En" bit="7" size="1" desc="Read-only. Reset: Fixed,0. Bus Power/Clock Control enable." />
      <field name="B2_B3" bit="6" size="1" desc="Read-only. Reset: Fixed,0. B2/B3 support for D3hot." />
      <field name="PMC_BSE_Reserved" bit="0" size="6" desc="Read-only. Reset: Fixed,00h. Reserved." />
    </register>
    <register name="EMMC_PMC_DATA" type="memory" device="EMMCCFG" offset="0x00000097" size="1" desc="FCH::EMMC::EMMC_PMC_DATA. Read-only. Reset: 00h.">
      <field name="PMC_Data" bit="0" size="8" desc="Read-only. Reset: 00h. Reports the state dependent data requested by the DataSelect field. The value of this register is scaled by the value reported by the DataScale field." />
    </register>
    <register name="EMMC_DLL_CFG" type="memory" device="EMMCCFG" offset="0x00000108" size="2" desc="FCH::EMMC::EMMC_DLL_CFG. Read-write. Reset: 3232h.">
      <field name="I_PARAM_INCREMENT" bit="8" size="8" desc="Read-write. Reset: 32h. Next step search value, when first search fails. Next jump step search value. Good value setting will reduce initial time when first lock searching. Typical value = start_point." />
      <field name="I_PARAM_START_POINT" bit="0" size="8" desc="Read-write. Reset: 32h. Initial DLL search value. Good value setting decreases initial time when first lock searching. Assumes every delay cell == 0.1 ns. For 200MHz, set &lt;VALUE> = 50 (32h). For 100MHz, set &lt;VALUE> = 100 (64h)." />
    </register>
    <register name="EMMC_DLL_CFG1" type="memory" device="EMMCCFG" offset="0x0000010A" size="2" desc="FCH::EMMC::EMMC_DLL_CFG1. Read-write. Reset: 3F00h.">
      <field name="I_DELAY" bit="8" size="8" desc="Read-write. Reset: 3Fh. DLL delay select. (I_BYPASS == 0) ? (This register is used to phase shift setting. 7Fh=Full cycle delay; 2Fh=1/4 cycle delay; 80h=Before one cycle; ...) : (This register is used to staticly delay the cell select.)" />
      <!-- Bits 7:5 reserved. -->
      <field name="I_BYPASS" bit="4" size="1" desc="Read-write. Reset: 0. 0=Disabled. 1=Enabled. DLL bypass. When enabled, the delay cell value is I_DELAY (bits[15:8])." />
      <!-- Bit 3 reserved. -->
      <field name="I_RESYNC" bit="2" size="1" desc="Read-write. Reset: 0. 0=No effect. 1=Re-sync. DLL re-sync dll slave line." />
      <field name="SOFT_RESET" bit="1" size="1" desc="Read-write. Reset: 0. 0=No effect. 1=Reset. DLL reset. Active is low." />
      <field name="DLL_ENABLE" bit="0" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. DLL enable. Default is off for saving power." />
    </register>
    <register name="EMMC_DLL_CFG2" type="memory" device="EMMCCFG" offset="0x0000010C" size="2" desc="FCH::EMMC::EMMC_DLL_CFG2. Reset: 2F00h.">
      <field name="O_LOCK_VALUE" bit="8" size="8" desc="Read-only. Reset: 2Fh. DLL lock value, which can be obtained by software to view the DLL state." />
      <!-- Bits 7:1 reserved. -->
      <field name="O_LOCK" bit="0" size="1" desc="Read-only. Reset: 0. 0=DLL not locked. 1=DLL locked. DLL lock flag. When asserted, the DLL is locked, then software can do next things." />
    </register>

    <!-- 9.2.2.2 eMMC Host Controller Registers -->

    <!-- page 382 -->

    <register name="EMMCHC_SYS_ADDR" type="memory" device="EMMCHC" offset="0x00000000" size="4" desc="FCH::EMMC::MMIO::EMMCHC_SYS_ADDR. Read-write. Reset: 0000_0000h.">
      <field name="SYS_ADDR" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. By updating this register, DMA_WAIT will be cleared. System Address. It indicates system memory address for DMA. When DMA transfer detects the DMA Buffer Boundary specified by the Host DMA Buffer Boundary in the Block Size register, SD controller asserts DMA_WAIT. Also SD controller generates DMA interrupt at this time in the case that corresponding bits in the Normal Interrupt Status Enable register and Normal Interrupt Signal Enable register are set. While ADMA is enabled, this regiseter will not be used." />
    </register>
    <register name="EMMCHC_BLK_CS" type="memory" device="EMMCHC" offset="0x00000004" size="4" desc="FCH::EMMC::MMIO::EMMCHC_BLK_CS.">
      <field name="BLK_CNT" bit="16" size="16" desc="Read-write. Reset: 0000h. Block Count. It indicates the block count of multiple data transfers. It is enabled when the Block Count Enable bit (D01) in the Transfer Mode Register is set to 1. It is decremented after each block data transmission. During infinite data transmission, setting of this bit is meaningless. Block Size and Block Count." />
      <!-- Bit 15 reserved. -->
      <field name="SDMA_BUF_BNDRY" bit="12" size="3" desc="Read-write. Reset: 0h. Host DMA Buffer Boundary. Indicates the contiguos buffer size in the system memory. Internally, when this boundary is reached, DMA interrupt will be generated." />
      <field name="BLK_SIZE" bit="0" size="12" desc="Read-write. Reset: 000h. Transfer Data Length (Maximum block size is 2K bytes). When the CE- ATA enable bit of the CE-ATA control register is set, a value of 0x000 indicates block size of 4K bytes." />
    </register>
    <register name="EMMCHC_CMD_ARG" type="memory" device="EMMCHC" offset="0x00000008" size="4" desc="FCH::EMMC::MMIO::EMMCHC_CMD_ARG. Read-write. Reset: 0000_0000h.">
      <field name="ARGUMENT1" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Command Argument. Command arguments specified as bits[39-8] of the command format." />
    </register>
    <register name="EMMCHC_CMD_TRN" type="memory" device="EMMCHC" offset="0x0000000C" size="4" desc="FCH::EMMC::MMIO::EMMCHC_CMD_TRN.">
      <!-- Bits 31:30 reserved. -->
      <field name="CMD_IDX" bit="24" size="6" desc="Read-write. Reset: 00h. Command index." />
      <field name="CMD_TYPE" bit="22" size="2" desc="Read-write. Reset: 0h. Command type." />
      <field name="DATA_PRSNT" bit="21" size="1" desc="Read-write. Reset: 0. 0=No data. 1=Data. Data Present Select. Indicates that data is present and will be transferred on the DAT line. When a command is issued with this bit enabled, the internal buffer will be cleared." />
      <field name="CMD_IDX_CHK_EN" bit="20" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Command Index Check enable." />
      <field name="CRC_CHK_EN" bit="19" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Command CRC Check enable." />
      <!-- Bit 18 reserved. -->
      <field name="RESP_TYPE" bit="16" size="2" desc="Read-write. Reset: 0h. Response type select." />
      <!-- Bits 15:6 reserved. -->
      <field name="MULTI_BLK" bit="5" size="1" desc="Read-write. Reset: 0. 0=Single block. 1=Multiple blocks. Multiple/Single block select." />
      <field name="DATA_DIR" bit="4" size="1" desc="Read-write. Reset: 0. 0=Write. 1=Read. Data Transfer Direction." />
      <field name="ACMD_EN" bit="2" size="2" desc="Read-write. Reset: 0h. Auto CMD Enable." />
      <field name="BLK_CNT_EN" bit="1" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Block Count Enable." />
      <field name="DMA_EN" bit="0" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. DMA Enable." />
    </register>

    <!-- page 383 -->

    <register name="EMMCHC_RESP1_0" type="memory" device="EMMCHC" offset="0x00000010" size="4" desc="FCH::EMMC::MMIO::EMMCHC_RESP1_0. Read-only. Reset: 0000_0000h.">
      <field name="RESPONSE1" bit="16" size="16" desc="Read-only. Reset: 0000h. R[39:24] of the response is saved in this field. The response value is preseved until the next response." />
      <field name="RESPONSE0" bit="0" size="16" desc="Read-only. Reset: 0000h. R[23:8] of the response is saved in this field." />
    </register>
    <register name="EMMCHC_RESP3_2" type="memory" device="EMMCHC" offset="0x00000014" size="4" desc="FCH::EMMC::MMIO::EMMCHC_RESP3_2. Read-only. Reset: 0000_0000h.">
      <field name="RESPONSE3" bit="16" size="16" desc="Read-only. Reset: 0000h. R[71:56] of the response is saved in this field. The response value is preseved until the next response." />
      <field name="RESPONSE2" bit="0" size="16" desc="Read-only. Reset: 0000h. R[55:40] of the response is saved in this field." />
    </register>

    <!-- page 384 -->

    <register name="EMMCHC_RESP5_4" type="memory" device="EMMCHC" offset="0x00000018" size="4" desc="FCH::EMMC::MMIO::EMMCHC_RESP5_4. Read-only. Reset: 0000_0000h.">
      <field name="RESPONSE5" bit="16" size="16" desc="Read-only. Reset: 0000h. R[103-88] of the response is saved in this field. The response value is preseved until the next response." />
      <field name="RESPONSE4" bit="0" size="16" desc="Read-only. Reset: 0000h. R[87:72] of the response is saved in this field." />
    </register>
    <register name="EMMCHC_RESP7_6" type="memory" device="EMMCHC" offset="0x0000001C" size="4" desc="FCH::EMMC::MMIO::EMMCHC_RESP7_6. Read-only. Reset: 0000_0000h.">
      <field name="RESPONSE7" bit="16" size="16" desc="Read-only. Reset: 0000h. R[127:120] of the response or R[39:24] of the Auto CMD12 response is saved in this field. The response value is preseved until the next response." />
      <field name="RESPONSE6" bit="0" size="16" desc="Read-only. Reset: 0000h. R[119:104] of the response or R[23:8] of the Auto CMD12 response is saved in this field." />
    </register>
    <register name="EMMCHC_BUF_PORT" type="memory" device="EMMCHC" offset="0x00000020" size="4" desc="FCH::EMMC::MMIO::EMMCHC_BUF_PORT. Read-write. Reset: 0000_0000h.">
      <field name="DATA_BUF_PORT" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Data Buffer. Data will be accessed through this register. Data which exceeds the size designated by the Block Size Register will not be written in the data buffer." />
    </register>
    <register name="EMMCHC_PRSNT_STATE" type="memory" device="EMMCHC" offset="0x00000024" size="4" desc="FCH::EMMC::MMIO::EMMCHC_PRSNT_STATE. Read-only.">
      <!-- Bits 31:29 reserved. -->
      <field name="DAT_LEVEL2" bit="25" size="4" desc="Read-only. Reset: 0h. DAT[7:4]." />
      <field name="CMD_LEVEL" bit="24" size="1" desc="Read-only. Reset: 0. CMD Line Signal Level. Reflects signal level of CMD line. This is used for testing." />
      <field name="DAT_LEVEL1" bit="20" size="4" desc="Read-only. Reset: 0h. DAT Line Signal level. Reflects signal level of DAT line. This is used for testing." />
      <field name="WP_LEVEL" bit="19" size="1" desc="Read-only. Reset: 0. 0=Write protected. 1=Write enable. Write Protect Switch level." />
      <field name="CD_LEVEL" bit="18" size="1" desc="Read-only. Reset: 0. 0=No card present. 1=Card present. Card Detect Pin level. This bit is used for testing." />
      <field name="CARD_STABLE" bit="17" size="1" desc="Read-only. Reset: 0. 0=Not stable (debouncing or resetting). 1=Card stable. Card state stable. Indicats Card Detect signal level is stable. This bit is used for testing." />
      <field name="CARD_INSERT" bit="16" size="1" desc="Read-only. Reset: 0. 0=No card inserted or debouncing state or resetting. 1=Card inserted. Card inserted." />
      <!-- Bits 15:12 reserved. -->
      <field name="BUF_RD_EN" bit="11" size="1" desc="Read-only. Reset: 0. 0=Read disable. 1=Read enable. Buffer Read Enable. Indicates buffer is ready for reading." />
      <field name="BUF_WR_EN" bit="10" size="1" desc="Read-only. Reset: 0. 0=Write disable. 1=Write enable. Buffer Write Enable. Indicates buffer is ready for Writing." />
      <field name="RD_TX_ACT" bit="9" size="1" desc="Read-only. Reset: 0. 0=No data transferring. 1=Read data transferring. Read Transfer Active. Indicates duration of Read data transfer." />
      <field name="WR_TX_ACT" bit="8" size="1" desc="Read-only. Reset: 0. 0=No data transferring. 1=Write data transferring. Write Transfer Active. Indicates duration of Write data transfer." />
      <!-- Bits 7:3 reserved. -->
      <field name="DAT_LINE_ACT" bit="2" size="1" desc="Read-only. Reset: 0. 0=DAT line inactive. 1=DAT line active. DAT Line Active. Indicates the DAT line on SD Bus is active." />
      <field name="CMD_INHIBIT_DAT" bit="1" size="1" desc="Read-only. Reset: 0. 0=Can issue commands which use the DAT line. 1=Cannot issue any commands which use the DAT line. Command Inhibit (DAT). Indicates that commands which also use the DAT line can be issued." />
      <field name="CMD_INHIBIT_CMD" bit="0" size="1" desc="Read-only. Reset: 0. 0=Can issue commands which use the CMD line. 1=Cannot issue any commands. Command Inhibit (CMD). Indicates that commands which use only the CMD line can be issued." />
    </register>

    <!-- page 385 -->

    <register name="EMMCHC_CTRL1" type="memory" device="EMMCHC" offset="0x00000028" size="4" desc="FCH::EMMC::MMIO::EMMCHC_CTRL1.">
      <!-- Bits 31:27 reserved. -->
      <field name="WAKEUP_RM_EN" bit="26" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. SD Card Removal Wakeup." />
      <field name="WAKEUP_INS_EN" bit="25" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. SD Card Insertion Wakeup." />
      <field name="WAKEUP_INT_EN" bit="24" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. SD Card Interrupt Wakeup." />
      <!-- Bits 23:20 reserved. -->
      <field name="BG_INT_EN" bit="19" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Interrupt at Block Gap. Enable interrupt detection during 4-bit block transmission." />
      <field name="RD_WAIT_EN" bit="18" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Read Wait Control. Indicates Read Wait will be inserted when needed." />
      <field name="CONT_REQ" bit="17" size="1" desc="Read-write. Reset: 0. 0=No effect. 1=Restart. Continue Request. Writing 1 to this bit triggers restart of halted data transaction with current register setting. Once this bit is 1, the internal buffer will be cleared and data transfer sequence will be restarted." />
      <field name="BG_STOP_REQ" bit="16" size="1" desc="Read-write. Reset: 0. 0=Transfer. 1=Stop. Stop at Block Gap Request. Writing 1 to this bit triggers halting of the current data transfer after the next block gap. For using this request, the Read Wait function is necessary in a Read transaction. Even if the Auto CMD12 enable bit is set to 1, Auto CMD12 is not issued in case this bit is set to 1. This bit is cleared by not only writing 0 to this bit, but also issuing abort commands." />
      <!-- Bits 15:12 reserved. -->
      <field name="BUS_VOLT_SEL" bit="9" size="3" desc="Read-write. Reset: 0h. Reserved. Not used in EMMC. Use FCH::EMMC::MMIO::EMMCHC_ACMD_ERR_CTRL2[VOL18_EN] instead." />
      <field name="BUS_PWR" bit="8" size="1" desc="Read-write. Reset: 0. 0=Off. 1=On. SD Bus Power. When card is removed, this bit is cleared automatically." />
      <field name="CD_SIG_SEL" bit="7" size="1" desc="Read-write. Reset: 0. 0=IO pin. 1=SD_TEST_LEVEL. Card Detect Signal selection. This is for testing." />
      <field name="CD_TEST_LEVEL" bit="6" size="1" desc="Read-write. Reset: 0. 0=Card removed. 1=Card inserted. Card Detect Test Level. This is for testing." />
      <field name="EXT_WIDTH" bit="5" size="1" desc="Read-write. Reset: 0. 0=Use width set by DAT_XFER_WIDTH. 1=8-bit width. Extended Data Transfer Width (MMC)." />
      <field name="DMA_SEL" bit="3" size="2" desc="Read-write. Reset: 0h. DMA Select. Valid only when DMA is enabled." />
      <field name="HS_EN" bit="2" size="1" desc="Read-write. Reset: 0. 0=Normal speed. 1=High-speed. High Speed Enable. When disabled, SD controller outputs commands and data on the falling edge of the SD clock (Up to 25 MHz SD clock can be supported). When enabled, SD controller outputs commands and data on the rising edge of the SD clock (Up to 50 MHz SD clock can be supported)." />
      <field name="DAT_XFER_WIDTH" bit="1" size="1" desc="Read-write. Reset: 0. 0=1-bit. 1=4-bit. Data Transfer Width." />
      <field name="LED_CTRL" bit="0" size="1" desc="Read-write. Reset: 0. 0=Off. 1=On. LED control. Drives the LED_ON output." />
    </register>

    <!-- page 386 -->

    <register name="EMMCHC_CTRL2" type="memory" device="EMMCHC" offset="0x0000002C" size="4" desc="FCH::EMMC::MMIO::EMMCHC_CTRL2.">
      <!-- Bits 31:27 reserved. -->
      <field name="SRST_DAT" bit="26" size="1" desc="Read-write. Reset: 0. 0=No effect. 1=Reset DAT Line." />
      <field name="SRST_CMD" bit="25" size="1" desc="Read-write. Reset: 0. 0=No effect. 1=Reset CMD Line." />
      <field name="SRST_ALL" bit="24" size="1" desc="Read-write. Reset: 0. 0=No effect. 1=Reset all." />
      <!-- Bits 23:20 reserved. -->
      <field name="DAT_TO_CNT" bit="16" size="4" desc="Read-write. Reset: 0h. Data Timeout Counter Value. By using this counter value, DAT line timeouts are detected." />
      <field name="CLK_FREQ_SEL" bit="8" size="8" desc="Read-write. Reset: 00h. SDCLK Frequency Select. If multiple bits are set, most significant bit will be selected." />
      <field name="CLK_FREQ_SEL_UP" bit="6" size="2" desc="Read-write. Reset: 0h. Upper Bits of SDCLK Frequency Select." />
      <field name="CLK_GEN_SEL" bit="5" size="1" desc="Read-write. Reset: 0. 0=Divided Clock mode. 1=Programmable Clock mode. Clock Generator select." />
      <!-- Bits 4:3 reserved. -->
      <field name="CLK_EN" bit="2" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. SD Clock Enable. SDCLK Frequency Select can be changed when this bit is 0. When card is removed, this bit is cleared to 0 automatically." />
      <field name="INTNCLK_STABLE" bit="1" size="1" desc="Read-only. Reset: 0. 0=Unstable. 1=Stable. Internal clock stable." />
      <field name="INTNCLK_EN" bit="0" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Internal clock enable." />
    </register>

    <!-- page 387 -->

    <register name="EMMCHC_INT_STS" type="memory" device="EMMCHC" offset="0x00000030" size="4" desc="FCH::EMMC::MMIO::EMMCHC_INT_STS.">
      <!-- Bits 31:30 reserved. -->
      <field name="CE_ATA_ERR" bit="29" size="1" desc="Read-only. Reset: 0. CE-ATA Error." />
      <field name="SDMA_ERR" bit="28" size="1" desc="Read,Write-1-to-clear. Reset: 0. SDMA Error." />
      <!-- Bit 27 reserved. -->
      <field name="TUNING_ERR" bit="26" size="1" desc="Read,Write-1-to-clear. Reset: 0. Tuning Error." />
      <field name="ADMA_ERR" bit="25" size="1" desc="Read,Write-1-to-clear. Reset: 0. ADMA Error." />
      <field name="ACMD_ERR" bit="24" size="1" desc="Read,Write-1-to-clear. Reset: 0. Auto CMD12 Error. Loginal OR of Auto CMD12 Error Status register." />
      <field name="CUR_LIM_ERR" bit="23" size="1" desc="Read,Write-1-to-clear. Reset: 0. Reserved." />
      <field name="DAT_END_ERR" bit="22" size="1" desc="Read,Write-1-to-clear. Reset: 0. Data CRC Error." />
      <field name="DAT_CRC_ERR" bit="21" size="1" desc="Read,Write-1-to-clear. Reset: 0. Data CRC Error." />
      <field name="DAT_TO_ERR" bit="20" size="1" desc="Read,Write-1-to-clear. Reset: 0. Data Timeout Error." />
      <field name="CMD_IDX_ERR" bit="19" size="1" desc="Read,Write-1-to-clear. Reset: 0. Command Index Error. Mismatch of Command Index and index of response." />
      <field name="CMD_END_ERR" bit="18" size="1" desc="Read,Write-1-to-clear. Reset: 0. Command End Bit Error." />
      <field name="CMD_CRC_ERR" bit="17" size="1" desc="Read,Write-1-to-clear. Reset: 0. Command CRC Error. If both CMD_TO_ERR and CMD_CRC_ERR set, this indicates Command Conflict Error." />
      <field name="CMD_TO_ERR" bit="16" size="1" desc="Read,Write-1-to-clear. Reset: 0. Command Timeout Error. Response not returned within 128 SDCLK cycles." />
      <field name="ERR_INT" bit="15" size="1" desc="Read-only. Reset: 0. Error Interrupt." />
      <!-- Bits 14:13 reserved. -->
      <field name="RE_RUNING" bit="12" size="1" desc="Read-only. Reset: 0. Re-Tuning Event. This status is set if Re-Tuning Request in the Present State register changes from 0 to 1." />
      <field name="INT_C" bit="11" size="1" desc="Read-only. Reset: 0. INT_C. This Status is set if INT_C is enabled and INT_C# pin is in low level." />
      <field name="INT_B" bit="10" size="1" desc="Read-only. Reset: 0. INT_B. This Status is set if INT_B is enabled and INT_B# pin is in low level." />
      <field name="INT_A" bit="9" size="1" desc="Read-only. Reset: 0. INT_A. This Status is set if INT_A is enabled and INT_A# pin is in low level." />
      <field name="CARD_INT" bit="8" size="1" desc="Read-only. Reset: 0. SDIO Card Interrupt. Writing 1 to this register does not clear this bit. For clearing this bit, interrupt factor of SDIO cards should be cleared. The value of this bit is latched internally as long as the Card Interrupt bit (D08) in the Normal Interrupt Status Enable Register is 1." />
      <field name="CARD_RM" bit="7" size="1" desc="Read,Write-1-to-clear. Reset: 0. Card Removal." />
      <field name="CARD_INS" bit="6" size="1" desc="Read,Write-1-to-clear. Reset: 0. Card Insertion." />
      <field name="BUF_RD_RDY" bit="5" size="1" desc="Read,Write-1-to-clear. Reset: 0. Buffer Read Ready. In case that Auto CMD12 is enabled and last block has been transferred, Auto CMD12 will be issued prior to this bit being set to 1. Clearing this bit should  be done before buffer reading, because SD controller has dual buffer and the next Buffer Read Ready interrupt may occur immediately." />
      <field name="BUF_WR_RDY" bit="4" size="1" desc="Read,Write-1-to-clear. Reset: 0. Buffer Write Ready. Clearing this bit should be done before buffer writing, because SD controller has dual buffer and the next Buffer Write Ready interrupt may occurr immediately." />
      <field name="DMA_INT" bit="3" size="1" desc="Read,Write-1-to-clear. Reset: 0. DMA Interrupt. It is set when the internal counter reaches the value designated by Host DMA Buffer Boundary. It should be cleared by Host Driver after System Address Register is updated." />
      <field name="BLOCK_GAP_EVT" bit="2" size="1" desc="Read,Write-1-to-clear. Reset: 0. Block Gap Event. It indicates the timing of next block gap, which is requested by the Stop At Block Gap Request. In case of a write transaction, this interrupt will be generated before busy completion." />
      <field name="XFER_DONE" bit="1" size="1" desc="Read,Write-1-to-clear. Reset: 0. Data Transfer Complete. Indicates the timing for completion of data transaction which includes the completion at the block gap by the Stop At Block Gap Request. When some errors are detected during data transaction, this bit will not be set. In case that Auto CMD12 is enabled, Auto CMD12 will be issued prior to this bit being set to 1." />
      <field name="CMD_DONE" bit="0" size="1" desc="Read,Write-1-to-clear. Reset: 0. Command Complete. The end bit of the command response is received. In the case of commands with no response, the end of the command." />
    </register>

    <!-- page 388 -->

    <register name="EMMCHC_INT_STS_EN" type="memory" device="EMMCHC" offset="0x00000034" size="4" desc="FCH::EMMC::MMIO::EMMCHC_INT_STS_EN.">
      <!-- Bits 31:30 reserved. -->
      <field name="CE_ATA_ERR_EN" bit="29" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. CE-ATA Error Status enable." />
      <field name="SDMA_ERR_EN" bit="28" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. SDMA Error Status enable." />
      <!-- Bits 27:26 reserved. -->
      <field name="ADMA_ERR_EN" bit="25" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. ADMA Error Status enable." />
      <field name="ACMD_ERR_EN" bit="24" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Auto CMD12 Error Status enable." />
      <field name="CUR_LIM_ERR_EN" bit="23" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Current Limit Error Status enable." />
      <field name="DAT_END_ERR_EN" bit="22" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Data End Bit Error Status enable." />
      <field name="DAT_CRC_ERR_EN" bit="21" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Data CRC Error Status enable." />
      <field name="DAT_TO_ERR_EN" bit="20" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Data Timeout Error Status enable." />
      <field name="CMD_IDX_ERR_EN" bit="19" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Command Index Error Status enable." />
      <field name="CMD_END_ERR_EN" bit="18" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Command End Bit Error Status enable." />
      <field name="CMD_CRC_ERR_EN" bit="17" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Command CRC Error Status enable." />
      <field name="CMD_TO_ERR_EN" bit="16" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Command Timeout Error Status enable." />
      <!-- Bits 15:13 reserved. -->
      <field name="RE_RUNING_EN" bit="12" size="1" desc="Read-only. Reset: 0. 0=Masked. 1=Enable. Re-Tuning Event Status enable." />
      <field name="INT_C_EN" bit="11" size="1" desc="Read-only. Reset: 0. 0=Masked. 1=Enable. INT_C Status enable." />
      <field name="INT_B_EN" bit="10" size="1" desc="Read-only. Reset: 0. 0=Masked. 1=Enable. INT_B Status enable." />
      <field name="INT_A_EN" bit="9" size="1" desc="Read-only. Reset: 0. 0=Masked. 1=Enable. INT_A Status enable." />
      <field name="CARD_INT_EN" bit="8" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Card Interrupt Status enable." />
      <field name="CARD_RM_EN" bit="7" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Card Removal Status enable." />
      <field name="CARD_INS_EN" bit="6" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Card Insertion Status enable." />
      <field name="BUF_RD_RDY_EN" bit="5" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Buffer Read Ready Status enable." />
      <field name="BUF_WR_RDY_EN" bit="4" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Buffer Write Ready Status enable." />
      <field name="DMA_INT_EN" bit="3" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. DMA Interrupt Status enable." />
      <field name="BLOCK_GAP_EVT_EN" bit="2" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Block Gap Event Status enable." />
      <field name="XFER_DONE_EN" bit="1" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Transfer Complete Status enable." />
      <field name="CMD_DONE_EN" bit="0" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Command Complete Status enable." />
    </register>

    <!-- page 389 -->

    <register name="EMMCHC_INT_EN" type="memory" device="EMMCHC" offset="0x00000038" size="4" desc="FCH::EMMC::MMIO::EMMCHC_INT_EN.">
      <!-- Bits 31:30 reserved. -->
      <field name="CE_ATA_ERR_EN" bit="29" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. CE-ATA Error Signal enable." />
      <field name="SDMA_ERR_EN" bit="28" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. SDMA Error Signal enable." />
      <!-- Bits 27:26 reserved. -->
      <field name="ADMA_ERR_EN" bit="25" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. ADMA Error Signal enable." />
      <field name="ACMD_ERR_EN" bit="24" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Auto CMD12 Error Signal enable." />
      <field name="CUR_LIM_ERR_EN" bit="23" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Current Limit Error Signal enable." />
      <field name="DAT_END_ERR_EN" bit="22" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Data End Bit Error Signal enable." />
      <field name="DAT_CRC_ERR_EN" bit="21" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Data CRC Error Signal enable." />
      <field name="DAT_TO_ERR_EN" bit="20" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Data Timeout Error Signal enable." />
      <field name="CMD_IDX_ERR_EN" bit="19" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Command Index Error Signal enable." />
      <field name="CMD_END_ERR_EN" bit="18" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Command End Bit Error Signal enable." />
      <field name="CMD_CRC_ERR_EN" bit="17" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Command CRC Error Signal enable." />
      <field name="CMD_TO_ERR_EN" bit="16" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Command Timeout Error Signal enable." />
      <!-- Bits 15:13 reserved. -->
      <field name="RE_RUNING_EN" bit="12" size="1" desc="Read-only. Reset: 0. 0=Masked. 1=Enable. Re-Tuning Event Signal enable." />
      <field name="INT_C_EN" bit="11" size="1" desc="Read-only. Reset: 0. 0=Masked. 1=Enable. INT_C Signal enable." />
      <field name="INT_B_EN" bit="10" size="1" desc="Read-only. Reset: 0. 0=Masked. 1=Enable. INT_B Signal enable." />
      <field name="INT_A_EN" bit="9" size="1" desc="Read-only. Reset: 0. 0=Masked. 1=Enable. INT_A Signal enable." />
      <field name="CARD_INT_EN" bit="8" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Card Interrupt Signal enable." />
      <field name="CARD_RM_EN" bit="7" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Card Removal Signal enable." />
      <field name="CARD_INS_EN" bit="6" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Card Insertion Signal enable." />
      <field name="BUF_RD_RDY_EN" bit="5" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Buffer Read Ready Signal enable." />
      <field name="BUF_WR_RDY_EN" bit="4" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Buffer Write Ready Signal enable." />
      <field name="DMA_INT_EN" bit="3" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. DMA Interrupt Signal enable." />
      <field name="BLOCK_GAP_EVT_EN" bit="2" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Block Gap Event Signal enable." />
      <field name="XFER_DONE_EN" bit="1" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Transfer Complete Signal enable." />
      <field name="CMD_DONE_EN" bit="0" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enable. Command Complete Signal enable." />
    </register>
    <register name="EMMCHC_ACMD_ERR_CTRL2" type="memory" device="EMMCHC" offset="0x0000003C" size="4" desc="FCH::EMMC::MMIO::EMMCHC_ACMD_ERR_CTRL2.">
      <field name="RESET_VAL_EN" bit="31" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Preset value enable." />
      <field name="ASYN_INT_EN" bit="30" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Asynchronous Interrupt enable." />
      <!-- Bits 29:24 reserved. -->
      <field name="SAMPLING_CLK" bit="23" size="1" desc="Read-write. Reset: 0. Sampling Clock select." />
      <field name="EXE_TUNING" bit="22" size="1" desc="Read-write. Reset: 0. 0=No effect. 1=Execute tuning. Execute tuning." />
      <field name="DRV_STR" bit="20" size="2" desc="Read-write. Reset: 0h. Driver strength select." />
      <field name="VOL18_EN" bit="19" size="1" desc="Read-write. Reset: 0. 1.8V Signaling Enable; this bit controls voltage 3.3/1.8v select. we should setting this bit first when use emmc" />
      <field name="UHS_MODE" bit="16" size="3" desc="Read-write. Reset: 0h. UHS mode select." />
      <!-- Bits 15:8 reserved. -->
      <field name="NOT_ISSUE_ERR" bit="7" size="1" desc="Read-only. Reset: 0. Command not issued by Auto CMD12 error." />
      <!-- Bits 6:5 reserved. -->
      <field name="IND_ERR" bit="4" size="1" desc="Read-only. Reset: 0. Auto CMD12 Index error." />
      <field name="END_ERR" bit="3" size="1" desc="Read-only. Reset: 0. Auto CMD12 End Bit error." />
      <field name="CRC_ERR" bit="2" size="1" desc="Read-only. Reset: 0. Auto CMD12 CRC error." />
      <field name="TO_ERR" bit="1" size="1" desc="Read-only. Reset: 0. Auto CMD12 Timeout error." />
      <field name="NOT_EXE_ERR" bit="0" size="1" desc="Read-only. Reset: 0. Auto CMD12 not executed error." />
    </register>

    <!-- page 390 -->

    <register name="EMMCHC_CAP1" type="memory" device="EMMCHC" offset="0x00000040" size="4" desc="FCH::EMMC::MMIO::EMMCHC_CAP1. Read-only.">
      <field name="SLOT_TYPE" bit="30" size="2" desc="Read-only. Reset: 0h. Slot type." />
      <field name="ASYN_INT_SUP" bit="29" size="1" desc="Read-only. Reset: 0. Asynchronous Interrupt support." />
      <field name="SYS_BUS64_SUP" bit="28" size="1" desc="Read-only. Reset: 0. 64-bit System Bus support." />
      <!-- Bit 27 reserved. -->
      <field name="V18_SUP" bit="26" size="1" desc="Read-only. Reset: 0. Voltage support 1.8V." />
      <field name="V30_SUP" bit="25" size="1" desc="Read-only. Reset: 0. Voltage support 3.0V." />
      <field name="V33_SUP" bit="24" size="1" desc="Read-only. Reset: 1. Voltage support 3.3V." />
      <field name="SUS_RES_SUP" bit="23" size="1" desc="Read-only. Reset: 1. Suspend/Resume support." />
      <field name="SDMA_SUP" bit="22" size="1" desc="Read-only. Reset: 0. SDMA support." />
      <field name="HS_SUP" bit="21" size="1" desc="Read-only. Reset: 1. High-speed support." />
      <!-- Bit 20 reserved. -->
      <field name="ADMA2_SUP" bit="19" size="1" desc="Read-only. Reset: 0. ADMA2 support." />
      <field name="WIDTH_8_SUP" bit="18" size="1" desc="Read-only. Reset: 1. 8-bit support for Embedded Device." />
      <field name="MAX_BLK_LEN" bit="16" size="2" desc="Read-only. Reset: 2h. Max block length." />
      <field name="BASE_CLK_FREQ" bit="8" size="8" desc="Read-only. Reset: 18h. Base clock frequency for SD clock." />
      <field name="TO_CLK_UNIT" bit="7" size="1" desc="Read-only. Reset: 1. Timeout clock unit." />
      <!-- Bit 6 reserved. -->
      <field name="TO_CLK_FREQ" bit="0" size="6" desc="Read-only. Reset: 18h. Timeout clock frequency." />
    </register>

    <!-- page 391 -->

    <register name="EMMCHC_CAP2" type="memory" device="EMMCHC" offset="0x00000044" size="4" desc="FCH::EMMC::MMIO::EMMCHC_CAP2. Read-only.">
      <!-- Bits 31:24 reserved. -->
      <field name="CLK_MULTI" bit="16" size="8" desc="Read-only. Reset: 00h. Clock multiplier." />
      <field name="RETUNING_MODE" bit="14" size="2" desc="Read-only. Reset: 0h. Re-Tuning modes." />
      <field name="SDR50_TUNING" bit="13" size="1" desc="Read-only. Reset: 0. Use Tuning for SDR50." />
      <!-- Bit 12 reserved. -->
      <field name="TO_RETUNING" bit="8" size="4" desc="Read-only. Reset: 0h. Timer Count for Re-Tuning." />
      <!-- Bit 7 reserved. -->
      <field name="DRV_D_SUP" bit="6" size="1" desc="Read-only. Reset: 0. Driver Type D support." />
      <field name="DRV_C_SUP" bit="5" size="1" desc="Read-only. Reset: 0. Driver Type C support." />
      <field name="DRV_A_SUP" bit="4" size="1" desc="Read-only. Reset: 0. Driver Type A support." />
      <!-- Bit 3 reserved. -->
      <field name="DDR50_SUP" bit="2" size="1" desc="Read-only. Reset: 1. DDR50 support." />
      <field name="SDR104_SUP" bit="1" size="1" desc="Read-only. Reset: 1. SDR104 support." />
      <field name="SDR50_SUP" bit="0" size="1" desc="Read-only. Reset: 1. SDR50 support." />
    </register>
    <register name="EMMCHC_CURR_CAP" type="memory" device="EMMCHC" offset="0x00000048" size="4" desc="FCH::EMMC::MMIO::EMMCHC_CURR_CAP. Read-only.">
      <!-- Bits 31:24 reserved. -->
      <field name="MAX_CURR_V18" bit="16" size="8" desc="Read-only. Reset: 00h. Maximum current for 1.8V." />
      <field name="MAX_CURR_V30" bit="8" size="8" desc="Read-only. Reset: 00h. Maximum current for 3.0V." />
      <field name="MAX_CURR_V33" bit="0" size="8" desc="Read-only. Reset: 64h. Maximum current for 3.3V." />
    </register>
    <register name="EMMCHC_CURR_CAP2" type="memory" device="EMMCHC" offset="0x0000004C" size="4" desc="FCH::EMMC::MMIO::EMMCHC_CURR_CAP2. Read-only. Reset: Fixed,0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="EMMCHC_FORCE_EVT" type="memory" device="EMMCHC" offset="0x00000050" size="4" desc="FCH::EMMC::MMIO::EMMCHC_FORCE_EVT.">
      <!-- Bits 31:30 reserved. -->
      <field name="CE_ATA_ERR" bit="29" size="1" desc="Write-only. Reset: 0. 0=No effect. 1=Force event. Force CE-ATA Error." />
      <field name="SDMA_ERR" bit="28" size="1" desc="Write-only. Reset: 0. 0=No effect. 1=Force event. Force SDMA error." />
      <!-- Bits 27:26 reserved. -->
      <field name="ADMA_ERR" bit="25" size="1" desc="Write-only. Reset: 0. 0=No effect. 1=Force event. Force ADMA error." />
      <field name="ACMD_ERR" bit="24" size="1" desc="Write-only. Reset: 0. 0=No effect. 1=Force event. Force Auto CMD12 error." />
      <field name="CUR_LIM_ERR" bit="23" size="1" desc="Write-only. Reset: 0. 0=No effect. 1=Force event. Force Current Limit error." />
      <field name="DAT_END_ERR" bit="22" size="1" desc="Write-only. Reset: 0. 0=No effect. 1=Force event. Force Data End Bit error." />
      <field name="DAT_CRC_ERR" bit="21" size="1" desc="Write-only. Reset: 0. 0=No effect. 1=Force event. Force Data CRC error." />
      <field name="DAT_TO_ERR" bit="20" size="1" desc="Write-only. Reset: 0. 0=No effect. 1=Force event. Force Data Timeout error." />
      <field name="CMD_IDX_ERR" bit="19" size="1" desc="Write-only. Reset: 0. 0=No effect. 1=Force event. Force Command Index error." />
      <field name="CMD_END_ERR" bit="18" size="1" desc="Write-only. Reset: 0. 0=No effect. 1=Force event. Force Command End Bit error." />
      <field name="CMD_CRC_ERR" bit="17" size="1" desc="Write-only. Reset: 0. 0=No effect. 1=Force event. Force Command CRC error." />
      <field name="CMD_TO_ERR" bit="16" size="1" desc="Write-only. Reset: 0. 0=No effect. 1=Force event. Force Command Timeout error." />
      <!-- Bits 15:8 reserved. -->
      <field name="ACMD12_ISS_ERR" bit="7" size="1" desc="Write-only. Reset: 0. 0=No effect. 1=Force event. Force Command Not Issued By Auto CMD12 error." />
      <!-- Bits 6:5 reserved. -->
      <field name="ACMD_IDX_ERR" bit="4" size="1" desc="Write-only. Reset: 0. 0=No effect. 1=Force event. Force Auto CMD12 Index error." />
      <field name="ACMD_END_ERR" bit="3" size="1" desc="Write-only. Reset: 0. 0=No effect. 1=Force event. Force Auto CMD12 End Bit error." />
      <field name="ACMD_CRC_ERR" bit="2" size="1" desc="Write-only. Reset: 0. 0=No effect. 1=Force event. Force Auto CMD12 CRC error." />
      <field name="ACMD_TO_ERR" bit="1" size="1" desc="Write-only. Reset: 0. 0=No effect. 1=Force event. Force Auto CMD12 Timeout error." />
      <field name="ACMD12_EXE_ERR" bit="0" size="1" desc="Write-only. Reset: 0. 0=No effect. 1=Force event. Force Auto CMD12 Not Executed error." />
    </register>

    <!-- page 392 -->

    <register name="EMMCHC_ADMA_ERR_STS" type="memory" device="EMMCHC" offset="0x00000054" size="4" desc="FCH::EMMC::MMIO::EMMCHC_ADMA_ERR_STS. Read-only.">
      <!-- Bits 31:3 reserved. -->
      <field name="ADDR_LEN_MISMATCH" bit="2" size="1" desc="Read-only. Reset: 0." />
      <field name="ERR_STATE" bit="0" size="2" desc="Read-only. Reset: 0h. ADMA state when error occured." />
    </register>
    <register name="EMMCHC_ADMA_SYSADDR" type="memory" device="EMMCHC" offset="0x00000058" size="4" desc="FCH::EMMC::MMIO::EMMCHC_ADMA_SYSADDR. Read-write. Reset: 0000_0000h.">
      <field name="ADMA_SYS_ADDR0" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Lower bits of ADMA system address. See also FCH::EMMC::MMIO::EMMCHC_ADMA_SYSADDR_UP." />
    </register>
    <register name="EMMCHC_ADMA_SYSADDR_UP" type="memory" device="EMMCHC" offset="0x0000005C" size="4" desc="FCH::EMMC::MMIO::EMMCHC_ADMA_SYSADDR_UP. Read-write. Reset: 0000_0000h.">
      <field name="ADMA_SYS_ADDR1" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Upper bits of ADMA System Address. Before ADMA data transfer, the descriptor address should be set by the Host driver. This address needs to be set with 4-byte alignment, since the descriptor table is 32-bit (4 byte) information formatted." />
    </register>
    <register name="EMMCHC_CE_ATA_CTRL" type="memory" device="EMMCHC" offset="0x00000080" size="4" desc="FCH::EMMC::MMIO::EMMCHC_CE_ATA_CTRL.">
      <!-- Bits 31:5 reserved. -->
      <field name="CE_ATA_SUPPORT" bit="4" size="1" desc="Read-only. Reset: 1. 0=Unsupported. 1=Supported. CE-ATA support capability. When supported, bits[3:0] can be written." />
      <field name="CE_ATA_EN" bit="3" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. CE-ATA enable. When enabled bits[2:0] can be written." />
      <field name="P_DRIVE_DIS" bit="2" size="1" desc="Read-write. Reset: 0. 0=Enable. 1=Disable. P-Drive disable." />
      <field name="CMD_COMP_DIS_EN" bit="1" size="1" desc="Read-write. Reset: 0. 0=Wait after command. 1=Issued after command. Command Completion Signal Disable enable." />
      <field name="CMD_COMP_SIG_EN" bit="0" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Command Completion Signal enable. When the Command Completion Signal is enabled, the Auto CMD12 Enable bit in the Transfer Mode register becomes of no use." />
    </register>

    <!-- page 393 -->

    <register name="EMMCHC_DAT3_CARD_DET" type="memory" device="EMMCHC" offset="0x00000090" size="4" desc="FCH::EMMC::MMIO::EMMCHC_DAT3_CARD_DET.">
      <!-- Bits 31:5 reserved. -->
      <field name="DEBOUNCING_EN" bit="4" size="1" desc="Read-write. Reset: 1. 0=Disable. 1=Enable. Debouncing enable. This bit should be cleared before starting command or data transfer if debouncing state is not needed in the error cases." />
      <field name="DEBOUNCING_STATUS" bit="3" size="1" desc="Read-only. Reset: 0. 0=Not debouncing. 1=Debouncing. Debouncing State status. Indicates the card is debouncing. Should not issue any command during debouncing." />
      <field name="CARD_DETECT_SEL" bit="2" size="1" desc="Read-only. Reset: 0. 0=Standard Card Detect mode. 1=DAT3 Card Detect mode. Card Detct Select status." />
      <field name="DAT3_DETECT_EN" bit="1" size="1" desc="Read-write. Reset: 1. 0=Disable. 1=Enable. DAT3 Card Detect control. Disable this bit before writing the Command Register. After Command or Transfer complete, this bit can be re-enabled. During command and data transfer, enabling DAT3 Card Detection is prohibited. This bit is fixed to 1 in Standard Card Detect mode." />
      <field name="DAT3_CARD_INS" bit="0" size="1" desc="Read-only. Reset: 0. 0=No card inserted. 1=Card inserted. DAT3 Card inserted." />
    </register>
    <register name="EMMCHC_SLOT_VER" type="memory" device="EMMCHC" offset="0x000000FC" size="4" desc="FCH::EMMC::MMIO::EMMCHC_SLOT_VER. Read-only.">
      <field name="VENDOR_VERSION" bit="24" size="8" desc="Read-only. Reset: C3h. Vendor version." />
      <field name="SPEC_VERSION" bit="16" size="8" desc="Read-only. Reset: 02h. Specification version." />
      <!-- Bits 15:8 reserved. -->
      <field name="SLOT_INTRPT" bit="0" size="8" desc="Read-only. Reset: 00h. Interrupt Signal for each slot. The value of XSLT_INT[7:0] inputs, which indicates the logical OR of the Interrupt signal and Wakeup signal, are inverted and referred by this register. In case of multiple slots, Interrupt signal and Wakeup signal should be logically ORed externally and should be inputted to each of XSLT_INT[7:0]." />
    </register>

    <!-- 9.2.3.1 IOAPIC Registers -->

    <register name="IOSel" type="memory" device="IOAPIC" offset="0x0000" size="4" desc="IO Register Select Register. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:8 reserved. -->
      <field name="IndirectAddressOffset" bit="0" size="8" desc="Read-write. Reset: 00h. Indirect Address Offset to IO Window Register. Determines which register is manipulated during an IO window register Read/Write operation." />
    </register>

    <!-- page 394 -->

    <register name="IOWindow" type="memory" device="IOAPIC" offset="0x0010" size="4" desc="IO Window Register. Read-write. Reset: 0000_0000h.">
      <field name="IOWindow" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Mapped by FCH::IOAPIC::IOSel to the designated indirect access register." />
    </register>
    <register name="IOAPICID" type="memory" device="IOAPIC" offset="0x0010" size="4" desc="IOAPICID. Read-write. Reset: 0000_0000h. This register is not used in IOxAPIC PCI bus delivery mode. Precondition (data port): IOSel[IndirectAddressOffset] = indirectaddressoffset00.">
      <!-- Bits 31:28 reserved. -->
      <field name="ID" bit="24" size="4" desc="Read-write. Reset: 0h. IOAPIC device ID." />
      <!-- Bits 23:0 reserved. -->
    </register>
    <register name="IOAPICVersion" type="memory" device="IOAPIC" offset="0x0010" size="4" desc="IOAPICVersion. Read-only. Reset: 0017_8021h. Precondition (data port): IOSel[IndirectAddressOffset] = indirectaddressoffset01.">
      <!-- Bits 31:24 reserved. -->
      <field name="MaxRedirectionEntries" bit="16" size="8" desc="Read-only. Reset: 17h. Indicates 24 entries [23:0]." />
      <field name="PRQ" bit="15" size="1" desc="Read-only. Reset: 1. IRQ pin assertion supported." />
      <!-- Bits 14:8 reserved. -->
      <field name="Version" bit="0" size="8" desc="Read-only. Reset: 21h. PCI 2.2 compliant." />
    </register>
    <register name="IOAPICArb" type="memory" device="IOAPIC" offset="0x0010" size="4" desc="IOAPICArb. Read-only,Volatile. Reset: 0000_0000h. This register is not used in IOxAPIC PCI bus delivery mode. Precondition (data port): IOSel[IndirectAddressOffset] = indirectaddressoffset02.">
      <!-- Bits 31:28 reserved. -->
      <field name="ArbitrationID" bit="24" size="4" desc="Arbitration ID. Read-only,Volatile. Reset: 0h. Arbitration ID." />
      <!-- Bits 23:0 reserved. -->
    </register>
    <register name="RedirectionTabEntryLow32" type="memory" device="IOAPIC" offset="0x0010" size="4" desc="Redirection Table Entry. Reset: 0001_0000h. DataPortWrite=FCH::IOAPIC::IOSel[IndirectAddressOffset]">
      <!-- Bits 31:17 reserved. -->
      <field name="Mask" bit="16" size="1" desc="Read-write. Reset: 1. 0=Unmask. 1=Mask the interrupt injection at the input of this device." />
      <field name="TriggerMode" bit="15" size="1" desc="Read-write. Reset: 0. 0=Edge. 1=Level." />
      <field name="RemoteIRR" bit="14" size="1" desc="Read-only. Reset: 0. 1=Interrupt message is delivered. Used for level triggered interrupts only. It is cleared by EOI special cycle transaction or a Write to FCH::IOAPIC::EOI." />
      <field name="InterruptPinPolarity" bit="13" size="1" desc="Read-write. Reset: 0. 0=High. 1=Low." />
      <field name="DeliveryStatus" bit="12" size="1" desc="Read-only. Reset: 0. 0=Idle. 1=Send Pending." />
      <field name="DestinationMode" bit="11" size="1" desc="Read-write. Reset: 0. 0=Physical. 1=Logical." />
      <field name="DeliveryMode" bit="8" size="3" desc="Read-write. Reset: 0h." />
      <field name="Vector" bit="0" size="8" desc="Read-write. Reset: 00h. Interrupt vector associated with this interrupt input." />
    </register>

    <!-- page 395 -->

    <register name="RedirectionTabEntryHigh32" type="memory" device="IOAPIC" offset="0x0010" size="4" desc="Redirection Table Entry. Read-write. Reset: 0000_0000h. DataPortWrite=FCH::IOAPIC::IOSel[IndirectAddressOffset]">
      <field name="DestinationID" bit="24" size="8" desc="Read-write. Reset: 00h. Bits[19:12] of the address field of the interrupt message." />
      <!-- Bits 23:0 reserved. -->
    </register>
    <register name="IRQPinAssertion" type="memory" device="IOAPIC" offset="0x0020" size="4" desc="IRQ Pin Assertion Register. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:8 reserved. -->
      <field name="InputIrq" bit="0" size="8" desc="Read-write. Reset: 00h. IRQ number for the requested interrupt. A write to this register triggers an interrupt associated with the redirection table entry referenced by the IRQ number. Currently the redirection table has 24 entries. Writes with IRQ number greater than 17h have no effect." />
    </register>
    <register name="EOI" type="memory" device="IOAPIC" offset="0x0040" size="4" desc="EOI Register. Write-only. Reset: 0000_0000h.">
      <!-- Bits 31:8 reserved. -->
      <field name="Vector" bit="0" size="8" desc="Write-only. Reset: 00h. Interrupt vector. A write to this register clears the remote IRR bit in the redirection table entry found matching the interrupt vector (see FCH::IOAPIC::RedirectionTabEntryLow32[RemoteIRR]). This provides an alternate mechanism other than the PCI special cycle for EOI to reach IOxAPIC." />
    </register>

    <!-- 9.2.4 SMI Registers -->

    <!-- page 396 -->

    <register name="EventStat" type="memory" device="SMI" offset="0x000" size="4" desc="Event_Status. Read,Write-1-to-clear.">
      <field name="EventStatus" bit="0" size="32" desc="Read,Write-1-to-clear. Reset: XXXX_XXXXh. This is a mirror register of the standard ACPI register FCH::PM::EventStat. Each event status bit is set when the selected event input equals to the corresponding value in FCH::SMI::SciTrig." />
    </register>
    <register name="EventEn" type="memory" device="SMI" offset="0x004" size="4" desc="Event_Enable. Read-write. Reset: 0000_0000h.">
      <field name="EventEnable" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. This is the mirror register of the standard ACPI register FCH::PM::EventEnable. Each bit controls whether ACPI should generate wake up and SCI interrupt." />
    </register>
    <register name="SciTrig" type="memory" device="SMI" offset="0x008" size="4" desc="SciTrig. Read-write. Reset: FFFF_FFFFh. Each bit in this register controls the way to set each corresponding bit in FCH::SMI::EventStat.">
      <field name="SciTrig31" bit="31" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[31]." />
      <field name="SciTrig30" bit="30" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[30]." />
      <field name="SciTrig29" bit="29" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[29]." />
      <field name="SciTrig28" bit="28" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[28]." />
      <field name="SciTrig27" bit="27" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[27]." />
      <field name="SciTrig26" bit="26" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[26]." />
      <field name="SciTrig25" bit="25" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[25]." />
      <field name="SciTrig24" bit="24" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[24]." />
      <field name="SciTrig23" bit="23" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[23]." />
      <field name="SciTrig22" bit="22" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[22]." />
      <field name="SciTrig21" bit="21" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[21]." />
      <field name="SciTrig20" bit="20" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[20]." />
      <field name="SciTrig19" bit="19" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[19]." />
      <field name="SciTrig18" bit="18" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[18]." />
      <field name="SciTrig17" bit="17" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[17]." />
      <field name="SciTrig16" bit="16" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[16]." />
      <field name="SciTrig15" bit="15" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[15]." />
      <field name="SciTrig14" bit="14" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[14]." />
      <field name="SciTrig13" bit="13" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[13]." />
      <field name="SciTrig12" bit="12" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set   FCH::SMI::EventStat bit[12]." />
      <field name="SciTrig11" bit="11" size="1" desc="Read-write. Reset: 1. 0=Falling edge. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[11]." />
      <field name="SciTrig10" bit="10" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[10]." />
      <field name="SciTrig9" bit="9" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[9]." />
      <field name="SciTrig8" bit="8" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[8]." />
      <field name="SciTrig7" bit="7" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[7]." />
      <field name="SciTrig6" bit="6" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[6]." />
      <field name="SciTrig5" bit="5" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[5]." />
      <field name="SciTrig4" bit="4" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[4]." />
      <field name="SciTrig3" bit="3" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[3]." />
      <field name="SciTrig2" bit="2" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[2]." />
      <field name="SciTrig1" bit="1" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[1]." />
      <field name="SciTrig0" bit="0" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high. The bit controls the way to set FCH::SMI::EventStat bit[0]." />
    </register>

    <!-- page 397 -->

    <register name="SciLevl" type="memory" device="SMI" offset="0x00C" size="4" desc="SciLevl. Read-write. Reset: 0000_0000h. Reset: 0000_0000h. This register specifies the trigger mode for each of the corresponding bit in FCH::SMI::EventStat.">
      <field name="SciLevl31" bit="31" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl30" bit="30" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl29" bit="29" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl28" bit="28" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl27" bit="27" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl26" bit="26" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl25" bit="25" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl24" bit="24" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl23" bit="23" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl22" bit="22" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl21" bit="21" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl20" bit="20" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl19" bit="19" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl18" bit="18" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl17" bit="17" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl16" bit="16" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl15" bit="15" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl14" bit="14" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl13" bit="13" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl12" bit="12" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl11" bit="11" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl10" bit="10" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl9" bit="9" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl8" bit="8" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl7" bit="7" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl6" bit="6" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl5" bit="5" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl4" bit="4" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl3" bit="3" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl2" bit="2" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl1" bit="1" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
      <field name="SciLevl0" bit="0" size="1" desc="Read-write. Reset: 0. 0=Edge trigger. 1=Level trigger." />
    </register>

    <!-- page 398 -->

    <register name="SmiSciStat" type="memory" device="SMI" offset="0x010" size="4" desc="SmiSciStatus. Read,Write-1-to-clear. Reset: 0000_0000h.">
      <field name="SmiSciStatus" bit="0" size="32" desc="Read,Write-1-to-clear. Reset: 0000_0000h. Each bit indicates the corresponding SmiSci status. The input of each bit is controlled by the corresponding FCH::SMI::SciTrig bit. NOTE: This function can be considered as a superset of FCH::SMI::EventStat. When one of the bits is set and its corresponding FCH::SMI::SmiSciEn is also set, it triggers an SMI to call the BIOS. After the BIOS has serviced the SMM and cleared its status, the internal logic automatically sets the corresponding FCH::SMI::EventStat bit and thereby triggering an SCI." />
    </register>

    <!-- page 399 -->

    <register name="SmiSciEn" type="memory" device="SMI" offset="0x014" size="4" desc="SmiSciEn. Read-write. Reset: 0000_0000h.">
      <field name="SmiSciEn" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Each bit controls if an SMI message is generated when the corresponding FCH::SMI::SmiSciStat bit is set to 1." />
    </register>

    <!-- page 401 -->

    <register name="SwSciEn" type="memory" device="SMI" offset="0x018" size="4" desc="SwSciEn. Read-write. Reset: 0000_0000h.">
      <field name="SwSciEn" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. This register is used as a software mechanism to trigger the SCI. NOTE: The setting of this bit needs to match with FCH::SMI::SciTrig and FCH::SMI::SciLevl in order to set the status bit." />
    </register>
    <register name="SwSciData" type="memory" device="SMI" offset="0x01C" size="4" desc="SwSciData. Read-write. Reset: 0000_0000h.">
      <field name="SwSciData" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. This is the software data path to set the corresponding FCH::SMI::EventStat bit when FCH::SMI::SwSciEn is set." />
    </register>

    <!-- page 402 -->

    <register name="SciSleepDisable" type="memory" device="SMI" offset="0x020" size="4" desc="SciSleepDisable. Read-write. Reset: 0000_0000h.">
      <field name="SciSleepDisable" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. This register is used to ignore EVENT pins that are powered in" />
    </register>

    <!-- page 403 -->

    <register name="CapturedData" type="memory" device="SMI" offset="0x030" size="4" desc="CapturedData. Read-only.">
      <field name="CapturedData" bit="0" size="32" desc="Read-only. Reset: XXXX_XXXXh. This is the buffer to capture Write data for the last transaction that caused an SMI. NOTE: This buffer has no meaning for a Read trap." />
    </register>
    <register name="CapturedVal" type="memory" device="SMI" offset="0x034" size="4" desc="CapturedValid. Read-only.">
      <!-- Bits 31:4 reserved. -->
      <field name="CapturedValid" bit="0" size="4" desc="Read-only. Reset: Xh. This is the byte valid buffer to signal which byte is captured for the last transaction that caused the SMI." />
    </register>
    <register name="EPBIF_AER_Straps" type="memory" device="SMI" offset="0x038" size="4" desc="EPBIF_AER_Straps. Read-write. Reset: 07FE_FFFEh.">
      <!-- Bits 31:28 reserved. -->
      <field name="StrapBifInternalErrEnFch" bit="27" size="1" desc="Read-write. Reset: 0. Internal error enable." />
      <field name="StrapBifPoisonedAdvisoryNonfatalAFch" bit="26" size="1" desc="Read-write. Reset: 1. Poisoned TLP as advisory non-fatal." />
      <field name="StrapBifAcsDirectTranslatedP2pFch" bit="25" size="1" desc="Read-write. Reset: 1. ACS direct translated P2P enable." />
      <field name="StrapBifAcsUpstreamForwardingFch" bit="24" size="1" desc="Read-write. Reset: 1. ACS upstream forwarding enable." />
      <field name="StrapBifAcsP2pCompletionRedirectFch" bit="23" size="1" desc="Read-write. Reset: 1. ACS P2P completion redirect enable." />
      <field name="StrapBifAcsP2pRequestRedirectFch" bit="22" size="1" desc="Read-write. Reset: 1. ACS P2P request redirect enable." />
      <field name="StrapBifAcsTranslationBlockingFch" bit="21" size="1" desc="Read-write. Reset: 1. ACS translation blocking enable." />
      <field name="StrapBifAcsSourceValidationFch" bit="20" size="1" desc="Read-write. Reset: 1. ACS source validation enable." />
      <field name="StrapBifAcsEnFch" bit="19" size="1" desc="Read-write. Reset: 1. ACS enable." />
      <field name="StrapBifFirstRcvdErrLogFch" bit="18" size="1" desc="Read-write. Reset: 1. First received error log." />
      <field name="StrapBifEcrcCheckEnFch" bit="17" size="1" desc="Read-write. Reset: 1. ECRC check enable." />
      <field name="StrapBifEcrcGenEnFch" bit="16" size="1" desc="Read-write. Reset: 0. ECRC generate enable." />
      <field name="StrapBifCplAbortErrEnFch" bit="15" size="1" desc="Read-write. Reset: 1. Completer abort error enable." />
      <field name="StrapBifRxIgnoreVend0UrFch" bit="14" size="1" desc="Read-write. Reset: 1. Ignore Vendor 0 error." />
      <field name="StrapBifRxIgnoreTcErrFch" bit="13" size="1" desc="Read-write. Reset: 1. Ignore traffic class error." />
      <field name="StrapBifRxIgnoreMsgErrFch" bit="12" size="1" desc="Read-write. Reset: 1. Ignore message error." />
      <field name="StrapBifRxIgnoreMaxPayloadErrFch" bit="11" size="1" desc="Read-write. Reset: 1. Ignore maximum payload error." />
      <field name="StrapBifRxIgnoreLenMismatchErrFch" bit="10" size="1" desc="Read-write. Reset: 1. Ignore length mismatch error." />
      <field name="StrapBifRxIgnoreIoUrErrFch" bit="9" size="1" desc="Read-write. Reset: 1. Ignore IO UR error." />
      <field name="StrapBifRxIgnoreIoErrFch" bit="8" size="1" desc="Read-write. Reset: 1. Ignore IO error." />
      <field name="StrapBifRxIgnoreEpErrFch" bit="7" size="1" desc="Read-write. Reset: 1. Ignore poisoned TLP error." />
      <field name="StrapBifRxIgnoreCplErrFch" bit="6" size="1" desc="Read-write. Reset: 1. Ignore completion error." />
      <field name="StrapBifRxIgnoreCfgUrFch" bit="5" size="1" desc="Read-write. Reset: 1. Ignore configuration UR error." />
      <field name="StrapBifRxIgnoreCfgErrFch" bit="4" size="1" desc="Read-write. Reset: 1. Ignore configuration error." />
      <field name="StrapBifRxIgnoreBeErrFch" bit="3" size="1" desc="Read-write. Reset: 1. Ignore byte enable error." />
      <field name="StrapBifErrReportingDisFch" bit="2" size="1" desc="Read-write. Reset: 1. Error reporting disable." />
      <field name="StrapBifAerEnFch" bit="1" size="1" desc="Read-write. Reset: 1. AER enable." />
      <field name="StrapBifStickyOverrideS5" bit="0" size="1" desc="Read-write. Reset: 0. 1=Values in this register would override straps loaded from EEPROM." />
    </register>

    <!-- page 404 -->

    <register name="DataErrStat" type="memory" device="SMI" offset="0x03C" size="4" desc="DataErrorStatus. Read,Write-1-to-clear. Reset: 0000_0000h.">
      <!-- Bits 31:8 reserved. -->
      <field name="SIrqIochk" bit="7" size="1" desc="Read,Write-1-to-clear. Reset: 0. Serial Iochk error." />
      <field name="SataPerr" bit="6" size="1" desc="Read,Write-1-to-clear. Reset: 0. SATA controller internal parity error status." />
      <field name="UmiUncorrectableErr" bit="5" size="1" desc="Read,Write-1-to-clear. Reset: 0. UMI uncorrectable error status." />
      <field name="UmiCorrectableErr" bit="4" size="1" desc="Read,Write-1-to-clear. Reset: 0. UMIcorrectable error status." />
      <field name="AbUmiGppPerr" bit="3" size="1" desc="Read,Write-1-to-clear. Reset: 0. AB/UMI/GPP parity error status." />
      <field name="InternalGPPSerr" bit="2" size="1" desc="Read,Write-1-to-clear. Reset: 0. Internal error status: FCH has detected an internal error from upstream bridge." />
      <field name="InternalPerr" bit="1" size="1" desc="Read,Write-1-to-clear. Reset: 0. Internal devices PERR error status." />
      <field name="InternalSerr" bit="0" size="1" desc="Read,Write-1-to-clear. Reset: 0. Internal devices SERR error status." />
    </register>
    <register name="SciMap0" type="memory" device="SMI" offset="0x040" size="4" desc="SciMap0. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:29 reserved. -->
      <field name="SciMap3" bit="24" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of LPC_PME_L to one of the 32 bits in FCH::SMI::EventStat." />
      <!-- Bits 23:21 reserved. -->
      <field name="SciMap2" bit="16" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of AGPIO3 to one of the 32 bits in FCH::SMI::EventStat." />
      <!-- Bits 15:13 reserved. -->
      <field name="SciMap1" bit="8" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of GENINT2_L to one of the 32 bits in FCH::SMI::EventStat." />
      <!-- Bits 7:5 reserved. -->
      <field name="SciMap0" bit="0" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of GENINT1_L to one of the 32 bits in FCH::SMI::EventStat." />
    </register>
    <register name="SciMap1" type="memory" device="SMI" offset="0x044" size="4" desc="SciMap1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:29 reserved. -->
      <field name="SciMap7" bit="24" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of AGPIO5 to one of the 32 bits in FCH::SMI::EventStat." />
      <!-- Bits 23:21 reserved. -->
      <field name="SciMap6" bit="16" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of SPKR to one of the 32 bits in FCH::SMI::EventStat." />
      <!-- Bits 15:13 reserved. -->
      <field name="SciMap5" bit="8" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of LPC_PD_L to one of the 32 bits in FCH::SMI::EventStat." />
      <!-- Bits 7:5 reserved. -->
      <field name="SciMap4" bit="0" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of AGPIO4 to one of the 32 bits in FCH::SMI::EventStat." />
    </register>

    <!-- page 405 -->

    <register name="SciMap2" type="memory" device="SMI" offset="0x048" size="4" desc="SciMap2. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:29 reserved. -->
      <field name="SciMap11" bit="24" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of AGPIO7 to one of the 32 bits in FCH::SMI::EventStat. CopyFrom: SciMap8." />
      <!-- Bits 23:21 reserved. -->
      <field name="SciMap10" bit="16" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of AGPIO6 to one of the 32 bits in FCH::SMI::EventStat. CopyFrom: SciMap8." />
      <!-- Bits 15:13 reserved. -->
      <field name="SciMap9" bit="8" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of LPC_SMI_L to one of the 32 bits in FCH::SMI::EventStat. CopyFrom: SciMap8." />
      <!-- Bits 7:5 reserved. -->
      <field name="SciMap8" bit="0" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of WAKE_L to one of the 32 bits in FCH::SMI::EventStat." />
    </register>
    <register name="SciMap3" type="memory" device="SMI" offset="0x04C" size="4" desc="SciMap3. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:29 reserved. -->
      <field name="SciMap15" bit="24" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of USB_OC3_L to one of the 32 bits in FCH::SMI::EventStat. CopyFrom: SciMap12." />
      <!-- Bits 23:21 reserved. -->
      <field name="SciMap14" bit="16" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of USB_OC2_L to one of the 32 bits in FCH::SMI::EventStat. CopyFrom: SciMap12." />
      <!-- Bits 15:13 reserved. -->
      <field name="SciMap13" bit="8" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of USB_OC1_L to one of the 32 bits in FCH::SMI::EventStat. CopyFrom: SciMap12." />
      <!-- Bits 7:5 reserved. -->
      <field name="SciMap12" bit="0" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of USB_OC0_L to one of the 32 bits in FCH::SMI::EventStat." />
    </register>
    <register name="SciMap4" type="memory" device="SMI" offset="0x050" size="4" desc="SciMap4. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:29 reserved. -->
      <field name="SciMap19" bit="24" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of SYS_RESET_L to one of the 32 bits in FCH::SMI::EventStat. CopyFrom: SciMap16." />
      <!-- Bits 23:21 reserved. -->
      <field name="SciMap18" bit="16" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of FANIN0 to one of the 32 bits in FCH::SMI::EventStat. CopyFrom: SciMap16." />
      <!-- Bits 15:13 reserved. -->
      <field name="SciMap17" bit="8" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of ESPI_RESET_L to one of the 32 bits in FCH::SMI::EventStat. CopyFrom: SciMap16." />
      <!-- Bits 7:5 reserved. -->
      <field name="SciMap16" bit="0" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of AGPIO23 to one of the 32 bits in FCH::SMI::EventStat." />
    </register>

    <!-- page 406 -->

    <register name="SciMap5" type="memory" device="SMI" offset="0x054" size="4" desc="SciMap5. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:29 reserved. -->
      <field name="SciMap23" bit="24" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of AGPIO8 to one of the 32 bits in FCH::SMI::EventStat. CopyFrom: SciMap20." />
      <!-- Bits 23:21 reserved. -->
      <field name="SciMap22" bit="16" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of AGPIO9 to one of the 32 bits in FCH::SMI::EventStat. CopyFrom: SciMap20." />
      <!-- Bits 15:13 reserved. -->
      <field name="SciMap21" bit="8" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of PWR_BTN_L to one of the 32 bits in FCH::SMI::EventStat. CopyFrom: SciMap20." />
      <!-- Bits 7:5 reserved. -->
      <field name="SciMap20" bit="0" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of AGPIO40 to one of the 32 bits in FCH::SMI::EventStat." />
    </register>
    <register name="SciMap6" type="memory" device="SMI" offset="0x058" size="4" desc="SciMap6. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:29 reserved. -->
      <field name="SciMap27" bit="24" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of eSPI_WAKE_PME (active high) to one of the 32 bits in FCH::SMI::EventStat." />
      <!-- Bits 23:21 reserved. -->
      <field name="SciMap26" bit="16" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of eSPI system event (active high) to one of the 32 bits in FCH::SMI::EventStat." />
      <!-- Bits 15:0 reserved. -->
    </register>
    <register name="SciMap7" type="memory" device="SMI" offset="0x05C" size="4" desc="SciMap7. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:21 reserved. -->
      <field name="SciMap30" bit="16" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of NB GPP Hot Plug to one of the 32 bits in FCH::SMI::EventStat." />
      <!-- Bits 15:13 reserved. -->
      <field name="SciMap29" bit="8" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of NB GPP_PME to one of the 32 bits in FCH::SMI::EventStat." />
      <!-- Bits 7:0 reserved. -->
    </register>
    <register name="SciMap8" type="memory" device="SMI" offset="0x060" size="4" desc="SciMap8. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:5 reserved. -->
      <field name="SciMap32" bit="0" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of WAKE_L to one of the 32 bits in FCH::SMI::EventStat." />
    </register>

    <!-- page 407 -->

    <register name="SciMap9" type="memory" device="SMI" offset="0x064" size="4" desc="SciMap9. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:29 reserved. -->
      <field name="SciMap39" bit="24" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of Azalia PME to one of the 32 bits in FCH::SMI::EventStat." />
      <!-- Bits 23:0 reserved. -->
    </register>
    <register name="SciMap10" type="memory" device="SMI" offset="0x068" size="4" desc="SciMap10. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:29 reserved. -->
      <field name="SciMap43" bit="24" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of AltHPET timer event to one of the 32 bits in FCH::SMI::EventStat." />
      <!-- Bits 23:13 reserved. -->
      <field name="SciMap41" bit="8" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of GPIO Interrupt to one of the 32 bits in FCH::SMI::EventStat." />
      <!-- Bits 7:5 reserved. -->
      <field name="SciMap40" bit="0" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of USB_PD_I2C4 (active high) interrupt to one of the 32 bits in FCH::SMI::EventStat." />
    </register>
    <register name="SciMap11" type="memory" device="SMI" offset="0x06C" size="4" desc="SciMap11. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:29 reserved. -->
      <field name="SciMap47" bit="24" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of SMBUS0 Interrupt event to one of the 32 bits in FCH::SMI::EventStat. CopyFrom: SciMap44." />
      <!-- Bits 23:21 reserved. -->
      <field name="SciMap46" bit="16" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of I2S wake event to one of the 32 bits in FCH::SMI::EventStat. CopyFrom: SciMap44." />
      <!-- Bits 15:13 reserved. -->
      <field name="SciMap45" bit="8" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of ASF Master and Slave interrupt event to one of the 32 bits in FCH::SMI::EventStat.CopyFrom: SciMap44." />
      <!-- Bits 7:5 reserved. -->
      <field name="SciMap44" bit="0" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of internal FAN/THERMAL event to one of the 32 bits in FCH::SMI::EventStat." />
    </register>
    <register name="SciMap12" type="memory" device="SMI" offset="0x070" size="4" desc="SciMap12. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:29 reserved. -->
      <field name="SciMap51" bit="24" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of Power Button event to one of the 32 bits in FCH::SMI::EventStat." />
      <!-- Bits 23:21 reserved. -->
      <field name="SciMap50" bit="16" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of LLB# to one of the 32 bits in FCH::SMI::EventStat." />
      <!-- Bits 15:13 reserved. -->
      <field name="SciMap49" bit="8" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of internal traffic monitor to one of the 32 bits in FCH::SMI::EventStat." />
      <!-- Bits 7:5 reserved. -->
      <field name="SciMap48" bit="0" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of TWARN pin to one of the 32 bits in   FCH::SMI::EventStat." />
    </register>

    <!-- page 408 -->

    <register name="SciMap13" type="memory" device="SMI" offset="0x074" size="4" desc="SciMap13. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:29 reserved. -->
      <field name="SciMap55" bit="24" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of RAS_event status to one of the 32 bits in FCH::SMI::EventStat. CopyFrom: SciMap52." />
      <!-- Bits 23:21 reserved. -->
      <field name="SciMap54" bit="16" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of SCI assertion message from APU to one of the 32 bits in FCH::SMI::EventStat. CopyFrom: SciMap52." />
      <!-- Bits 15:13 reserved. -->
      <field name="SciMap53" bit="8" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of hardware assertion message from APU to one of the 32 bits in FCH::SMI::EventStat. CopyFrom: SciMap52." />
      <!-- Bits 7:5 reserved. -->
      <field name="SciMap52" bit="0" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of PROHOT# pin to one of the 32 bits in FCH::SMI::EventStat." />
    </register>
    <register name="SciMap14" type="memory" device="SMI" offset="0x078" size="4" desc="SciMap14. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:21 reserved. -->
      <field name="SciMap58" bit="16" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of AcDcTimerEvent to one of the 32 bits in FCH::SMI::EventStat." />
      <!-- Bits 15:13 reserved. -->
      <field name="SciMap57" bit="8" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of XHC1 PME event to one of the 32 bits in FCH::SMI::EventStat." />
      <!-- Bits 7:5 reserved. -->
      <field name="SciMap56" bit="0" size="5" desc="Read-write. Reset: 00h. Specifies the mapping of XHC0 PME event to one of the 32 bits in FCH::SMI::EventStat." />
    </register>
    <register name="SmiStat0" type="memory" device="SMI" offset="0x080" size="4" desc="SmiStatus0. Read,Write-1-to-clear. Reset: 0000_0000h.">
      <!-- Bit 31 reserved. -->
      <field name="NBGPPHP_event30" bit="30" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of NB Hot Plug event." />
      <field name="NBGppPme_event29" bit="29" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of NB GPP PME." />
      <!-- Bit 28 reserved. -->
      <field name="eSPI_WAKE_PME_event27" bit="27" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of eSPI_WAKE_PME_event27." />
      <field name="eSPI_system_event26" bit="26" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of eSPI system event." />
      <!-- Bits 25:24 reserved. -->
      <field name="Gevent23StatusEvent23" bit="23" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of AGPIO8." />
      <field name="Gevent22StatusEvent22" bit="22" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of AGPIO9." />
      <field name="Gevent21StatusEvent21" bit="21" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of PWR_BTN_L." />
      <field name="Gevent20StatusEvent20" bit="20" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of AGPIO40." />
      <field name="Gevent19StatusEvent19" bit="19" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of SYS_RESET_L." />
      <field name="Gevent18StatusEvent18" bit="18" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of FANIN0." />
      <field name="Gevent17StatusEvent17" bit="17" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of ESPI_RESET_L." />
      <field name="Gevent16StatusEvent16" bit="16" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of AGPIO23." />
      <field name="Gevent15StatusEvent15" bit="15" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of USB_OC3_L." />
      <field name="Gevent14StatusEvent14" bit="14" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of USB_OC2_L." />
      <field name="Gevent13StatusEvent13" bit="13" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of USB_OC1_L." />
      <field name="Gevent12StatusEvent12" bit="12" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of USB_OC0_L." />
      <field name="Gevent11StatusEvent11" bit="11" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of AGPIO7." />
      <field name="Gevent10StatusEvent10" bit="10" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of AGPIO6." />
      <field name="Gevent9StatusEvent9" bit="9" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of LPC_SMI_L." />
      <field name="Gevent8StatusEvent8" bit="8" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of WAKE_L." />
      <field name="Gevent7StatusEvent7" bit="7" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of AGPIO5." />
      <field name="Gevent6StatusEvent6" bit="6" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of SPKR." />
      <field name="Gevent5StatusEvent5" bit="5" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of LPC_PD_L." />
      <field name="Gevent4StatusEvent4" bit="4" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of AGPIO4." />
      <field name="Gevent3StatusEvent3" bit="3" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of LPC_PME_L." />
      <field name="Gevent2StatusEvent2" bit="2" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of AGPIO3." />
      <field name="Gevent1StatusEvent1" bit="1" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of GENINT2_L." />
      <field name="Gevent0StatusEvent0" bit="0" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of GENINT1_L." />
    </register>

    <!-- page 409 -->

    <register name="SmiStat1" type="memory" device="SMI" offset="0x084" size="4" desc="SmiStatus1. Read,Write-1-to-clear. Reset: 0000_0000h.">
      <!-- Bits 31:27 reserved. -->
      <field name="AcDcTimerEventEvent58" bit="26" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of AcDcTimer wake up event." />
      <field name="Xhc1PmeEvent57" bit="25" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of XHC1 PME." />
      <field name="Xhc0PmeEvent56" bit="24" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of XHC0 PME." />
      <field name="RasEvent55" bit="23" size="1" desc="Read,Write-1-to-clear. Reset: 0. Internal devices SERR error status." />
      <field name="ApuSciAssertionEvent54" bit="22" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of APU SCI request." />
      <field name="ApuHwAssertionEvent53" bit="21" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of APU hardware assertion." />
      <field name="ProcHotEvent52" bit="20" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of ProcHot event." />
      <field name="PwrButtonEvent51" bit="19" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of PwrButton (rising edge)." />
      <field name="PwrButtonEvent50" bit="18" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of iLLB# assertion." />
      <field name="TrafficMonitorIntrEvent49" bit="17" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of FCH Traffic Monitor Interrupt." />
      <field name="TwarnEvent48" bit="16" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of FCH TWARN." />
      <field name="Smbus0Event47" bit="15" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of FCH SMBUS0 master interrupt." />
      <field name="Smbus0Event46" bit="14" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of I2S wake event." />
      <field name="AsfrIntrEvent45" bit="13" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of FCH ASF master and slave interrupt." />
      <field name="FanThermalGeventEvent44" bit="12" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of FCH fan thermal." />
      <field name="AltMmTimerStsEvent43" bit="11" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of AltMmTimer Alarm." />
      <!-- Bit 10 reserved. -->
      <field name="GpioEvent41" bit="9" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of FCH GPIO Control interrupt." />
      <field name="GpioEvent40" bit="8" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of USB_PD_I2C4." />
      <field name="AZPME_event39" bit="7" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of Azalia wake event." />
      <!-- Bits 6:1 reserved. -->
      <field name="WakeLEvent32" bit="0" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of WAKE_L." />
    </register>

    <!-- page 410 -->

    <register name="SmiStat2" type="memory" device="SMI" offset="0x088" size="4" desc="SmiStatus2. Read,Write-1-to-clear. Reset: 0000_0000h.">
      <!-- Bits 31:27 reserved. -->
      <field name="Emulate64Event90" bit="26" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of Emulation IO Port 60h/64h." />
      <!-- Bits 25:21 reserved. -->
      <field name="PciSerrEvent84" bit="20" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of SERR assertion on PCI bus." />
      <field name="ProtHotEvent83" bit="19" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of ProtHot event." />
      <field name="VbatLowEvent82" bit="18" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of VBAT low." />
      <field name="IntruderAlertStsEvent81" bit="17" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of IntruderAlertSts." />
      <!-- Bits 16:15 reserved. -->
      <field name="Smbus0IntrEvent78" bit="14" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of SMBUS0 interrupt request." />
      <field name="SerialIrqSmiEvent77" bit="13" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of SMI request from Serial IRQ." />
      <field name="UsbSmiEvent76" bit="12" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of USB SMI request." />
      <field name="SmiCmdportEvent75" bit="11" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of Writing SMI Command Port." />
      <field name="PwrbtnEvent74" bit="10" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of Power Button being pressed." />
      <field name="BiosRlsEvent73" bit="9" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of BIOS_RLS. See FCH::PM::AcpiCfg[BiosRls]." />
      <field name="GblRlsEvent72" bit="8" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of GBL event. See FCH::PM::PmCtl[GblRls]." />
      <!-- Bit 7 reserved. -->
      <field name="UsbPdI2C4IntrBSmiEvent70" bit="6" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of USB_PD_I2C4_intrB SMI request." />
      <field name="NBGppHpPulseSmiEvent69" bit="5" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of NBGppHpPulse SMI request." />
      <field name="NBGppPmePulseSmiEvent68" bit="4" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of NBGppPmePulse SMI request." />
      <field name="SataAhciSmiEvent67" bit="3" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of SATA AHCI SMI request." />
      <field name="AL2H_ACPI_Assertion_Event67" bit="2" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of AL2H ACPI Assertion." />
      <field name="SlpTypeEvent65" bit="1" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of writing FCH::PM::PmCtl[SlpTyp]." />
      <field name="KBRstEvent64" bit="0" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status is set when KeyBoard Reset." />
    </register>
    <register name="SmiStat4" type="memory" device="SMI" offset="0x090" size="4" desc="SmiStatus4. Read,Write-1-to-clear. Reset: 0000_0000h.">
      <!-- Bits 31:29 reserved. -->
      <field name="CfgTrapping0Event156" bit="28" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of PCI configuration cycle Trapping0 SMI request." />
      <!-- Bits 27:25 reserved. -->
      <field name="MemTrapping0Event152" bit="24" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of memory Trapping0 SMI request." />
      <field name="IoTrapping3Event151" bit="23" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of IO Trapping3 SMI request." />
      <field name="IoTrapping2Event150" bit="22" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of IO Trapping2 SMI request." />
      <field name="IoTrapping1Event149" bit="21" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of IO Trapping1 SMI request." />
      <field name="IoTrapping0Event148" bit="20" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of IO Trapping0 SMI request." />
      <!-- Bit 19 reserved. -->
      <field name="eSPISMIEvent146" bit="18" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of eSPI SMI event." />
      <!-- Bit 17 reserved. -->
      <field name="AbSmiTrapEvent144" bit="16" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of AB SMI trapping request." />
      <field name="LongTimerEvent143" bit="15" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of Long Timer SMI request." />
      <field name="ShortTimerEvent142" bit="14" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of Short Timer SMI request." />
      <field name="Cf9WriteEvent141" bit="13" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=CF9 bit[2] is not written to 1. 1=CF9 bit[2] has been written to 1." />
      <!-- Bits 12:6 reserved. -->
      <field name="Fanin0StsEvent133" bit="5" size="1" desc="Read,Write-1-to-clear. Reset: 0. Status of FanIn0 event." />
      <!-- Bits 4:0 reserved. -->
    </register>

    <!-- page 411 -->

    <register name="SmiPtr" type="memory" device="SMI" offset="0x094" size="2" desc="SmiPointer. Read-only. Reset: 0000h. This register is meant as a faster mechanism to locate the SMI source. BIOS can examine this register to find out the SMI source instead of reading FCH::SMI::SmiStat0 through FCH::SMI::SmiStat4 individually.">
      <!-- Bits 15:6 reserved. -->
      <field name="SmiStatusSource4" bit="5" size="1" desc="Read-only. Reset: 0. Indicates whether the SMI source is from FCH::SMI::SmiStat4 if the corresponding SMI enable is selected." />
      <!-- Bit 4 reserved. -->
      <field name="SmiStatusSource2" bit="3" size="1" desc="Read-only. Reset: 0. Indicates whether the SMI source is from FCH::SMI::SmiStat2 if the corresponding SMI enable is selected." />
      <field name="SmiStatusSource1" bit="2" size="1" desc="Read-only. Reset: 0. Indicates whether the SMI source is from FCH::SMI::SmiStat1 if the corresponding SMI enable is selected." />
      <field name="SmiStatusSource0" bit="1" size="1" desc="Read-only. Reset: 0. Indicates whether the SMI source is from FCH::SMI::SmiStat0 if the corresponding SMI enable is selected." />
      <field name="SmiSciSource" bit="0" size="1" desc="Read-only. Reset: 0. Indicates whether the SMI source is from FCH::SMI::SmiSciStat." />
    </register>
    <register name="SmiTimer" type="memory" device="SMI" offset="0x096" size="2" desc="SmiTimer. Read-write. Reset: 0000h. There are two SMI timers: the short timer runs at 1 us unit time and the long timer runs at 1 ms unit time. This register is actually made up of two sets of registers depending on the setting of FCH::SMI::SmiTrig0[SmiTimerSel]. If FCH::SMI::SmiTrig0[SmiTimerSel] == 0, then FCH::SMI::SmiTimer is for the short timer. If FCH::SMI::SmiTrig0[SmiTimerSel] == 1, then FCH::SMI::SmiTimer is for the long timer. The default setting selects this register as &quot;SmiShortTimer&quot;; software needs to set the &quot;SmiTimerSel = 1&quot; to select this register as &quot;SmiLongTimer&quot;.">
      <field name="TimerEn" bit="15" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable the SMI short Timer or long timer, which is selected by FCH::SMI::SmiTrig0[SmiTimerSel]." />
      <field name="SmiTimerCount" bit="0" size="15" desc="Read-write. Reset: 0000h. Actual timer duration = TimerTime + 1 unit." />
    </register>
    <register name="SmiTrig0" type="memory" device="SMI" offset="0x098" size="4" desc="SmiTrig0. Read-write. Reset: 81FF_FFFFh. Bits[23:0] defines the trigger mode for 24 GEVENTS in FCH::SMI::SmiStat0[23:0]. Note these are different from FCH::SMI::SciTrig.">
      <field name="SmiEnB" bit="31" size="1" desc="Read-write. Reset: 1. 0=Enable SMI function. 1=Disable." />
      <!-- Bit 30 reserved. -->
      <field name="SmiTimerSel" bit="29" size="1" desc="Read-write. Reset: 0. 0=Select FCH::SMI::SmiTimer to be SmiShortTimer register. 1=Select FCH::SMI::SmiTimer to be SmiLongTimer register." />
      <field name="Eos" bit="28" size="1" desc="Read-write. Reset: 0. This bit is set to 1 by software to enable SMI generation. It is cleared by hardware after an SMI event has occurred. When Eos is clear, subsequent pending SMI event will be blocked." />
      <!-- Bits 27:25 reserved. -->
      <field name="TrappingIrqOnPic" bit="24" size="1" desc="Read-write. Reset: 1. 0=SMI is generated when trapping IRQ[15:0] of IOAPIC. 1=SMI is generated when trapping IRQ[15:0] of PIC." />
      <field name="SmiTrig23" bit="23" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig22" bit="22" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig21" bit="21" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig20" bit="20" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig19" bit="19" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig18" bit="18" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig17" bit="17" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig16" bit="16" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig15" bit="15" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig14" bit="14" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig13" bit="13" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig12" bit="12" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig11" bit="11" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig10" bit="10" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig9" bit="9" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig8" bit="8" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig7" bit="7" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig6" bit="6" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig5" bit="5" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig4" bit="4" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig3" bit="3" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig2" bit="2" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig1" bit="1" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
      <field name="SmiTrig0" bit="0" size="1" desc="Read-write. Reset: 1. 0=Active low. 1=Active high." />
    </register>

    <!-- page 412 -->

    <register name="SmiTrig1" type="memory" device="SMI" offset="0x09C" size="4" desc="SmiTrig1. Read-write. Bits[23:0] defines the trigger mode for 24 IRQs.">
      <!-- Bits 31:24 reserved. -->
      <field name="SmiIrq23Trig" bit="23" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq22Trig" bit="22" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq21Trig" bit="21" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq20Trig" bit="20" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq19Trig" bit="19" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq18Trig" bit="18" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq17Trig" bit="17" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq16Trig" bit="16" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq15Trig" bit="15" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq14Trig" bit="14" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq13Trig" bit="13" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq12Trig" bit="12" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq11Trig" bit="11" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq10Trig" bit="10" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq9Trig" bit="9" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq8Trig" bit="8" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq7Trig" bit="7" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq6Trig" bit="6" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq5Trig" bit="5" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq4Trig" bit="4" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq3Trig" bit="3" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq2Trig" bit="2" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq1Trig" bit="1" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
      <field name="SmiIrq0Trig" bit="0" size="1" desc="Read-write. Reset: 0. 0=Active low. 1=Active high." />
    </register>

    <!-- page 413 -->

    <register name="SmiCtl0" type="memory" device="SMI" offset="0x0A0" size="4" desc="SmiControl0. Read-write. Reset: 0000_0000h. This register specifies the control mechanism for SMI sources in FCH::SMI::SmiStat0[15:0].">
      <field name="Smicontrol15" bit="30" size="2" desc="Read-write. Reset: 0h. Control for GEVENT15." />
      <field name="Smicontrol14" bit="28" size="2" desc="Read-write. Reset: 0h. Control for GEVENT14." />
      <field name="Smicontrol13" bit="26" size="2" desc="Read-write. Reset: 0h. Control for GEVENT13." />
      <field name="Smicontrol12" bit="24" size="2" desc="Read-write. Reset: 0h. Control for GEVENT12." />
      <field name="Smicontrol11" bit="22" size="2" desc="Read-write. Reset: 0h. Control for GEVENT11." />
      <field name="Smicontrol10" bit="20" size="2" desc="Read-write. Reset: 0h. Control for GEVENT10." />
      <field name="Smicontrol9" bit="18" size="2" desc="Read-write. Reset: 0h. Control for GEVENT9.  " />
      <field name="Smicontrol8" bit="16" size="2" desc="Read-write. Reset: 0h. Control for GEVENT8." />
      <field name="Smicontrol7" bit="14" size="2" desc="Read-write. Reset: 0h. Control for GEVENT7." />
      <field name="Smicontrol6" bit="12" size="2" desc="Read-write. Reset: 0h. Control for GEVENT6." />
      <field name="Smicontrol5" bit="10" size="2" desc="Read-write. Reset: 0h. Control for GEVENT5." />
      <field name="Smicontrol4" bit="8" size="2" desc="Read-write. Reset: 0h. Control for GEVENT4." />
      <field name="Smicontrol3" bit="6" size="2" desc="Read-write. Reset: 0h. Control for GEVENT3." />
      <field name="Smicontrol2" bit="4" size="2" desc="Read-write. Reset: 0h. Control for GEVENT2." />
      <field name="Smicontrol1" bit="2" size="2" desc="Read-write. Reset: 0h. Control for GEVENT1." />
      <field name="Smicontrol0" bit="0" size="2" desc="Read-write. Reset: 0h. Control for GEVENT0." />
    </register>

    <!-- page 415 -->

    <register name="SmiCtl1" type="memory" device="SMI" offset="0x0A4" size="4" desc="SmiControl1. Read-write. Reset: 0000_0000h. This register specifies the control mechanism for SMI sources in FCH::SMI::SmiStat0[31:16].">
      <!-- Bits 31:30 reserved. -->
      <field name="Smicontrol30" bit="28" size="2" desc="Read-write. Reset: 0h. Control for NB GPP Hot Plug." />
      <field name="Smicontrol29" bit="26" size="2" desc="Read-write. Reset: 0h. Control for GPP PME." />
      <!-- Bits 25:24 reserved. -->
      <field name="Smicontrol27" bit="22" size="2" desc="Read-write. Reset: 0h. Control for eSPI_WAKE_PME." />
      <field name="Smicontrol26" bit="20" size="2" desc="Read-write. Reset: 0h. Control for eSPI system event." />
      <!-- Bits 19:16 reserved. -->
      <field name="Smicontrol23" bit="14" size="2" desc="Read-write. Reset: 0h. Control for GEVENT23." />
      <field name="Smicontrol22" bit="12" size="2" desc="Read-write. Reset: 0h. Control for GEVENT22." />
      <field name="Smicontrol21" bit="10" size="2" desc="Read-write. Reset: 0h. Control for GEVENT21." />
      <field name="Smicontrol20" bit="8" size="2" desc="Read-write. Reset: 0h. Control for GEVENT20." />
      <field name="Smicontrol19" bit="6" size="2" desc="Read-write. Reset: 0h. Control for GEVENT19." />
      <field name="Smicontrol18" bit="4" size="2" desc="Read-write. Reset: 0h. Control for GEVENT18." />
      <field name="Smicontrol17" bit="2" size="2" desc="Read-write. Reset: 0h. Control for GEVENT17." />
      <field name="Smicontrol16" bit="0" size="2" desc="Read-write. Reset: 0h. Control for GEVENT16." />
    </register>

    <!-- page 417 -->

    <register name="SmiCtl2" type="memory" device="SMI" offset="0x0A8" size="4" desc="SmiControl2. Read-write. Reset: 0000_0000h. This register specifies the control mechanism for SMI sources in FCH::SMI::SmiStat1[15:0].">
      <field name="Smicontrol47" bit="30" size="2" desc="Read-write. Reset: 0h. Control for SMBUS0 interrupt." />
      <field name="Smicontrol46" bit="28" size="2" desc="Read-write. Reset: 0h. Control for ACP_FCH_I2S_Wake." />
      <field name="Smicontrol45" bit="26" size="2" desc="Read-write. Reset: 0h. Control for ASF Master and Slave interrupt." />
      <field name="Smicontrol44" bit="24" size="2" desc="Read-write. Reset: 0h. Control for fan thermal GEvent." />
      <field name="SimControl43" bit="22" size="2" desc="Read-write. Reset: 0h. Control for ALTHPET_TimerSts." />
      <!-- Bits 21:20 reserved. -->
      <field name="SimControl41" bit="18" size="2" desc="Read-write. Reset: 0h. Control for GPIO interrupt." />
      <field name="Smicontrol40" bit="16" size="2" desc="Read-write. Reset: 0h. Control for USB_PD_I2C4_intrB." />
      <field name="Smicontrol39" bit="14" size="2" desc="Read-write. Reset: 0h. Control for Azalia PME." />
      <!-- Bits 13:2 reserved. -->
      <field name="Smicontrol32" bit="0" size="2" desc="Read-write. Reset: 0h. Control for WAKE_L." />
    </register>

    <!-- page 419 -->

    <register name="SmiCtl3" type="memory" device="SMI" offset="0x0AC" size="4" desc="SmiControl3. Read-write. Reset: 0000_0000h. This register specifies the control mechanism for SMI sources in FCH::SMI::SmiStat1[31:16].">
      <field name="Smicontrol63" bit="30" size="2" desc="Read-write. Reset: 0h. Control for TempTsi event." />
      <!-- Bits 29:22 reserved. -->
      <field name="Smicontrol58" bit="20" size="2" desc="Read-write. Reset: 0h. Control for AcDcTimer wake up event (Wake Device in ACPI 4.0)." />
      <field name="Smicontrol57" bit="18" size="2" desc="Read-write. Reset: 0h. Control for XHC1 PME." />
      <field name="Smicontrol56" bit="16" size="2" desc="Read-write. Reset: 0h. Control for XHC0 PME." />
      <field name="Smicontrol55" bit="14" size="2" desc="Read-write. Reset: 0h. Control for internal devices SERR error status." />
      <field name="Smicontrol54" bit="12" size="2" desc="Read-write. Reset: 0h. Control for APU SCI request." />
      <field name="Smicontrol53" bit="10" size="2" desc="Read-write. Reset: 0h. Control for APU hardware assertion." />
      <field name="Smicontrol52" bit="8" size="2" desc="Read-write. Reset: 0h. Control for ProcHot event." />
      <field name="Smicontrol51" bit="6" size="2" desc="Read-write. Reset: 0h. Control for iLLB#." />
      <field name="Smicontrol50" bit="4" size="2" desc="Read-write. Reset: 0h. Control for Power Button event." />
      <field name="Smicontrol49" bit="2" size="2" desc="Read-write. Reset: 0h. Control for internal Traffic monitor interrupt." />
      <field name="Smicontrol48" bit="0" size="2" desc="Read-write. Reset: 0h. Control for TWARN#." />
    </register>

    <!-- page 420 -->

    <register name="SmiCtl4" type="memory" device="SMI" offset="0x0B0" size="4" desc="SmiControl4. Read-write. Reset: 0000_0000h. This register specifies the control mechanism for SMI sources in FCH::SMI::SmiStat2[15:0].">
      <field name="Smicontrol79" bit="30" size="2" desc="Read-write. Reset: 0h. Control for EC SMI request0." />
      <field name="Smicontrol78" bit="28" size="2" desc="Read-write. Reset: 0h. Control for SMBUS0 interrupt." />
      <field name="Smicontrol77" bit="26" size="2" desc="Read-write. Reset: 0h. Control for SMI request form serial IRQ." />
      <field name="Smicontrol76" bit="24" size="2" desc="Read-write. Reset: 0h. Control for USB SMI request." />
      <field name="Smicontrol75" bit="22" size="2" desc="Read-write. Reset: 0h. Control for Writing SMI command port at FCH::PM::SmiCmdPort." />
      <field name="Smicontrol74" bit="20" size="2" desc="Read-write. Reset: 0h. Control for Bower Button being pressed." />
      <field name="Smicontrol73" bit="18" size="2" desc="Read-write. Reset: 0h. Control for Writing FCH::PM::AcpiCfg[BiosRls]." />
      <field name="Smicontrol72" bit="16" size="2" desc="Read-write. Reset: 0h. Control for Writing FCH::PM::PmCtl[GblRls]." />
      <field name="Smicontrol71" bit="14" size="2" desc="Read-write. Reset: 0h. Control for USB_PD_I2C4_intrB event." />
      <field name="Smicontrol70" bit="12" size="2" desc="Read-write. Reset: 0h. Control for USB_PD_I2C4_intrB event." />
      <field name="Smicontrol69" bit="10" size="2" desc="Read-write. Reset: 0h. Control for NBGppHpPulse event." />
      <field name="Smicontrol68" bit="8" size="2" desc="Read-write. Reset: 0h. Control for NBGppPmePulse event." />
      <field name="Smicontrol67" bit="6" size="2" desc="Read-write. Reset: 0h. Control for SATA AHCI event." />
      <field name="Smicontrol66" bit="4" size="2" desc="Read-write. Reset: 0h. Control for iAL2H ACPI Assertion." />
      <field name="Smicontrol65" bit="2" size="2" desc="Read-write. Reset: 0h. Control for Writing FCH::PM::PmCtl[SlpTyp] to put the system in S-state." />
      <field name="Smicontrol64" bit="0" size="2" desc="Read-write. Reset: 0h. Control for Keyboard Reset.  " />
    </register>

    <!-- page 423 -->

    <register name="SmiCtl5" type="memory" device="SMI" offset="0x0B4" size="4" desc="SmiControl5. Read-write. Reset: 0000_0000h. This register specifies the control mechanism for SMI sources in FCH::SMI::SmiStat2[31:16].">
      <!-- Bits 31:22 reserved. -->
      <field name="Smicontrol90" bit="20" size="2" desc="Read-write. Reset: 0h. Control for Emulation64." />
      <field name="Smicontrol89" bit="18" size="2" desc="Read-write. Reset: 0h. Control for ThermalTrip# assertion." />
      <!-- Bits 17:10 reserved. -->
      <field name="Smicontrol84" bit="8" size="2" desc="Read-write. Reset: 0h. Control for SERR#." />
      <field name="Smicontrol83" bit="6" size="2" desc="Read-write. Reset: 0h. Control for ProcHot." />
      <field name="Smicontrol82" bit="4" size="2" desc="Read-write. Reset: 0h. Control for VBAT low." />
      <field name="Smicontrol81" bit="2" size="2" desc="Read-write. Reset: 0h. Control for Intruder event." />
      <!-- Bits 1:0 reserved. -->
    </register>

    <!-- page 424 -->

    <register name="SmiCtl8" type="memory" device="SMI" offset="0x0C0" size="4" desc="SmiControl8. Read-write. Reset: 0000_0000h. This register specifies the control mechanism for SMI sources in FCH::SMI::SmiStat4[15:0].">
      <field name="Smicontrol143" bit="30" size="2" desc="Read-write. Reset: 0h. Control for Long Timer." />
      <field name="Smicontrol142" bit="28" size="2" desc="Read-write. Reset: 0h. Control for Short Timer." />
      <field name="Smicontrol141" bit="26" size="2" desc="Read-write. Reset: 0h. Control for CF9 IO Write." />
      <!-- Bits 25:12 reserved. -->
      <field name="Smicontrol133" bit="10" size="2" desc="Read-write. Reset: 0h. Control for Fan0 Tach 0 too slow event." />
      <!-- Bits 9:0 reserved. -->
    </register>

    <!-- page 425 -->

    <register name="SmiCtl9" type="memory" device="SMI" offset="0x0C4" size="4" desc="SmiControl9. Read-write. Reset: 0000_0000h. This register specifies the control mechanism for SMI sources in FCH::SMI::SmiStat4[31:16].">
      <!-- Bits 31:26 reserved. -->
      <field name="Smicontrol156" bit="24" size="2" desc="Read-write. Reset: 0h. Control for configuration cycle trapping 0." />
      <!-- Bits 23:18 reserved. -->
      <field name="Smicontrol152" bit="16" size="2" desc="Read-write. Reset: 0h. Control for memory trapping 0." />
      <field name="Smicontrol151" bit="14" size="2" desc="Read-write. Reset: 0h. Control for IO trapping 3." />
      <field name="Smicontrol150" bit="12" size="2" desc="Read-write. Reset: 0h. Control for IO trapping 2." />
      <field name="Smicontrol149" bit="10" size="2" desc="Read-write. Reset: 0h. Control for IO trapping 1." />
      <field name="Smicontrol148" bit="8" size="2" desc="Read-write. Reset: 0h. Control for IO trapping 0." />
      <!-- Bits 7:6 reserved. -->
      <field name="Smicontrol146" bit="4" size="2" desc="Read-write. Reset: 0h. Control for ESPI_SMI_B." />
      <!-- Bits 3:2 reserved. -->
      <field name="Smicontrol144" bit="0" size="2" desc="Read-write. Reset: 0h. Control for AB SMI trapping request." />
    </register>

    <!-- 9.2.5 High Precision Event Timer (HPET) Registers -->

    <!-- page 426 -->

    <register name="HpetId" type="memory" device="HPET" offset="0x000" size="4" desc="ID. Read-only. Reset: 1022_8201h.">
      <field name="VendorID" bit="16" size="16" desc="Read-only. Reset: 1022h. Vendor ID." />
      <field name="LegacyCap" bit="15" size="1" desc="Read-only. Reset: 1. Legacy replacement interrupt is supported." />
      <!-- Bit 14 reserved. -->
      <field name="CounterSizeCap" bit="13" size="1" desc="Read-only. Reset: 0. 0=32-bits wide. 1=64-bits wide." />
      <field name="NumTmrCap" bit="8" size="5" desc="Read-only. Reset: 02h. Three timers are supported." />
      <field name="RevID" bit="0" size="8" desc="Read-only. Reset: 01h. Revision ID." />
    </register>
    <register name="ClkPeriod" type="memory" device="HPET" offset="0x004" size="4" desc="ClkPeriod. Read-only. Reset: 0429_B17Eh.">
      <field name="CounterClkPeriod" bit="0" size="32" desc="Read-only. Reset: 0429_B17Eh. Specifies the clock period of each HPET timer tick. HPET main counter runs at 14.31818 MHz. The unit is femtosecond (10^-15 seconds). The value of this register can be modified through FCH::TMR::HPET::ClkPeriod." />
    </register>
    <register name="Cfg" type="memory" device="HPET" offset="0x010" size="4" desc="Config. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:2 reserved. -->
      <field name="LegacyEn" bit="1" size="1" desc="Read-write. Reset: 0. 1=Timer0 interrupt goes to IRQ0 of PIC controller, INT2 of IOAPIC; Timer1 interrupt goes to IRQ8 of PIC controller, INT8 of IOAPIC." />
      <field name="TmrEn" bit="0" size="1" desc="Read-write. Reset: 0. 0=Pause main counter and disable all timer interrupts. 1=Allow main counter to run and allow timer interrupts if enabled." />
    </register>

    <!-- page 427 -->

    <register name="IntStat" type="memory" device="HPET" offset="0x020" size="4" desc="Interrupt Status. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="MainCtr" type="memory" device="HPET" offset="0x0F0" size="8" desc="Main Counter. Read-write. Reset: 0000_0000_0000_0000h.">
      <field name="MainCounterHi" bit="32" size="32" desc="Read-write. Reset: 0000_0000h. IF (FCH::PM::PmDecodeEn[HpetWidthSel] == 1) THEN Specifies the upper 32 bits of the 64-bit HPET main counter. Bits [31:0] contain the lower 32 bits of the 64-bit HPET main counter. Should be written to only when it is halted. ELSE Reserved. ENDIF." />
      <field name="MainCounterLo" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Specified the HPET main counter, incremented by 1 on every clock. Should be written to only when it is halted." />
    </register>

    <!-- TODO Multiple BAR instances, keeping only first one: HPETx1[0...4]0 [Timer[2:0] Config Capability] (FCH::TMR::HPET::TimerCfgCap) -->
    <register name="TimerCfgCap" type="memory" device="HPET" offset="0x100" size="8" desc="Timer[2:0] Config Capability. Reset: 00C0_0000_0000_8010h.">
      <field name="TmrIntRouteCap" bit="32" size="32" desc="Read-only. Reset: 00C0_0000h. Indicates which INT entry of IOAPIC can be assigned to the timer interrupt." />
      <!-- Bits 31:16 reserved. -->
      <field name="TmrFsbCap" bit="15" size="1" desc="Read-only. Reset: 1. 1=Front side bus delivery is supported." />
      <field name="TmrFsbEn" bit="14" size="1" desc="Read-write. Reset: 0. 1=Enable front side bus delivery of interrupt." />
      <field name="TmrIntRoute" bit="9" size="5" desc="Read-write. Reset: 00h. This specifies which INT entry of IOAPIC the timer is routed to if FCH::TMR::HPET::Cfg[LegacyEn] == 0." />
      <field name="Tmr32ModeEn" bit="8" size="1" desc="Read-only. Reset: 0. 0=64-bit timer is not supported. 1=64-bit timer is supported." />
      <!-- Bit 7 reserved. -->
      <field name="TmrSetPer" bit="6" size="1" desc="Read-write. Reset: 0. 1=Allow software to set the timer's accumulator if the timer is set to periodic mode. The bit is automatically cleared when FCH::TMR::HPET::TimerComparator is written by software." />
      <field name="TmrSizeCap" bit="5" size="1" desc="Read-only. Reset: 0. The timer is 32-bits wide." />
      <field name="TmrTypCap" bit="4" size="1" desc="Read-only. Reset: 1. The timer supports periodic interrupt delivery mode." />
      <field name="TmrTyp" bit="3" size="1" desc="Read-write. Reset: 0. 0=Non-periodic. 1=Periodic. Selects the timer interrupt type." />
      <field name="TmrIntEn" bit="2" size="1" desc="Read-write. Reset: 0. 1=Enable the timer interrupt." />
      <field name="TmrIntTyp" bit="1" size="1" desc="Read-write. Reset: 0. 0=Edge triggered. 1=Level triggered. Specifies the timer interrupt polarity." />
      <!-- Bit 0 reserved. -->
    </register>

    <!-- TODO Multiple BAR instances, keeping only first one: HPETx1[0...4]8 [Timer[2:0] Comparator] (FCH::TMR::HPET::TimerComparator) -->
    <register name="TimerComparator" type="memory" device="HPET" offset="0x108" size="8" desc="Timer[2:0] Comparator. Read-write. Reset: 0000_0000_FFFF_FFFFh.">
      <field name="ComparatorHi" bit="32" size="32" desc="Read-write. Reset: 0000_0000h. IF (FCH::PM::PmDecodeEn[HpetWidthSel] == 1) THEN ELSE ENDIF. Specifies the upper 32 bits of the 64-bit timer comparator. Bits [31:0] contain the lower 32 bits of the 64-bit timer comparator. ELSE Reserved. ENDIF." />
      <field name="ComparatorLo" bit="0" size="32" desc="Read-write. Reset: FFFF_FFFFh. IF (FCH::TMR::HPET::TimerCfgCap[TmrTyp] == 0) THEN Read-write. ELSEIF ((FCH::TMR::HPET::TimerCfgCap[TmrTyp] == 1) &amp;&amp; (FCH::TMR::HPET::TimerCfgCap[TmrSetPer] == 1)) THEN Read-write. ELSE Read-only. ENDIF. The comparator is periodically incremented by the value last written to this register. This register is updated by hardware when (FCH::TMR::HPET::TimerCfgCap[TmrTyp] == 1)." />
    </register>

    <!-- page 428 -->

    <!-- TODO Multiple BAR instances, keeping only first one: HPETx1[1...5]0 [Timer[2:0] FSB Interrupt Data] (FCH::TMR::HPET::TimerFSBIntData) -->
    <register name="TimerFSBIntData" type="memory" device="HPET" offset="0x110" size="4" desc="Timer[2:0] FSB Interrupt Data. Read-write. Reset: 0000_0000h.">
      <field name="TnFsbIntVal" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Software sets this 32-bit field to specify the write data of Front Side Bus (FSB) Interrupt Message." />
    </register>

    <!-- TODO Multiple BAR instances, keeping only first one: HPETx1[1...5]4 [Timer[2:0] FSB Interrupt Address] (FCH::TMR::HPET::TimerFSBIntAddr) -->
    <register name="TimerFSBIntAddr" type="memory" device="HPET" offset="0x114" size="4" desc="Timer[2:0] FSB Interrupt Address. Read-write. Reset: 0000_0000h.">
      <field name="TnFsbIntAddr" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Software sets this 32-bit field to specify the address of Front Side Bus (FSB) Interrupt Message." />
    </register>

    <!-- TODO Multiple BAR instances, keeping only first one: HPETx1[B...D]0 [Timer[2:0] Comparator Base Shadow] (FCH::TMR::HPET::TimerComparatorBaseShadow) -->
    <register name="TimerComparatorBaseShadow" type="memory" device="HPET" offset="0x1B0" size="8" desc="Timer[2:0] Comparator Base Shadow. Read-write. Reset: 0000_0000_FFFF_FFFFh.">
      <field name="TmrCompBaseShadowHi" bit="32" size="32" desc="Read-write. Reset: 0000_0000h. IF (FCH::PM::PmDecodeEn[HpetWidthSel] == 1) THEN ELSE ENDIF. This is a shadow of the base value of FCH::TMR::HPET::TimerComparator_n[2:0] [ComparatorHi]. Reading this register returns the base value of FCH::TMR::HPET::TimerComparator_n[2:0] [ComparatorHi]. Writing the register changes the base value of FCH::TMR::HPET::TimerComparator_n[2:0] [ComparatorHi]." />
      <field name="TmrCompBaseShadowLo" bit="0" size="32" desc="Read-write. Reset: FFFF_FFFFh. This is shadow of the base value of FCH::TMR::HPET::TimerComparator_n[2:0][ComparatorLo]. Reading this register returns the base value of FCH::TMR::HPET::TimerComparator_n[2:0][ComparatorLo]. Writing the register changes the base value of FCH::TMR::HPET::TimerComparator_n[2:0][ComparatorLo]." />
    </register>

    <!-- TODO Multiple BAR instances, keeping only first one: HPETx1[B...D]8 [Timer[2:0] Comparator Shadow] (FCH::TMR::HPET::TimerComparatorShadow) -->
    <register name="TimerComparatorShadow" type="memory" device="HPET" offset="0x1B8" size="8" desc="Timer[2:0] Comparator Shadow. Read-write. Reset: 0000_0000_FFFF_FFFFh.">
      <field name="TmrCompShadowHi" bit="32" size="32" desc="Read-write. Reset: 0000_0000h. IF (FCH::PM::PmDecodeEn[HpetWidthSel] == 1) THEN ELSE ENDIF. This is a shadow of the current value of FCH::TMR::HPET::TimerComparator_n[2:0] [ComparatorHi]. Reading this register returns the current value of FCH::TMR::HPET::TimerComparator_n[2:0] [ComparatorHi]. Writing the register changes the current value of FCH::TMR::HPET::TimerComparator_n[2:0] [ComparatorHi]." />
      <field name="TmrCompShadowLo" bit="0" size="32" desc="Read-write. Reset: FFFF_FFFFh. This is shadow of the current value of FCH::TMR::HPET::TimerComparator_n[2:0][ComparatorLo]. Reading this register returns the current value of FCH::TMR::HPET::TimerComparator_n[2:0][ComparatorLo]. Writing the register changes the current value of FCH::TMR::HPET::TimerComparator_n[2:0][ComparatorLo]." />
    </register>
    <register name="MainCtrRTC" type="memory" device="HPET" offset="0x1E0" size="8" desc="Main Counter RTC. Read-write. Reset: 0000_0000_0000_0000h.">
      <field name="MainCounterRtcHi" bit="32" size="32" desc="Read-write. Reset: 0000_0000h. IF (FCH::PM::PmDecodeEn[HpetWidthSel] == 1) THEN Specifies the shadow of FCH::TMR::HPET::MainCtr[MainCounterHi]. See MainCounterRtcLo. ELSE Reserved. ENDIF." />
      <field name="MainCounterRtcLo" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. This is a shadow of FCH::TMR::HPET::MainCtr[MainCounterLo]. It samples the value of Main Counter at every falling edge of RTC 32 KHz clock for software to Read. When software Writes this register, FCH::TMR::HPET::MainCtr[MainCounterLo] is updated with the same value written to this register, and then enabled counting at the next RTC clock falling edge. The purpose of this register is for the convenience of   software save-restore HPET." />
    </register>

    <!-- page 429 -->

    <register name="NextTimerRemain" type="memory" device="HPET" offset="0x1E8" size="8" desc="Next Timer Remain. Reset: 0000_0000_FFFF_FFFFh.">
      <field name="NxtTmrRemainHi" bit="32" size="32" desc="Read-write. Reset: 0000_0000h. IF (FCH::PM::PmDecodeEn[HpetWidthSel] == 1) THEN Specifies the upper 32 bits of the timer ticks remaining before the next enabled comparator interrupt. ELSE Reserved. ENDIF." />
      <field name="NxtTmrRemainLo" bit="0" size="32" desc="Read-only. Reset: FFFF_FFFFh. Specifies how many timer ticks remaining before the next enabled comparator interrupt." />
    </register>

    <!-- 9.2.6 Watchdog Timer (WDT) Registers -->

    <register name="WatchdogCtl" type="memory" device="WDT" offset="0x000" size="4" desc="WatchdogControl.">
      <!-- Bits 31:8 reserved. -->
      <field name="WatchdogTrigger" bit="7" size="1" desc="Write-1-only. Reset: 0. Writing 1 to this bit triggers the watchdog to start a new count interval, counting down from the value that was last written to FCH::TMR::WDT::WatchdogCnt." />
      <!-- Bits 6:4 reserved. -->
      <field name="WatchdogDisable" bit="3" size="1" desc="Read-only. Reset: 1. 0=Enable. 1=Disable. This bit reflects the state of the watchdog timer hardware. This bit reflects the state of FCH::PM::PmDecodeEn[WatchdogTmrEn]." />
      <field name="WatchdogAction" bit="2" size="1" desc="Read-write. Reset: 0. 0=System reset. 1=System power off. This bit determines the action to be taken when the watchdog timer expires. The bit is only valid when the watchdog is enabled." />
      <field name="WatchdogFired" bit="1" size="1" desc="Read,Write-1-to-clear. Reset: Cold,0. 1=The watchdog timer has expired and caused the current restart. The bit is cleared by a power cycle or by the operating system and it must remain cleared for any restart that is not caused by the watchdog timer firing. The bit is only valid when the watchdog is enabled." />
      <field name="WatchdogRunStopB" bit="0" size="1" desc="Read-write. Reset: 0. 0=Watchdog is in the stopped state. 1=Watchdog is in the running state. This bit is used to control or indicate whether the watchdog is in the running or stopped states. If the watchdog is in the stopped state and a 1 is written to this bit, the watchdog moves to the running state, but a count interval is not started until a 1 is written to WatchdogTrigger. If the watchdog is in the running state, writing 1 to this bit has no effect. The bit is only valid when the watchdog is enabled." />
    </register>
    <register name="WatchdogCnt" type="memory" device="WDT" offset="0x004" size="4" desc="WatchdogCount. Read-write.">
      <!-- Bits 31:16 reserved. -->
      <field name="WatchdogCount" bit="0" size="16" desc="Read-write. Reset: XXXXh. Writing this field specifies the countdown time for the counter." />
    </register>

    <!-- 9.2.7 Wake Alarm Device (AcDcTimer) Registers -->

    <!-- page 430 -->

    <register name="AcTimerVal" type="memory" device="ACDC" offset="0x000" size="4" desc="AcTimerValue. Read-write. Reset: FFFF_FFFFh.">
      <field name="AcTimerValue" bit="0" size="32" desc="Read-write. Reset: FFFF_FFFFh. Description: Writing the register with a value other than FFFF_FFFFh starts the AC timer. Reading this register returns the current value of the AC timer. When the AC or DC timer generates a wake up event, this register is reset to FFFF_FFFFh by hardware." />
    </register>
    <register name="AcExpiredTimerPolicy" type="memory" device="ACDC" offset="0x004" size="4" desc="AcExpiredTimerPolicy. Read-write. Reset: FFFF_FFFFh.">
      <field name="AcExpiredTimerPolicy" bit="0" size="32" desc="Read-write. Reset: FFFF_FFFFh. When the AC timer expires, the wake signal is asserted if the current power source is AC; the wake signal is not asserted if the current power source is DC. If the power source is switched from DC to AC after the AC timer expired, we wait for the number of seconds defined in this register and then wake up the system. When the AC or DC timer generates a wake up event, this register is reset to FFFF_FFFFh by hardware." />
    </register>
    <register name="AcTimerStatus" type="memory" device="ACDC" offset="0x008" size="4" desc="AcTimerStatus. Read,Write-1-to-clear. Reset: 0000_0000h.">
      <!-- Bits 31:2 reserved. -->
      <field name="AcTimerWakeup" bit="1" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Wake-up was not caused by AC timer expiration. 1=Wake up was caused by AC timer expiration." />
      <field name="AcTimerExpired" bit="0" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=AC timer has not expired. 1=AC timer expired." />
    </register>
    <register name="DcTimerVal" type="memory" device="ACDC" offset="0x010" size="4" desc="DcTimerValue. Read-write. Reset: FFFF_FFFFh.">
      <field name="DcTimerValue" bit="0" size="32" desc="Read-write. Reset: FFFF_FFFFh. Description: Writing the register with a value other than FFFF_FFFFh starts the DC timer. Reading this register returns the current value of the DC timer. When the AC or DC timer generates a wake up event, this register is reset to FFFF_FFFFh by hardware." />
    </register>
    <register name="DcExpiredTimerPolicy" type="memory" device="ACDC" offset="0x014" size="4" desc="DcExpiredTimerPolicy. Read-write. Reset: FFFF_FFFFh.">
      <field name="DcExpiredTimerPolicy" bit="0" size="32" desc="Read-write. Reset: FFFF_FFFFh. When the DC timer expires, the wake signal is asserted if the current power source is DC; the wake signal is not asserted if the current power source is AC. If the power source is switched from AC to DC after the DC timer expired, the device waits for the number of seconds defined in this register and then wakes up the system. When the AC or DC timer generates a wake up event, this register is reset to FFFF_FFFFh by hardware." />
    </register>

    <!-- page 431 -->

    <register name="DcTimerStatus" type="memory" device="ACDC" offset="0x018" size="4" desc="DcTimerStatus. Read,Write-1-to-clear. Reset: 0000_0000h.">
      <!-- Bits 31:2 reserved. -->
      <field name="DcTimerWakeup" bit="1" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Wake-up was not caused by DC timer expiration. 1=Wake- up was caused by DC timer expiration." />
      <field name="DcTimerExpired" bit="0" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=DC timer has not expired. 1=DC timer expired." />
    </register>
    <register name="AcDcTimerCtrl" type="memory" device="ACDC" offset="0x020" size="4" desc="AcDcTimerCtrl. Reset: 0000_0000h.">
      <!-- Bits 31:10 reserved. -->
      <field name="DcTimerEventEn" bit="9" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable DC Timer to wake up system." />
      <field name="AcTimerEventEn" bit="8" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable AC Timer to wake up system." />
      <!-- Bits 7:1 reserved. -->
      <field name="Busy" bit="0" size="1" desc="Read-only. Reset: 0. Right after FCH::TMR::ACDC::AcTimerVal or FCH::TMR::ACDC::DcTimerVal is programmed, the hardware sets this bit to 1. The hardware clears this bit once the programming is done and the corresponding timer is started properly. Before the software writes to FCH::TMR::ACDC::AcTimerVal or FCH::TMR::ACDC::DcTimerVal, it has to read this bit and make sure it is 0. Otherwise, the hardware just ignores the programming action from software. For the registers other than FCH::TMR::ACDC::AcTimerVal or FCH::TMR::ACDC::DcTimerVal, there is no such limitation." />
    </register>

    <!-- 9.2.8 Always On Always Connected (AOAC) Registers -->

    <!-- page 432 -->

    <!-- TODO Multiple BAR instances, keeping only first one: AOACx0000[40...7E] [Device D3 Control] (FCH::AOAC::DevD3Ctl) -->
    <register name="DevD3Ctl" type="memory" device="AOAC" offset="0x000040" size="1" desc="Device D3 Control. Read-write. AOAC=FED8_1E00h">
      <field name="IsSwControl" bit="7" size="1" desc="Read-write. Reset: 0. 0=Hardware controls control signals (PwrRstB, RefClkOk, RstB) to the device. 1=Software controls control signals (PwrRstB, RefClkOk, RstB) to the device. Software must set bit IsSwControl first before programming bits SwPwrOnRstB, SwRefClkOk and SwRstB, otherwise, unpredictable behavior may result." />
      <field name="SwRstB" bit="6" size="1" desc="Read-write. Reset: 1. 0=RstB is asserted to the device if IsSwControl == 1. 1=RstB is de-asserted to the device if IsSwControl == 1." />
      <field name="SwRefClkOk" bit="5" size="1" desc="Read-write. Reset: 1. 0=RefClkOk is de-asserted to the device if IsSwControl == 1. 1=RefClkOk is asserted to the device if IsSwControl == 1." />
      <field name="SwPwrOnRstB" bit="4" size="1" desc="Read-write. Reset: 1. 0=PwrRstB is asserted to the device if IsSwControl == 1. 1=PwrRstB is de-asserted to the device if IsSwControl == 1." />
      <field name="PwrOnDev" bit="3" size="1" desc="Read-write. Reset: X. 0=Put device in reset state. 1=Put device out of reset state. If SwControl == 0, software can write this bit to trigger a hardware controlled reset sequence to the device. Default value is 0 when N=13-15, 18-24, 29. Default value is 1 when N!=13-15, 18-24, 29." />
      <field name="DeviceState" bit="2" size="1" desc="Read-write. Reset: 1. 0=Device power is removed. 1=Device power is applied. Software records the device power state in this field." />
      <field name="TargetedDeviceState" bit="0" size="2" desc="Read-write. Reset: 1h. Software records D-State of the device in this field. Default value is 01b when N=0-12, 16-17, 25-28, 30-31. Default value is 00b when N=13-15, 18-24, 29." />
    </register>

    <!-- TODO Multiple BAR instances, keeping only first one: AOACx0000[41...7F] [Device D3 State] (FCH::AOAC::DevD3State) -->
    <register name="DevD3State" type="memory" device="AOAC" offset="0x000041" size="1" desc="Device D3 State. Read-only. Reset: 27h. AOAC=FED8_1E00h">
      <field name="Stat1" bit="7" size="1" desc="Read-only. Reset: 0. State of device." />
      <field name="Stat0" bit="6" size="1" desc="Read-only. Reset: 0. State of device." />
      <field name="ClkOkState" bit="5" size="1" desc="Read-only. Reset: 1. Specifies the state of device's ClkOk signal." />
      <field name="D3Cold" bit="4" size="1" desc="Read-only. Reset: 0. Specifies the state of device's D3 Cold signal." />
      <field name="DevOffGatingState" bit="3" size="1" desc="Read-only. Reset: 0. Specifies the state of device's DevOffGating signal." />
      <field name="RstBState" bit="2" size="1" desc="Read-only. Reset: 1. Specifies the state of device's RstB signal." />
      <field name="RefClkOkState" bit="1" size="1" desc="Read-only. Reset: 1. Specifies the state of device's RefClkOk signal." />
      <field name="PwrRstBState" bit="0" size="1" desc="Read-only. Reset: 1. Specifies the state of device's PwrRstB signal." />
    </register>
    <register name="ShadowRegStat" type="memory" device="AOAC" offset="0x000084" size="4" desc="Shadow Register Status. Read-write. Reset: 3FFF_FFFFh.">
      <!-- Bits 31:30 reserved. -->
      <field name="Status" bit="0" size="30" desc="Read-write. Reset: 3FFF_FFFFh. Reading these bits returns the status of the store or restore action. Each  bit represents the status of a device. For each bit, Software can also write this register to 1 or 0. This provides software a way to override the status." />
    </register>

    <!-- page 434 -->

    <register name="ShadowRegSRAMAddr" type="memory" device="AOAC" offset="0x000088" size="4" desc="Shadow Register SRAM Addr. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="ShadowSRamAddr" bit="0" size="16" desc="Read-write. Reset: 0000h. Software has indirect access to the SRAM in shadow register block via FCH::AOAC::ShadowRegSRAMAddr and FCH::AOAC::ShadowRegSRAMData. The field specifies the shadow SRAM address to be accessed." />
    </register>
    <register name="ShadowRegSRAMData" type="memory" device="AOAC" offset="0x00008C" size="4" desc="Shadow Register SRAM Data. Read-write. Reset: 0000_0000h.">
      <field name="ShadowSRamData" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Specifies the data to be written or read for the shadow SRAM address specified by FCH::AOAC::ShadowRegSRAMAddr." />
    </register>
    <register name="S0I3Ctl" type="memory" device="AOAC" offset="0x000094" size="4" desc="S0I3 Control. Reset: 0000_0000h.">
      <!-- Bits 31:18 reserved. -->
      <field name="PllOffReq" bit="17" size="1" desc="Write-only. Reset: 0. Read back always 0. SMU can write 1 to this bit to request FCH to shutdown CGPLL." />
      <field name="IntrBlocked" bit="16" size="1" desc="Read-only. Reset: 0. 0=FCH interrupts are not blocked. 1=FCH interrupts are blocked. If the FCH is sending an interrupt message when software or SMU write 1 to InterruptDis, the interrupt is blocked &quot;gracefully&quot;. Wait until the interrupt is sent and then block the interrupt. This bit indicates the interrupt blocking status." />
      <field name="InterruptDis" bit="15" size="1" desc="Read-write. Reset: 0. 0=Interrupt from FCH is enabled. 1=Interrupt from FCH is disabled. Software is able to set and clear this bit. Hardware can only set this bit." />
      <field name="ArbiterDis" bit="14" size="1" desc="Read-write. Reset: 0. 0=FCH upstream arbiter is enabled. 1=FCH upstream arbiter is disabled. Software is able to set and clear this bit. Hardware can only set this bit." />
      <!-- Bits 13:11 reserved. -->
      <field name="ShadowTimerWakeSts" bit="10" size="1" desc="Read-only. Reset: 0. 0=Shadow Timer did not fire. 1=Shadow Timer fired and caused a wake-up from the S0I3 state. Harware clears this bit during S0I3 entry." />
      <field name="S0I3Resume" bit="9" size="1" desc="Read,Write-1-to-clear. Reset: 0. Set to 1 by S0I3 exit to indicate the system has resumed from the S0I3 state. The bit is cleared by S0I3 entry or write-1-to-cleared by software." />
      <field name="S0I3Enter" bit="8" size="1" desc="Read-only. Reset: 0. 0=Indicate the system is in S0 state. 1=Indicate the system is in S0I3 state." />
      <!-- Bits 7:5 reserved. -->
      <field name="S0I3Trigger" bit="4" size="1" desc="Write-only. Reset: 0. Setting the bit to 1 triggers S0I3 power down sequence." />
      <!-- Bit 3 reserved. -->
      <field name="S0I3Ready2" bit="2" size="1" desc="Read-write. Reset: 0. 0=S0I3 can't be entered. 1=S0I3 can be entered. Programmed by Driver." />
      <field name="S0I3OnSlpS3B" bit="1" size="1" desc="Read-write. Reset: 0. 0=SLP_S3# doesn't assert in S0I3 state. 1=SLP_S3# asserts in S0I3 state." />
      <field name="S0I3Ready" bit="0" size="1" desc="Read-write. Reset: 0. 0=S0I3 cannot be entered. 1=S0I3 can be entered. Programmed by BIOS." />
    </register>

    <!-- page 435 -->

    <register name="ShadowTimerCtl" type="memory" device="AOAC" offset="0x00009C" size="4" desc="Shadow Timer Control. Read-write. Reset: 0000_0000h.">
      <field name="RestoredOffset64" bit="24" size="8" desc="Read-write. Reset: 00h. Specifies a programmable offset to be added to restored HPET 64-bit timer; this is to account for restore time uncertainty." />
      <field name="RestoredOffset" bit="16" size="8" desc="Read-write. Reset: 00h. Specifies a programmable offset to be added to restored HPET 32-bit timer and ACPI timer; this is to account for restore time uncertainty." />
      <field name="EarlyCount" bit="8" size="8" desc="Read-write. Reset: 00h. Specifies a programmable offset to be subtracted from the alarm value." />
      <!-- Bits 7:3 reserved. -->
      <field name="EarlyCountUnit" bit="2" size="1" desc="Read-write. Reset: 0. 0=The unit of EarlyCount is 1 RTC clock period. 1=The unit of EarlyCount is 16 RTC clock period." />
      <field name="ShadowAcpiTimerEn" bit="1" size="1" desc="Read-write. Reset: 0. 1=Enable control to perform store/restore operation for ACPI timer." />
      <field name="ShadowHpetEn" bit="0" size="1" desc="Read-write. Reset: 0. 1=Enable control to perform store/restore operation from HPET timer." />
    </register>
    <register name="PwrGoodCtl" type="memory" device="AOAC" offset="0x0000A0" size="4" desc="PwrGood Control. Read-write. Reset: 0000_8003h.">
      <!-- Bits 31:25 reserved. -->
      <field name="SpiPadDisable" bit="24" size="1" desc="Read-write. Reset: 0. 1=Disable the OE and PU of the SPI pads." />
      <field name="LpcPadDisable" bit="23" size="1" desc="Read-write. Reset: 0. 1=Disable the OE and PU of the LPC pads." />
      <!-- Bits 22:16 reserved. -->
      <field name="PowerAllPwrIsland" bit="15" size="1" desc="Read-write. Reset: 1. 0=When software programs [PG1a/PG2/XHC], ACPI powers up all groups immediately. 1=Indicates that when software programs [PG1a/PG2/XHC], ACPI powers up all power groups sequentially to avoid current surge. If the platform supports AOAC, this bit must be 0 during boot, otherwise, this bit remains set." />
      <!-- Bits 14:2 reserved. -->
      <field name="PG2PwrGood" bit="1" size="1" desc="Read-write. Reset: 1. 0=PG2 is powered down. 1=PG2 is powered up. Controls the power of Power Group 2. Waking up from S3 or S5 sets this bit to default value." />
      <field name="PG1aPwrGood" bit="0" size="1" desc="Read-write. Reset: 1. 0=PG1a is powered down. 1=PG1a is powered up. Controls the power of Power Group 1a. Waking up from S3 or S5 sets this bit to default value." />
    </register>

    <!-- 9.2.9.1 Device 14h Function 3 (LPC Bridge) Configuration Registers -->

    <!-- page 436 -->

    <register name="PciDevVendID" type="pcicfg" device="LPC" offset="0x000" size="4" desc="Device/Vendor ID. Read-only.">
      <field name="DeviceID" bit="16" size="16" desc="Device Identifier. Read-only. Reset: Fixed,790Eh. This 16-bit field is assigned by the device  manufacturer and identifies the type of device." />
      <field name="VendorID" bit="0" size="16" desc="Vendor Identifier. Read-only. Reset: 1022h. PCI vendor identifier." />
    </register>
    <register name="PciStatCmd" type="pcicfg" device="LPC" offset="0x004" size="4" desc="Status/Command.">
      <field name="DetectedParityError" bit="31" size="1" desc="Detected Parity Error. Read,Write-1-to-clear. Reset: 0. 1=The FCH detects a parity error. Parity error detection." />
      <field name="SignaledSystemError" bit="30" size="1" desc="Signaled System Error. Read,Write-1-to-clear. Reset: 0. 1=The FCH detects a PCI address parity error. System error detection." />
      <field name="ReceivedMasterAbort" bit="29" size="1" desc="Received Master Abort. Read,Write-1-to-clear. Reset: 0. 1=The FCH acts as a PCI master and aborts a PCI bus memory cycle. Master abort received." />
      <field name="ReceivedTargetAbort" bit="28" size="1" desc="Received Target Abort. Read,Write-1-to-clear. Reset: 0. 1=An FCH generated PCI cycle (the FCH is the PCI master) is aborted by a PCI target. Target abort received." />
      <field name="SignaledTargetAbort" bit="27" size="1" desc="Signaled Target Abort. Read,Write-1-to-clear. Reset: 0. 1=The FCH signals target abort. Target abort signal." />
      <field name="DeviceSelectTiming" bit="25" size="2" desc="Device Select Timing. Read-only. Reset: Fixed,1h. Indicates DEVSEL# timing when performing a positive decode. DEVSEL# is asserted to meet the medium timing." />
      <field name="MasterDataParityError" bit="24" size="1" desc="Master Data Parity Error. Read,Write-1-to-clear. Reset: 0. 1=The FCH detects PERR# asserted while acting as PCI master regardless whether PERR# was driven by the FCH or not. Master data parity error." />
      <!-- Bits 23:21 reserved. -->
      <field name="CapabilitiesList" bit="20" size="1" desc="Capabilities List. Read-only. Reset: 0. Always reads 0." />
      <!-- Bits 19:10 reserved. -->
      <field name="FastBack2BackEnable" bit="9" size="1" desc="Fast Back-to-Back Enable. Read-only. Reset: Fixed,0. Enable fast back-to-back transactions." />
      <field name="SERREnable" bit="8" size="1" desc="SERR# Enable. Read-only. Reset: 0. 0=SERR# is not asserted. 1=The FCH asserts SERR# when it detects an address parity error. SERR# assertion on address parity error." />
      <field name="SteppingControl" bit="7" size="1" desc="Stepping Control. Read-only. Reset: Fixed,0. Stepping control." />
      <field name="ParityErrorResponse" bit="6" size="1" desc="Parity Error Response. Read-write. Reset: 0. 0=PERR# is not asserted. 1=The FCH asserts PERR# when it is the agent receiving data and it detects a parity error. PERR# (Response) Detection enable bit." />
      <field name="VGAPaletteSnoop" bit="5" size="1" desc="VGA Palette Snoop. Read-only. Reset: Fixed,0. Snoop VGA color palette." />
      <field name="MemoryWriteAndInvalidateEnable" bit="4" size="1" desc="Memory Write and Invalidate Enable. Read-only. Reset: Fixed,0. Enables Memory Write and Invalidate command." />
      <field name="SpecialCycles" bit="3" size="1" desc="Special Cycles. Read-only. Reset: Fixed,1. Controls Special Cycle operations." />
      <field name="BusMaster" bit="2" size="1" desc="Bus Master. Read-only. Reset: 1. 1=Bus master enabled." />
      <field name="MemorySpace" bit="1" size="1" desc="Memory Space. Read-only. Reset: Fixed,1. Controls a device's response to Memory Space accesses." />
      <field name="IOSpace" bit="0" size="1" desc="IO Space. Read-only. Reset: 1. 1=Enable access to the legacy IDE ports and PCI bus master IDE IO registers are enabled. This bit controls access to the IO space registers." />
    </register>
    <register name="PciClassCodeRevId" type="pcicfg" device="LPC" offset="0x008" size="4" desc="Revision ID/Class Code. Read-only.">
      <field name="ClassCode" bit="8" size="24" desc="Class Code. Read-only. Reset: 06_0100h. Indicates an ISA bridge." />
      <field name="RevisionID" bit="0" size="8" desc="Revision ID. Read-only. Reset: Fixed,51h. Indicates the revision level of the design." />
    </register>

    <!-- page 437 -->

    <register name="PciHeadType" type="pcicfg" device="LPC" offset="0x00C" size="4" desc="Cache Line Size. Read-only.">
      <field name="Bist" bit="24" size="8" desc="Read-only. Reset: 00h. No BIST modes." />
      <field name="HeaderType" bit="16" size="8" desc="Header Type. Read-only. Reset: 80h. Identifies the type of the predefined header in the configuration space. The most significant bit is set to 1 to indicate a multi-function device." />
      <field name="LatencyTimer" bit="8" size="8" desc="Latency Timer. Read-only. Reset: 00h. Specifies the value of the latency timer in units of PCICLKs." />
      <field name="CacheLineSize" bit="0" size="8" desc="Cache Line Size. Read-only. Reset: Fixed,00h. Specifies the size of the cache line." />
    </register>
    <register name="BaseAddrReg0" type="pcicfg" device="LPC" offset="0x010" size="4" desc="Base Address Reg 0.">
      <field name="BaseAddress0[31:5]" bit="5" size="27" desc="Base Address 0. Write-only. Reset: Fixed,7F6_0000h. Read as zero. This register has an internal value used as base address BaseAddress0[31:5] for APIC memory space. Writing to the register changes its internal value. The default internal base address is FEC0_0000h." />
      <field name="BaseAddress0[4:0]" bit="0" size="5" desc="Read-only. Reset: 00h. This register has an internal value used as base address BaseAddress0[4:0] for APIC memory space." />
    </register>
    <register name="SubsystemIDSubsystemVendorID" type="pcicfg" device="LPC" offset="0x02C" size="4" desc="Subsystem ID and Subsystem Vendor ID. Read,Write-once. Reset: 790E_1022h.">
      <field name="SubsystemID" bit="16" size="16" desc="Subsystem ID. Read,Write-once. Reset: 790Eh. Subsystem identifier." />
      <field name="SubsystemVendorID" bit="0" size="16" desc="Subsystem Vendor ID. Read,Write-once. Reset: 1022h. PCI vendor identifier." />
    </register>
    <register name="PciCapPtr" type="pcicfg" device="LPC" offset="0x034" size="4" desc="Capabilities Pointer. Read-only. Reset: 0000_0000h.">
      <!-- Bits 31:8 reserved. -->
      <field name="CapabilitiesPointer" bit="0" size="8" desc="Capabilities Pointer. Read-only. Reset: 00h. No capability, always Read 00h." />
    </register>
    <register name="PCICtl" type="pcicfg" device="LPC" offset="0x040" size="4" desc="PCI Control. Reset: 0000_001Ch.">
      <!-- Bits 31:7 reserved. -->
      <field name="EcSemaphore" bit="6" size="1" desc="Read-only. Reset: 0. 0=SPI ROM is not locked by External EC. 1=SPI ROM is locked by External EC. SPI ROM locking." />
      <field name="BiosSemaphore" bit="5" size="1" desc="Read-write. Reset: 0. 0=SPI ROM is not locked by Host. 1=SPI ROM is locked by Host. This bit is writable by host to block EC ROM access. Whenever the host needs to lock down ROM access then the host should continue writing the bit to 1 until it reads back 1." />
      <field name="ExtRomSharingEn" bit="4" size="1" desc="Read-write. Reset: 1. 0=Disable ROM sharing in External mode. 1=Support ROM sharing in External mode." />
      <field name="VWRomSharingEn" bit="3" size="1" desc="Read-write. Reset: 1. 0=Disable ROM sharing in Virtual write mode. 1=Support ROM sharing in Virtual write mode." />
      <field name="LegacyDmaEnable" bit="2" size="1" desc="Legacy DMA Enable. Read-write. Reset: 1. 1=Enable LPC DMA cycle. Transfer size for channel[3:0] is 8 bits; Transfer size for channel[7:5] is 16 bits. 32-bit DMA is not supported." />
      <!-- Bits 1:0 reserved. -->
    </register>

    <!-- page 438 -->

    <register name="IOPortDecodeEn" type="pcicfg" device="LPC" offset="0x044" size="4" desc="IO Port Decode Enable. Read-write. Reset: 0000_0000h.">
      <field name="AdLibPortEnable" bit="31" size="1" desc="Ad-Lib Port Enable. Read-write. Reset: 0. 1=Enable the IO range. Port enable for Ad-Lib port, 388h-389h." />
      <field name="AcpiMicroControllerPortEnable" bit="30" size="1" desc="ACPI Micro-Controller Port Enable. Read-write. Reset: 0. 1=Enable the IO range. Port enable for ACPI micro-controller port, 62h &amp; 66h." />
      <field name="KBCPortEnable" bit="29" size="1" desc="KBC Port Enable. Read-write. Reset: 0. 1=Enable the IO range. Port enable for KBC port, 60h &amp; 64h." />
      <field name="GamePortEnable" bit="28" size="1" desc="Game Port Enable. Read-write. Reset: 0. 1=Enable the IO range. Port enable for game port, 200h-20Fh." />
      <field name="FDCPortEnable1" bit="27" size="1" desc="FDC Port Enable 1. Read-write. Reset: 0. 1=Enable the IO range. Port enable for FDC port, 370h-377h." />
      <field name="FDCPortEnable0" bit="26" size="1" desc="FDC Port Enable 0. Read-write. Reset: 0. 1=Enable the IO range. Port enable for FDC port, 3F0h-3F7h." />
      <field name="MSSPortEnable3" bit="25" size="1" desc="MSS Port Enable 3. Read-write. Reset: 0. 1=Enable the IO range. Port enable for MSS port, F40h-F47h." />
      <field name="MSSPortEnable2" bit="24" size="1" desc="MSS Port Enable 2. Read-write. Reset: 0. 1=Enable the IO range. Port enable for MSS port, E80h-E87h." />
      <field name="MSSPortEnable1" bit="23" size="1" desc="MSS Port Enable 1. Read-write. Reset: 0. 1=Enable the IO range. Port enable for MSS port, 604h-60bh." />
      <field name="MSSPortEnable0" bit="22" size="1" desc="MSS Port Enable 0. Read-write. Reset: 0. 1=Enable the IO range. Port enable for MSS port, 530h-537h." />
      <field name="MIDIPortEnable3" bit="21" size="1" desc="MIDI Port Enable 3. Read-write. Reset: 0. 1=Enable the IO range. Port enable for MIDI port, 330h-331h." />
      <field name="MIDIPortEnable2" bit="20" size="1" desc="MIDI Port Enable 2. Read-write. Reset: 0. 1=Enable the IO range. Port enable for MIDI port, 320h-321h." />
      <field name="MIDIPortEnable1" bit="19" size="1" desc="MIDI Port Enable 1. Read-write. Reset: 0. 1=Enable the IO range. Port enable for MIDI port, 310h-311h." />
      <field name="MIDIPortEnable0" bit="18" size="1" desc="MIDI Port Enable 0. Read-write. Reset: 0. 1=Enable the IO range. Port enable for MIDI port, 300h-301h." />
      <field name="AudioPortEnable3" bit="17" size="1" desc="Audio Port Enable 3. Read-write. Reset: 0. 1=Enable the IO range. Port enable for audio port, 280h-293h." />
      <field name="AudioPortEnable2" bit="16" size="1" desc="Audio Port Enable 2. Read-write. Reset: 0. 1=Enable the IO range. Port enable for audio port, 260h-273h." />
      <field name="AudioPortEnable1" bit="15" size="1" desc="Audio Port Enable 1. Read-write. Reset: 0. 1=Enable the IO range. Port enable for audio port, 240h-253h." />
      <field name="AudioPortEnable0" bit="14" size="1" desc="Audio Port Enable 0. Read-write. Reset: 0. 1=Enable the IO range. Port enable for audio port, 230h-233h." />
      <field name="SerialPortEnable7" bit="13" size="1" desc="Serial Port Enable 7. Read-write. Reset: 0. 1=Enable the IO range. Port enable for serial port, 3E8h-3EFh." />
      <field name="SerialPortEnable6" bit="12" size="1" desc="Serial Port Enable 6. Read-write. Reset: 0. 1=Enable the IO range. Port enable for serial port, 338h-33Fh." />
      <field name="SerialPortEnable5" bit="11" size="1" desc="Serial Port Enable 5. Read-write. Reset: 0. 1=Enable the IO range. Port enable for serial port, 2E8h-2EFh." />
      <field name="SerialPortEnable4" bit="10" size="1" desc="Serial Port Enable 4. Read-write. Reset: 0. 1=Enable the IO range. Port enable for serial port, 238h-23Fh." />
      <field name="SerialPortEnable3" bit="9" size="1" desc="Serial Port Enable 3. Read-write. Reset: 0. 1=Enable the IO range. Port enable for serial port, 228h-22Fh." />
      <field name="SerialPortEnable2" bit="8" size="1" desc="Serial Port Enable 2. Read-write. Reset: 0. 1=Enable the IO range. Port enable for serial port, 220h-227h." />
      <field name="SerialPortEnable1" bit="7" size="1" desc="Serial Port Enable 1. Read-write. Reset: 0. 1=Enable the IO range. Port enable for serial port, 2F8h-2FFh." />
      <field name="SerialPortEnable0" bit="6" size="1" desc="Serial Port Enable 0. Read-write. Reset: 0. 1=Enable the IO range. Port enable for serial port, 3F8h-3FFh." />
      <field name="ParallelPortEnable5" bit="5" size="1" desc="Parallel Port Enable 5. Read-write. Reset: 0. 1=Enable the IO range. Port enable for parallel port, 7BCh-7BFh." />
      <field name="ParallelPortEnable4" bit="4" size="1" desc="Parallel Port Enable 4. Read-write. Reset: 0. 1=Enable the IO range. Port enable for parallel port, 3BCh-3BFh." />
      <field name="ParallelPortEnable3" bit="3" size="1" desc="Parallel Port Enable 3. Read-write. Reset: 0. 1=Enable the IO range. Port enable for parallel port, 678h-67Fh." />
      <field name="ParallelPortEnable2" bit="2" size="1" desc="Parallel Port Enable 2. Read-write. Reset: 0. 1=Enable the IO range. Port enable for parallel port, 278h-27Fh." />
      <field name="ParallelPortEnable1" bit="1" size="1" desc="Parallel Port Enable 1. Read-write. Reset: 0. 1=Enable the IO range. Port enable for parallel port, 778h-77Fh." />
      <field name="ParallelPortEnable0" bit="0" size="1" desc="Parallel Port Enable 0. Read-write. Reset: 0. 1=Enable the IO range. Port enable for parallel port, 378h-37Fh." />
    </register>

    <!-- page 439 -->

    <register name="IOMemPortDecodeEn" type="pcicfg" device="LPC" offset="0x048" size="4" desc="IO/Mem Port Decode Enable. Read-write. Reset: 0000_FF00h.">
      <!-- Bits 31:26 reserved. -->
      <field name="WideIO2Enable" bit="25" size="1" desc="Read-write. Reset: 0. 1=Enable the IO range. Port enable for wide generic IO port 2 defined by FCH::ITF::LPC::WideIO2[IOBaseAddress2]." />
      <field name="WideIO1Enable" bit="24" size="1" desc="Read-write. Reset: 0. 1=Enable the IO range. Port enable for wide generic IO port 1 defined by FCH::ITF::LPC::PciIoBaseAddrWideGenPort[IOBaseAddress1]." />
      <field name="IOPortEnable6" bit="23" size="1" desc="IO port enable 6. Read-write. Reset: 0. 1=Enable the IO range. Port enable for IO port FD60h- FD6Fh." />
      <field name="IOPortEnable5" bit="22" size="1" desc="IO port enable 5. Read-write. Reset: 0. 1=Enable the IO range. Port enable for IO port 4700h- 470Bh." />
      <field name="IOPortEnable4" bit="21" size="1" desc="IO port enable 4. Read-write. Reset: 0. 1=Enable the IO range. Port enable for IO port 80h." />
      <field name="MemPortEnable" bit="20" size="1" desc="Mem port enable. Read-write. Reset: 0. 1=Enable the memory range. Port enable for 4K byte memory range defined in FCH::ITF::LPC::MemRng." />
      <field name="IOPortEnable3" bit="19" size="1" desc="IO port enable 3. Read-write. Reset: 0. 1=Enable the IO range. Port enable for IO port 580h- 5BFh." />
      <field name="IOPortEnable2" bit="18" size="1" desc="IO port enable 2. Read-write. Reset: 0. 1=Enable the IO range. Port enable for IO port 500h- 53Fh." />
      <field name="IOPortEnable1" bit="17" size="1" desc="IO port enable 1. Read-write. Reset: 0. 1=Enable the IO range. Port enable for IO port 480h- 4BFh." />
      <field name="IOPortEnable0" bit="16" size="1" desc="IO port enable 0. Read-write. Reset: 0. 1=Enable the IO range. Port enable for IO port 400h- 43Fh." />
      <field name="SyncTimeoutCount" bit="8" size="8" desc="Synchronization Timeout Count. Read-write. Reset: FFh. When [SyncTimeoutCounterEnable] == 1, this field specifies the number of LPC clocks that the state machine waits during LPC data synchronization before aborting the cycle." />
      <field name="SyncTimeoutCounterEnable" bit="7" size="1" desc="Synchronization Timeout Counter Enable. Read-write. Reset: 0. 0=The counter is disabled. 1=LPC sync timeout counter is enabled. This counter is used to avoid a deadlock condition if an LPC device drives sync forever. Timeout count is programmed in [SyncTimeoutCount]. Write 0 to this bit if an LPC device is extremely slow and takes more than 255 LPC clocks to complete a cycle." />
      <field name="RtcIORangePortEnable" bit="6" size="1" desc="RTC IO Range Port Enable. Read-write. Reset: 0. 1=Enable the IO range. Port enable for RTC IO range 70h-73h." />
      <field name="MemoryRangePortEnable" bit="5" size="1" desc="Memory Range Port Enable. Read-write. Reset: 0. 1=Enable the memory range. Port enable for LPC memory target range defined by FCH::ITF::LPC::PCIMemAddrforLPCTargCyc." />
      <!-- Bits 4:3 reserved. -->
      <field name="WideIO0Enable" bit="2" size="1" desc="Read-write. Reset: 0. 1=Enable the IO range. Port enable for wide generic IO port defined by FCH::ITF::LPC::PciIoBaseAddrWideGenPort[IOBaseAddress0]." />
      <field name="AlternateSuperIOConfigurationPortEnable" bit="1" size="1" desc="Alternate Super IO Configuration Port Enable. Read-write. Reset: 0. 1=Enable the IO range. Port enable for alternate Super IO configuration port, 4Eh-4Fh." />
      <field name="SuperIOConfigurationPortEnable" bit="0" size="1" desc="Super IO Configuration Port Enable. Read-write. Reset: 0. 1=Enable the IO range. Port enable for Super IO configuration port, 2Eh-2Fh." />
    </register>

    <!-- page 440 -->

    <register name="MemRng" type="pcicfg" device="LPC" offset="0x04C" size="4" desc="Memory Range. Read-write. Reset: 0000_0000h.">
      <field name="BaseAddress" bit="12" size="20" desc="Base Address. Read-write. Reset: 0_0000h. Specifies a 4K byte memory range from {Base Address, 000h} to {Base Address, FFFh}. The range is enabled by FCH::ITF::LPC::IOMemPortDecodeEn[MemPortEnable]." />
      <!-- Bits 11:0 reserved. -->
    </register>
    <register name="RomProtect0" type="pcicfg" device="LPC" offset="0x050" size="4" lockedby="SpiHostAccessRomEn" desc="ROM Protect 0. Read,Write-once. Reset: 0000_0000h. This register specifies different ROM ranges to be protected. FCH::ITF::SPI::AltSPICS[SpiProtectEn0] enables the protection ranges. The addresses are within the defined ROM range if: {RomBase, 000_0000_0000b} &lt;= address[31:0] &lt;= ({RomBase, 000_0000_0000b} + (Range &lt;&lt; (RangeUnit ? 16 : 12))). For the host, this register can only be written once after hardware reset; subsequent writes have no effect. To enable writing to this register again, one can generate an SMI through FCH or apply hardware reset.">
      <field name="RomBase" bit="12" size="20" desc="ROM Base. Read,Write-once. Reset: 0_0000h." />
      <!-- Bit 11 reserved. -->
      <field name="WriteProtect" bit="10" size="1" desc="Write Protect. Read,Write-once. Reset: 0. 1=The memory range defined by this register is write- protected and writing to the range has no effect." />
      <field name="ReadProtect" bit="9" size="1" desc="Read Protect. Read,Write-once. Reset: 0. 1=The memory range defined by this register is read- protected and reading any location in the range returns FFFF_FFFFh." />
      <field name="RangeUnit" bit="8" size="1" desc="Read,Write-once. Reset: 0. 0=4 KB. 1=64 KB." />
      <field name="Range" bit="0" size="8" desc="Read,Write-once. Reset: 00h. Description: Specifies the protected range. The unit is defined at bit[8] in the same register. NOTE: The protection is limited to 4GB boundary. Base + Range cannot cross 4GB boundary; otherwise, hardware will not behave correctly. BIOS should make sure the values are within a valid range." />
    </register>
    <register name="RomProtect1" type="pcicfg" device="LPC" offset="0x054" size="4" lockedby="SpiHostAccessRomEn" desc="ROM Protect 1. Read,Write-once. Reset: 0000_0000h. This register specifies different ROM ranges to be protected. FCH::ITF::SPI::AltSPICS[SpiProtectEn0] enables the protection ranges. The addresses are within the defined ROM range if: {RomBase, 000_0000_0000b} &lt;= address[31:0] &lt;= ({RomBase, 000_0000_0000b} + (Range &lt;&lt; (RangeUnit ? 16 : 12))). For the host, this register can only be written once after hardware reset; subsequent writes have no effect. To enable writing to this register again, one can generate an SMI through FCH or apply hardware reset.">
      <field name="RomBase" bit="12" size="20" desc="ROM Base. Read,Write-once. Reset: 0_0000h." />
      <!-- Bit 11 reserved. -->
      <field name="WriteProtect" bit="10" size="1" desc="Write Protect. Read,Write-once. Reset: 0. 1=The memory range defined by this register is write- protected and writing to the range has no effect." />
      <field name="ReadProtect" bit="9" size="1" desc="Read Protect. Read,Write-once. Reset: 0. 1=The memory range defined by this register is read- protected and reading any location in the range returns FFFF_FFFFh." />
      <field name="RangeUnit" bit="8" size="1" desc="Read,Write-once. Reset: 0. 0=4 KB. 1=64 KB." />
      <field name="Range" bit="0" size="8" desc="Read,Write-once. Reset: 00h. Description: Specifies the protected range. The unit is defined at bit[8] in the same register. NOTE: The protection is limited to 4GB boundary. Base + Range cannot cross 4GB boundary; otherwise, hardware will not behave correctly. BIOS should make sure the values are within a valid range." />
    </register>
    <register name="RomProtect2" type="pcicfg" device="LPC" offset="0x058" size="4" lockedby="SpiHostAccessRomEn" desc="ROM Protect 2. Read,Write-once. Reset: 0000_0000h. This register specifies different ROM ranges to be protected. FCH::ITF::SPI::AltSPICS[SpiProtectEn0] enables the protection ranges. The addresses are within the defined ROM range if: {RomBase, 000_0000_0000b} &lt;= address[31:0] &lt;= ({RomBase, 000_0000_0000b} + (Range &lt;&lt; (RangeUnit ? 16 : 12))). For the host, this register can only be written once after hardware reset; subsequent writes have no effect. To enable writing to this register again, one can generate an SMI through FCH or apply hardware reset.">
      <field name="RomBase" bit="12" size="20" desc="ROM Base. Read,Write-once. Reset: 0_0000h." />
      <!-- Bit 11 reserved. -->
      <field name="WriteProtect" bit="10" size="1" desc="Write Protect. Read,Write-once. Reset: 0. 1=The memory range defined by this register is write- protected and writing to the range has no effect." />
      <field name="ReadProtect" bit="9" size="1" desc="Read Protect. Read,Write-once. Reset: 0. 1=The memory range defined by this register is read- protected and reading any location in the range returns FFFF_FFFFh." />
      <field name="RangeUnit" bit="8" size="1" desc="Read,Write-once. Reset: 0. 0=4 KB. 1=64 KB." />
      <field name="Range" bit="0" size="8" desc="Read,Write-once. Reset: 00h. Description: Specifies the protected range. The unit is defined at bit[8] in the same register. NOTE: The protection is limited to 4GB boundary. Base + Range cannot cross 4GB boundary; otherwise, hardware will not behave correctly. BIOS should make sure the values are within a valid range." />
    </register>
    <register name="RomProtect3" type="pcicfg" device="LPC" offset="0x05C" size="4" lockedby="SpiHostAccessRomEn" desc="ROM Protect 3. Read,Write-once. Reset: 0000_0000h. This register specifies different ROM ranges to be protected. FCH::ITF::SPI::AltSPICS[SpiProtectEn0] enables the protection ranges. The addresses are within the defined ROM range if: {RomBase, 000_0000_0000b} &lt;= address[31:0] &lt;= ({RomBase, 000_0000_0000b} + (Range &lt;&lt; (RangeUnit ? 16 : 12))). For the host, this register can only be written once after hardware reset; subsequent writes have no effect. To enable writing to this register again, one can generate an SMI through FCH or apply hardware reset.">
      <field name="RomBase" bit="12" size="20" desc="ROM Base. Read,Write-once. Reset: 0_0000h." />
      <!-- Bit 11 reserved. -->
      <field name="WriteProtect" bit="10" size="1" desc="Write Protect. Read,Write-once. Reset: 0. 1=The memory range defined by this register is write- protected and writing to the range has no effect." />
      <field name="ReadProtect" bit="9" size="1" desc="Read Protect. Read,Write-once. Reset: 0. 1=The memory range defined by this register is read- protected and reading any location in the range returns FFFF_FFFFh." />
      <field name="RangeUnit" bit="8" size="1" desc="Read,Write-once. Reset: 0. 0=4 KB. 1=64 KB." />
      <field name="Range" bit="0" size="8" desc="Read,Write-once. Reset: 00h. Description: Specifies the protected range. The unit is defined at bit[8] in the same register. NOTE: The protection is limited to 4GB boundary. Base + Range cannot cross 4GB boundary; otherwise, hardware will not behave correctly. BIOS should make sure the values are within a valid range." />
    </register>
    <register name="PCIMemAddrforLPCTargCyc" type="pcicfg" device="LPC" offset="0x060" size="4" desc="PCI Memory Address for LPC Target Cycles. Read-write. Reset: 0000_0000h. This register contains the upper 16 bits of the start and end address of the LPC memory target range. The lower 16 bits of MemoryStartAddress are 0000h. The lower 16 bits of MemoryEndAddress are FFFFh. This range can be enabled or disabled using FCH::ITF::LPC::IOMemPortDecodeEn[MemoryRangePortEnable].">
      <field name="MemoryEndAddress" bit="16" size="16" desc="Memory End Address. Read-write. Reset: 0000h. Specifies the upper 16 bits of the end address of the LPC target memory range." />
      <field name="MemoryStartAddress" bit="0" size="16" desc="Memory Start Address. Read-write. Reset: 0000h. Specifies the upper 16 bits of the start address of the LPC target memory range." />
    </register>

    <!-- page 441 -->

    <register name="PciIoBaseAddrWideGenPort" type="pcicfg" device="LPC" offset="0x064" size="4" desc="PCI IO base Address for Wide Generic Port. Read-write. Reset: 0000_0000h.">
      <field name="IOBaseAddress1" bit="16" size="16" desc="IO Base Address 1. Read-write. Reset: 0000h. 16-bit PCI IO base address for wide generic IO port range. This function is enabled by FCH::ITF::LPC::IOMemPortDecodeEn[WideIO1Enable]. If FCH::ITF::LPC::AlternativeWideIORngEn[AlternativeWideIO1RangeEnable] == 1, the range is 16 bytes; else the range is 512 bytes." />
      <field name="IOBaseAddress0" bit="0" size="16" desc="IO Base Address 0. Read-write. Reset: 0000h. 16-bit PCI IO base address for wide generic IO port range. This function is enabled by FCH::ITF::LPC::IOMemPortDecodeEn[WideIO0Enable]. If FCH::ITF::LPC::AlternativeWideIORngEn[AlternativeWideIO0RangeEnable] == 1, the range is 16 bytes; else the range is 512 bytes." />
    </register>
    <register name="ROMAddrRng1" type="pcicfg" device="LPC" offset="0x068" size="4" desc="ROM Address Range 1. Read-write. Reset: 000F_0008h. This register contains the upper 16 bits of the start and end address of the ROM address range 1. The lower 16 bits of RomStartAddress1 are 0000h. The lower 16 bits of the RomEndAddress1 are FFFFh. This register is used for both LPC and SPI flash.">
      <field name="RomEndAddress1" bit="16" size="16" desc="ROM End Address 1. Read-write. Reset: 000Fh. Specifies the upper 16 bits of the end address of the ROM memory address range 1. If the strap is disabled, the reset value is 0h." />
      <field name="RomStartAddress1" bit="0" size="16" desc="ROM Start Address 1. Read-write. Reset: 0008h. Specifies the upper 16 bits of the start address of the ROM memory address range 1. If the strap is disabled, the reset value is 0h. Default is set to 512K below 1M." />
    </register>
    <register name="ROMAddrRng2" type="pcicfg" device="LPC" offset="0x06C" size="4" desc="ROM Address Range 2. Read-write. Reset: FFFF_FF00h. This register contains the upper 16 bits of the start and end address of the ROM address range 2. The lower 16 bits of RomStartAddress2 are 0000h. The lower 16 bits of RomEndAddress2 are FFFFh. This register is used for both LPC and SPI flash.">
      <field name="RomEndAddress2" bit="16" size="16" desc="ROM End Address 2. Read-write. Reset: FFFFh. Specifies the upper 16 bits of the end address of the ROM memory address range 2. If the strap is disabled, the reset value is 0h." />
      <field name="RomStartAddress2" bit="0" size="16" desc="ROM Start Address 2. Read-write. Reset: FF00h. Specifies the upper 16 bits of the start address of the ROM memory address range 2. If the strap is disabled, the reset value is 0h." />
    </register>
    <register name="AlternativeWideIORngEn" type="pcicfg" device="LPC" offset="0x074" size="4" desc="Alternative Wide IO Range Enable. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:4 reserved. -->
      <field name="AlternativeWideIO2RangeEnable" bit="3" size="1" desc="Alternative Wide IO 2 Range Enable. Read-write. Reset: 0. This bit is similar to bit[AlternativeWideIO0RangeEnable], but it applies to the IO range defined by FCH::ITF::LPC::WideIO2[IOBaseAddress2]. See bit[AlternativeWideIO0RangeEnable] for a detailed description." />
      <field name="AlternativeWideIO1RangeEnable" bit="2" size="1" desc="Alternative Wide IO 1 Range Enable. Read-write. Reset: 0. This bit is similar to bit[AlternativeWideIO0RangeEnable], but it applies to the IO range defined by FCH::ITF::LPC::PciIoBaseAddrWideGenPort[IOBaseAddress1]. See bit[AlternativeWideIO0RangeEnable] for a detailed description." />
      <!-- Bit 1 reserved. -->
      <field name="AlternativeWideIO0RangeEnable" bit="0" size="1" desc="Alternative Wide IO 0 Range Enable. Read-write. Reset: 0. 0=Wide IO range defined by FCH::ITF::LPC::PciIoBaseAddrWideGenPort[IOBaseAddress0] is 512 bytes. 1=The range is 16 bytes. To use this feature, address in FCH::ITF::LPC::PciIoBaseAddrWideGenPort[IOBaseAddress0] must be aligned to 16 bytes, i.e., bits[3:0] must be 0. If the address is not aligned to 16 bytes, the IO range is from address[15:0] to {address[15:4], 0xF}." />
    </register>

    <!-- page 442 -->

    <register name="MiscCtlBits" type="pcicfg" device="LPC" offset="0x078" size="4" desc="Miscellaneous Control Bits. Read-write. Reset: 0000_0091h.">
      <!-- Bits 31:11 reserved. -->
      <field name="LDRQ0_PD_EN" bit="10" size="1" desc="Read-write. Reset: 0. 0=Disable the pull-down of LDRQ0 pad. 1=Enable the pull-down of LDRQ0 pad. LDRQ0_PD_EN." />
      <field name="LDRQ0_PU_EN" bit="9" size="1" desc="Read-write. Reset: 0. 0=Disable the pull-up of LDRQ0 pad. 1=Enable the pull-up of LDRQ0 pad. LDRQ0_PU_EN." />
      <!-- Bit 8 reserved. -->
      <field name="AllowHostInDma" bit="7" size="1" desc="Read-write. Reset: 1. 0=DMA hold LPC even ACPI has not given GNT to LPC during DMA transfer. 1=Allow Host to access LPC if ACPI has not given GNT to LPC during DMA transfer." />
      <field name="GateWrongRx" bit="6" size="1" desc="Read-write. Reset: 0. 1=Allow AltRxByteCount to be 0." />
      <field name="GateSpiAccessDis" bit="5" size="1" desc="Read-write. Reset: 0. 1=Pass ROM access to SPI even if it is strapped as LPC." />
      <field name="SMMWriteRomEn" bit="4" size="1" desc="Read-write. Reset: 1. 1=Enable ROM access in SMM mode." />
      <!-- Bit 3 reserved. -->
      <field name="LDRQ0" bit="2" size="1" desc="Read-write. Reset: 0. 1=Enable LDRQ0# on LPC bus. Enable LDRQ0." />
      <!-- Bit 1 reserved. -->
      <field name="NoHog" bit="0" size="1" desc="No Hog. Read-write. Reset: 1. 0=LPC may hold the internal bus during a DMA transfer. 1=The internal bus is not locked by LPC bridge during a slave access. LPC DMA fetch." />
    </register>
    <register name="TPM" type="pcicfg" device="LPC" offset="0x07C" size="4" desc="TPM.">
      <!-- Bits 31:14 reserved. -->
      <field name="TpmBufferEn" bit="13" size="1" desc="Read-write. Reset: 0. 0=Disable TPM buffer. 1=Enable TPM buffer." />
      <field name="TpmPfetchEn" bit="12" size="1" desc="Read-write. Reset: 0. 0=Disable TPM burst Read. 1=Enable TPM burst Read." />
      <field name="LpcClk1IsGpio" bit="11" size="1" desc="Read-write. Reset: 1. 0=Treat LpcClk1 as LpcClk1. 1=Treat LpcClk1 as GPIO." />
      <field name="GpioLpcClk1Out" bit="10" size="1" desc="Read-write. Reset: 0. Control GpioLpcClk1 output value." />
      <field name="GpioLpcClk1OeB" bit="9" size="1" desc="Read-write. Reset: 1. 0=Enable GpioLpcClk1 output. 1=Disable GpioLpcClk1 output." />
      <field name="GpioLpcClk1" bit="8" size="1" desc="Read-only. Reset: X. Status of LpcClk1 port." />
      <field name="WiderTpmEn" bit="7" size="1" desc="Read-write. Reset: 0. 1=Force logic to decode FED4_XXXXh as TPM cycles instead of FED4_0XXXh, FED4_1XXXh, FED4_2XXXh, FED4_3XXXh, and FED4_4XXXh." />
      <!-- Bits 6:3 reserved. -->
      <field name="TpmLegacy" bit="2" size="1" desc="Read-write. Reset: 0. 1=Enable decoding of legacy TPM addresses: IO addresses 7Eh/7Fh and EEh/EFh." />
      <!-- Bit 1 reserved. -->
      <field name="Tpm12En" bit="0" size="1" desc="Read-write. Reset: 1. 1=Enable decoding of TPM cycles defined in TPM1. Enables decoding of TPM cycles defined in TPM 1.2 spec. Note that this bit and [TpmLegacy] are independent bits; they respectively turn on decoding of different TPM addresses." />
    </register>

    <!-- page 443 -->

    <register name="WideIO2" type="pcicfg" device="LPC" offset="0x090" size="4" desc="Wide IO 2. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="IOBaseAddress2" bit="0" size="16" desc="IO Base Address 2. Read-write. Reset: 0000h. 16-bit PCI IO base address for wide generic IO port range. This function is enabled by FCH::ITF::LPC::IOMemPortDecodeEn[WideIO2Enable]. If FCH::ITF::LPC::AlternativeWideIORngEn[AlternativeWideIO2RangeEnable] == 1, the range is 16 bytes; else, the range is 512 bytes." />
    </register>
    <register name="SPIBaseAddr" type="pcicfg" device="LPC" offset="0x0A0" size="4" desc="SPI Base_Addr. Read-write. Reset: FEC1_0002h.">
      <field name="Spi_eSpi_BaseAddr" bit="8" size="24" desc="Read-write. Reset: FE_C100h." />
      <!-- Bits 7:5 reserved. -->
      <field name="PspSpiMmioSel" bit="4" size="1" desc="Read-write. Reset: 0. 0=SPI MMIO register for Host. 1=SPI MMIO register for PSP. PSP SPI MMIO select." />
      <field name="RouteTpm2Spi" bit="3" size="1" desc="Read-write. Reset: 0. 1=TPM cycles are routed to SPI bus with TPM_SPI_CS# asserted. Route TPM to SPI." />
      <field name="AbortEnable" bit="2" size="1" desc="Read-write. Reset: 0. LPC Abort enable." />
      <field name="SpiRomEnable" bit="1" size="1" desc="Read-write. Reset: 1. 0=SPI ROM is disabled. 1=SPI ROM is enabled if chip is strapped to SPI ROM." />
      <field name="AltSpiCSEnable" bit="0" size="1" desc="Read-write. Reset: 0. Alternative SPI CS enable." />
    </register>
    <register name="RomDmaSrcAddr" type="pcicfg" device="LPC" offset="0x0B0" size="4" desc="RomDmaSrcAddr. Read-write. Reset: 0000_0000h.">
      <field name="DmaStartAddr" bit="6" size="26" desc="Read-write. Reset: 000_0000h. Specifies the starting DMA address to read from the ROM. NOTE: This is not the same as the legacy DMA function. This is meant to be used by BIOS to fetch the BOOT code quicker." />
      <!-- Bits 5:0 reserved. -->
    </register>
    <register name="RomDmaDstAddr" type="pcicfg" device="LPC" offset="0x0B4" size="4" desc="RomDmaDstAddr. Read-write. Reset: 0000_0000h.">
      <field name="DmaDstAddr" bit="6" size="26" desc="Read-write. Reset: 000_0000h. Specifies the target DMA address to be written in the system memory. NOTE: This is not the same as the legacy DMA function. This is meant to be used by BIOS to fetch the BOOT code quicker." />
      <!-- Bits 5:0 reserved. -->
    </register>
    <register name="RomDmaCtlHostCtl" type="pcicfg" device="LPC" offset="0x0B8" size="4" desc="RomDmaControl/HostControl. Reset: 0300_0004h.">
      <!-- Bits 31:28 reserved. -->
      <field name="AutoSizeDone_pmio" bit="27" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. 1=Enable hand-instance of the pulse generator." />
      <!-- Bit 26 reserved. -->
      <field name="LpcBusPullUpEn" bit="25" size="1" desc="Read-write. Reset: 1. Init: BIOS,1. 0=Disable LAD[3:0] internal pull-up. 1=Enable LAD internal Pull-up. LPC Bus Pull-up enable." />
      <field name="PrefetchEnSpiFromHost" bit="24" size="1" desc="Read-write. Reset: 1. Init: BIOS,1. 1=SPI controller prefetches from the flash on   behalf of the host. Host enabled SPI prefetch." />
      <!-- Bits 23:16 reserved. -->
      <field name="DWCount" bit="6" size="10" desc="Read-write. Reset: 000h. This register specifies the number (DWCount + 1) of cache lines (64 bytes) to be fetched from the ROM when the DMA is used." />
      <!-- Bits 5:3 reserved. -->
      <field name="RomcpSupportAbRetry" bit="2" size="1" desc="Read-write. Reset: 1. 0=ROM copy does not support AB retry. 1=ROM copy supports AB retry." />
      <field name="DmaErrorStatus" bit="1" size="1" desc="Read-only. Reset: 0. 0=Previous transfer has completed successfully. 1=Previous transfer has error. DmaErrorStatus." />
      <field name="DmaStart" bit="0" size="1" desc="Read,Write-1-only. Reset: 0. 1=LPC bridge starts the DMA function, with starting addresses defined by FCH::ITF::LPC::RomDmaSrcAddr andFCH::ITF::LPC::RomDmaDstAddr. This bit returns the status of the DMA transfer. 0=DMA transfer is complete. A return value of 1 means the DMA transfer is running." />
    </register>

    <!-- page 444 -->

    <register name="ClkCntrl" type="pcicfg" device="LPC" offset="0x0D0" size="4" desc="ClkCntrl. Reset: 08FF_E086h.">
      <field name="ClkRunEn" bit="31" size="1" desc="Read-write. Reset: 0. 0=ClkRun function is disabled and LPCCLK0/LPCCLK1 can be running all the time. 1=ClkRun function is enabled and LPCCLK0/LPCCLK1 can be stopped. Should be set to 1 for mobile platforms to enhance energy savings." />
      <field name="ClkRunDlyCounter" bit="24" size="7" desc="Read-write. Reset: 08h. Specifies the amount of clocks to be extended before stopping the LPCCLK0/LPCCLK1." />
      <!-- Bit 23 reserved. -->
      <field name="Lclk1ClkrunOvrid" bit="22" size="1" desc="Read-write. Reset: 1. 0=LPCCLK1 is forced to run. 1=LPCCLK1 functions with CLKRUN protocol." />
      <field name="Lclk0ClkrunOvrid" bit="21" size="1" desc="Read-write. Reset: 1. 0=LPCCLK0 is forced to run. 1=LPCCLK0 is functioning with CLKRUN protocol." />
      <!-- Bits 20:15 reserved. -->
      <field name="Lclk1En" bit="14" size="1" desc="Read-write. Reset: 1. 0=LPCCLK1 is forced to stop. 1=LPCCLK1 is functioning with CLKRUN protocol." />
      <field name="Lclk0En" bit="13" size="1" desc="Read-write. Reset: 1. 0=LPCCLK0 is forced to stop. 1=LPCCLK0 is functioning with CLKRUN protocol." />
      <!-- Bits 12:8 reserved. -->
      <field name="LpcClkRunEn" bit="7" size="1" desc="Read-write. Reset: 1. 0=Disable. 1=Enable. LPC Clock run enable." />
      <!-- Bits 6:3 reserved. -->
      <field name="SpiOnClkRun" bit="2" size="1" desc="Read-write. Reset: 1. 0=SPI request can assert ClkRun#. 1=SPI request doesn't assert ClkRun#." />
      <field name="ClkGateCntrl" bit="0" size="2" desc="Read-write. Reset: 2h. These two bits control whether the LPC module allows clock gating to the internal core clock." />
    </register>
    <register name="ClkRunOption" type="pcicfg" device="LPC" offset="0x0D4" size="4" desc="ClkRunOption. Read-write. Reset: 0000_0040h.">
      <!-- Bits 31:8 reserved. -->
      <field name="MinAssertion" bit="4" size="4" desc="Read-write. Reset: 4h. Specifies the minimum time of ClkRun# assertion. In units of 30 ns." />
      <!-- Bits 3:1 reserved. -->
      <field name="ExtendClkRunB" bit="0" size="1" desc="Read-write. Reset: 0. 0=Delay 30 ns before capturing ClkRun# input. 1=Delay 60 ns before capturing ClkRun# input." />
    </register>

    <!-- 9.2.9.3.2 FCH::ITF::SPI Registers -->

    <!-- page 446 -->

    <register name="SPICntrl0" type="memory" device="SPI" offset="0x000" size="4" desc="SPI_Cntrl0. Reset: 0FC0_0000h.">
      <field name="SpiBusy" bit="31" size="1" desc="Read-only. Reset: 0. 0=SPI bus is idle. 1=SPI bus is busy." />
      <field name="SpiReadMode[2:1]" bit="29" size="2" desc="Read-write. Reset: 0h. Description: See Table 78 [SpiReadMode[2:0]]. NOTE: SPI modes supported are listed below," />
      <field name="SpiClkGate" bit="28" size="1" desc="Read-write. Reset: 0. 1=Skip the 8th SPI clock at the end data when doing read." />
      <field name="SpiBridgeDisable" bit="27" size="1" desc="Read-write. Reset: 1. Setting this bit disables the SPI bridge mode (SB acts as a SPI-LPC bridge to the MAC)." />
      <field name="ArbWaitCount" bit="24" size="3" desc="Read-write. Reset: 7h. Specifies the amount of wait time the SPI controller asserts HOLD# before it should access the SPI ROM, under ROM sharing mode with the MAC. This time is to allow the MAC to sample HOLD#." />
      <field name="SpiHostAccessRomEn" bit="23" size="1" desc="Read,Write-0-only. Reset: 1. 0=MAC cannot access BIOS ROM space (upper 512 KB). 1=MAC can access BIOS ROM space. This is a clear-once protection bit. Once set, some SPI registers can't be written and discards a SPI request if it is an illegal request." />
      <field name="SpiAccessRomEn" bit="22" size="1" desc="Read,Write-0-only. Reset: 1. 0=Software cannot access MAC's portion of the ROM space   (lower 512 KB). 1=Software can access MAC's portion of the ROM space. This is a clear-once protection bit. Once set, some SPI registers can't be written and discards a SPI request if it is an illegal request." />
      <field name="IllegalAccess" bit="21" size="1" desc="Read-only. Reset: 0. 0=Legal index mode access. 1=Illegal index mode access." />
      <!-- Bits 20:19 reserved. -->
      <field name="SpiReadMode[0]" bit="18" size="1" desc="Read-write. Reset: 0. Bit[0] of SpiReadMode. See the definition of SpiReadMode[2:1] in this register. SpiReadMode = {SpiReadMode[2:1],SpiReadMode[0]}." />
      <!-- Bits 17:0 reserved. -->
    </register>

    <!-- page 447 -->

    <register name="SPIRestrictedCmd" type="memory" device="SPI" offset="0x004" size="4" lockedby="SpiHostAccessRomEn" desc="SPI_RestrictedCmd. Reset: 0000_0000h.">
      <field name="RestrictedCmd3" bit="24" size="8" desc="Reset: 00h. Same as RestrictedCmd0. AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
      <field name="RestrictedCmd2" bit="16" size="8" desc="Reset: 00h. Same as RestrictedCmd0. AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
      <field name="RestrictedCmd1" bit="8" size="8" desc="Reset: 00h. Same as RestrictedCmd0. AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
      <field name="RestrictedCmd0" bit="0" size="8" desc="Reset: 00h. This defines a restricted command issued by the MAC which is checked by the SB. If the opcode issued by the MAC matches with this register and the address space is in the BIOS space, this controller simply ignores the command for the case of bridge mode. For peer mode, the SPI controller stalls the entire interface as an attempt to stop that transaction. Note when either SpiAccessRomEn and/or SpiHostAccessRomEn bit are cleared, these registers become read-only and cannot be changed any more. AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
    </register>
    <register name="SPIRestrictedCmd2" type="memory" device="SPI" offset="0x008" size="4" lockedby="SpiHostAccessRomEn" desc="SPI_RestrictedCmd2. Reset: 0000_0000h.">
      <field name="RestrictedCmdWoAddr2" bit="24" size="8" desc="Reset: 00h. Same as [RestrictedCmdWoAddr0]. AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
      <field name="RestrictedCmdWoAddr1" bit="16" size="8" desc="Reset: 00h. Same as [RestrictedCmdWoAddr0]. AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
      <field name="RestrictedCmdWoAddr0" bit="8" size="8" desc="Reset: 00h. Same as FCH::ITF::SPI::SPIRestrictedCmd[RestrictedCmd0] except that this field defines a restricted command that does not have an address. AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
      <field name="RestrictedCmd4" bit="0" size="8" desc="Reset: 00h. Same as FCH::ITF::SPI::SPIRestrictedCmd[RestrictedCmd0]. AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
    </register>

    <!-- page 448 -->

    <register name="SPICntrl1" type="memory" device="SPI" offset="0x00C" size="4" desc="SPI_Cntrl1. Reset: 0222_0000h.">
      <field name="ByteCommand" bit="24" size="8" desc="Reset: 02h. Specifies the command byte for the opcode transaction.  AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
      <field name="SpiDoLockOnNxtCmd" bit="23" size="1" desc="Read-write. Reset: 0. SPI does a lock on the next command." />
      <field name="SpiDoUnLockOnNxtCmd" bit="22" size="1" desc="Read-write. Reset: 0. SPI does an unlock on the next command." />
      <field name="WaitCount" bit="16" size="6" desc="Read-write. Reset: 22h. Specifies the time, where units = 15 ns * (WaitCount + 1)." />
      <!-- Bits 15:12 reserved. -->
      <field name="TrackMacLockEn" bit="11" size="1" desc="Read-write. Reset: 0. When set, the controller will lock the SPI for the MAC when it has detected a command (from the MAC) matching the value defined in offset 10h or 11h. Conversely, it will unlock the bus when it has detected a command (from the MAC) matching the value defined in offset 12h or 13h." />
      <!-- Bits 10:8 reserved. -->
      <field name="SpiParameters" bit="0" size="8" desc="Read-write. Reset: 00h. This is the TX/RX FIFO port which can take up to 8 bytes. To send data to SPI ROM, software Writes data into this port. To retrieve data that are received from the SPI ROM, software Reads from this port." />
    </register>
    <register name="SPICmdVal0" type="memory" device="SPI" offset="0x010" size="4" desc="SPI_CmdValue0. Reset: 0404_2006h.">
      <field name="MacUnlockCmd1" bit="24" size="8" desc="Reset: 04h. Same as MacUnlockCmd0. AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
      <field name="MacUnlockCmd0" bit="16" size="8" desc="Reset: 04h. This field is used to compare against the opcode sent out by the MAC. If FCH::ITF::SPI::SPICntrl1[TrackMacLockEn] == 1, the controller unlocks the SPI bus for the MAC. In other words, access by the CPU is allowed again. AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
      <field name="MacLockCmd1" bit="8" size="8" desc="Reset: 20h. Same as MacLockCmd0. AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
      <field name="MacLockCmd0" bit="0" size="8" desc="Reset: 06h. This is used to compare against the opcode sent out by the MAC. If FCH::ITF::SPI::SPICntrl1[TrackMacLockEn] == 1, the controller locks the SPI bus for the MAC. In other words, the MAC has the exclusive access to the ROM and access by the CPU is delayed until this is unlocked. This allows the MAC to do a certain sequence of operations without interruption. AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
    </register>
    <register name="SPICmdVal1" type="memory" device="SPI" offset="0x014" size="4" desc="SPI_CmdValue1. Reset: 059F_0406h.">
      <field name="RDSR" bit="24" size="8" desc="Reset: 05h. This is used to compare against the opcode sent out by the MAC. This is a predefined value to decode for the RDSR (Read Status Register) command from the MAC. AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
      <field name="RDID" bit="16" size="8" desc="Reset: 9Fh. This is used to compare against the opcode sent out by the MAC. This is a predefined value to decode for the RDID (Read ID) command from the MAC.   AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
      <field name="WRDI" bit="8" size="8" desc="Reset: 04h. This is used to compare against the opcode sent out by the MAC. This is a predefined value to decode for the WRDI (Write Disable) command from the MAC. AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
      <field name="WREN" bit="0" size="8" desc="Reset: 06h. This is used to compare against the opcode sent out by the MAC. This is a predefined value to decode for the WREN (Write Enable) command from the MAC. AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
    </register>

    <!-- page 449 -->

    <register name="SPICmdVal2" type="memory" device="SPI" offset="0x018" size="4" desc="SPI_CmdValue2. Reset: 020A_0B03h.">
      <field name="BYTEWR" bit="24" size="8" desc="Reset: 02h. This is used to compare against the opcode sent out by the MAC. This is a predefined value to decode for the BYTEWR (Byte Write) command from the MAC. AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
      <field name="PAGEWR" bit="16" size="8" desc="Reset: 0Ah. Page Write command. AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
      <field name="FRead" bit="8" size="8" desc="Reset: 0Bh. This is used to compare against the opcode sent out by the MAC. This is a predefined value to decode for the FRead (Fast Read) command from the MAC. AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
      <field name="Read" bit="0" size="8" desc="Reset: 03h. This is used to compare against the opcode sent out by the MAC. This is a predefined value to decode for the Read (Read Byte) command from the MAC. AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
    </register>
    <register name="Reserved" type="memory" device="SPI" offset="0x01C" size="1" desc="Reserved. Read-write. Reset: FFh.">
      <!-- Bits 7:0 reserved. -->
    </register>
    <register name="AltSPICS" type="memory" device="SPI" offset="0x01D" size="1" desc="Alt_SPI_CS. Reset: 00h." lockedby="SpiProtectLock">
      <field name="SpiCsDlySel" bit="7" size="1" desc="Read-write. Reset: 0. 0=75 ns minimum SPI_CS# de-assertion time. 1=125 ns minimum SPI_CS# de-assertion time." />
      <!-- Bit 6 reserved. -->
      <field name="SpiProtectLock" bit="5" size="1" desc="Read-write. Reset: 0. 1=Bits[3,4,5] are no longer writable." />
      <field name="SpiProtectEn1" bit="4" size="1" desc="Reset: 0. 1=Enable SPI protection to prevent host from accessing IMC and USB3 space. AccessType: FCH::ITF::SPI::AltSPICS[SpiProtectLock] ? Read-only : Read-write." />
      <field name="SpiProtectEn0" bit="3" size="1" desc="Reset: 0. 1=Enable SPI Read/Write protection ranges specified by FCH::ITF::LPC::RomProtect. AccessType: FCH::ITF::SPI::AltSPICS[SpiProtectLock] ? Read-only : Read-write." />
      <field name="WriteBufferEn" bit="2" size="1" desc="Read-write. Reset: 0. 1=SPI bridge can take burst write from the host and transfer it to the SPI flash. SPI write performance enhancement." />
      <field name="AltSpiCsEn" bit="0" size="2" desc="Reset: 0h. These two bits select the alternate SPI_CS# for BIOS_ROM. AccessType: (FCH::ITF::SPI::SPICntrl0[SpiAccessRomEn] &amp;&amp; FCH::ITF::SPI::SPICntrl0[SpiHostAccessRomEn]) ? Read-write : Read-only." />
    </register>

    <!-- page 450 -->

    <register name="SPI100En" type="memory" device="SPI" offset="0x020" size="1" desc="SPI100 Enable. Read-write. Reset: 00h.">
      <!-- Bits 7:1 reserved. -->
      <field name="UseSpi100" bit="0" size="1" desc="Read-write. Reset: 0. 0=Does not support 100 MHz speed. 1=Supports 100 MHz speed. The actual Read speed also depends on FCH::ITF::SPI::SPI100SpeedCfg." />
    </register>
    <register name="SPI100SpeedCfg" type="memory" device="SPI" offset="0x022" size="2" desc="SPI100 Speed Config. Read-write. Reset: 3133h.">
      <field name="NormSpeedNew[3:0]" bit="12" size="4" desc="Read-write. Reset: 3h. Configures the SPI bus normal speed in SPI100 engine. If the command is not using TpmSpeed and FastSpeed, it uses NormSpeed." />
      <field name="FastSpeedNew[3:0]" bit="8" size="4" desc="Read-write. Reset: 1h." />
      <field name="AltSpeedNew[3:0]" bit="4" size="4" desc="Read-write. Reset: 3h. Configures the SPI bus speed for the AltOpCode mode in SPI100 engine.  " />
      <field name="TpmSpeedNew[3:0]" bit="0" size="4" desc="Read-write. Reset: 3h. Configures the SPI bus speed for TPM Read and Write to the SPI100 engine." />
    </register>

    <!-- page 451 -->

    <register name="SPI100HostPrefetchCfg" type="memory" device="SPI" offset="0x02C" size="2" desc="SPI100 Host Prefetch Config. Read-write. Reset: D4C0h. • We have reached the maximum prefetch size defined in HostPrefetchSize and HostPrefOn64ByteBoundary register. • When the host requests an address that is not already prefetched and not going to be prefetched shortly, we stop current prefetch action and re-start a new prefetch with the first address being the current address requested by the Host. • When there is a ROM-Write or AltOpCode request from host, the on-going prefetch is terminated, and the prefetch buffer is flushed. • When there is a TPM-Write, TPM-Read, USB-Read or EC-Read request, the on-going prefetch is halted. The contents of prefetch buffer is preserved so that the host can access them later. • &quot;Will Hit&quot; algorithm. The current requested address is fetched &quot;shortly&quot; if this equation is true: Current Requested Address &lt;= (First Prefetched Address + HostPrefetchSize). • &quot;Hit Soon&quot; algorithm. The current requested address is fetched &quot;shortly&quot; if this equation is true: Current Requested Address &lt;= (Last Prefetched Address + HostHitRange).">
      <field name="Rd4dw_en_host" bit="15" size="1" desc="Read-write. Reset: 1. 1=Enable Host burst to 4 DWORD. Rd4dw_en_host." />
      <field name="HostBurstEn" bit="14" size="1" desc="Read-write. Reset: 1. 1=Enable Host buffer burst data out. Host burst enable." />
      <field name="HostHitSoonEn" bit="13" size="1" desc="Read-write. Reset: 0. 1=Enable the &quot;Hit Soon&quot; algorithm." />
      <field name="HostWillHitEn" bit="12" size="1" desc="Read-write. Reset: 1. 1=Enable the &quot;Will Hit&quot; algorithm. When &quot;Will Hit&quot; algorithm is enabled, &quot;Hit Soon&quot; algorithm is automatically disabled regardless of the setting in HostHitSoonEn." />
      <field name="HostHitRange[3:0]" bit="8" size="4" desc="Read-write. Reset: 4h. Configures the &quot;Hit Range&quot; in the &quot;Hit Soon&quot; algorithm." />
      <field name="HostPrefOn64ByteBoundary" bit="7" size="1" desc="Read-write. Reset: 1. 0=Always fetch 64 bytes no matter whether the first Host requested address lies on the 64-byte boundary or not. 1=Fetch 64 bytes if the first Host requested address lies on the 64-byte boundary, otherwise, get the 4 bytes the Host is currently requesting." />
      <field name="HostPrefetchSize[6:0]" bit="0" size="7" desc="Read-write. Reset: 40h. Configures the maximum prefetch byte count for the host prefetch buffer. The value has to be less than or equal to 64." />
    </register>

    <!-- page 452 -->

    <register name="DDRCmdCode" type="memory" device="SPI" offset="0x040" size="1" desc="DDRCmdCode. Read-write. Reset: 3Bh.">
      <field name="DDR_CMD" bit="0" size="8" desc="Read-write. Reset: 3Bh. Double Data Rate command." />
    </register>
    <register name="QDRCmdCode" type="memory" device="SPI" offset="0x041" size="1" desc="QDRCmdCode. Read-write. Reset: 6Bh.">
      <field name="QDR_CMD" bit="0" size="8" desc="Read-write. Reset: 6Bh. Quad Data Rate command." />
    </register>
    <register name="DPRCmdCode" type="memory" device="SPI" offset="0x042" size="1" desc="DPRCmdCode. Read-write. Reset: BBh.">
      <field name="DPR_CMD" bit="0" size="8" desc="Read-write. Reset: BBh. DPR command." />
    </register>
    <register name="QPRCmdCode" type="memory" device="SPI" offset="0x043" size="1" desc="QPRCmdCode. Read-write. Reset: EBh.">
      <field name="QPR_CMD" bit="0" size="8" desc="Read-write. Reset: EBh. QPR command." />
    </register>
    <register name="ModeByte" type="memory" device="SPI" offset="0x044" size="1" desc="ModeByte. Read-write. Reset: 00h.">
      <field name="ModeByte" bit="0" size="8" desc="Read-write. Reset: 00h. SPI Read Mode." />
    </register>
    <register name="CmdCode" type="memory" device="SPI" offset="0x045" size="1" desc="CmdCode. Read-write. Reset: 00h.">
      <field name="SpiOpCode" bit="0" size="8" desc="Read-write. Reset: 00h. Specifies the SPI opcode in alternate program method." />
    </register>
    <register name="CmdTrig" type="memory" device="SPI" offset="0x047" size="1" desc="CmdTrigger. Write-1-only. Reset: 00h.">
      <field name="Execute" bit="7" size="1" desc="Write-1-only. Reset: 0. Trigger to execute command." />
      <!-- Bits 6:0 reserved. -->
    </register>
    <register name="TxByteCnt" type="memory" device="SPI" offset="0x048" size="1" desc="TxByteCount. Read-write. Reset: 00h.">
      <field name="TxByteCount" bit="0" size="8" desc="Read-write. Reset: 00h. Number of bytes to be sent to SPI ROM." />
    </register>

    <!-- page 453 -->

    <register name="RxByteCnt" type="memory" device="SPI" offset="0x04B" size="1" desc="RxByteCount. Read-write. Reset: 00h.">
      <field name="RxByteCount" bit="0" size="8" desc="Read-write. Reset: 00h. Number of bytes to be received from the SPI ROM." />
    </register>
    <register name="SpiStat" type="memory" device="SPI" offset="0x04C" size="4" desc="SpiStatus. Read-only. Reset: 0000_0000h.">
      <field name="SpiBusy" bit="31" size="1" desc="Read-only. Reset: 0. 0=SPI bus is idle. 1=SPI bus is busy." />
      <!-- Bits 30:23 reserved. -->
      <field name="FiFoRdPtr" bit="16" size="7" desc="Read-only. Reset: 00h. The current Data FIFO read pointer." />
      <!-- Bit 15 reserved. -->
      <field name="FiFoWrPtr" bit="8" size="7" desc="Read-only. Reset: 00h. The current Data FIFO write pointer." />
      <field name="DoneByteCount" bit="0" size="8" desc="Read-only. Reset: 00h. Indicates how many bytes has been received or sent in the previous SPI transaction." />
    </register>
    <register name="FIFO" type="memory" device="SPI" offset="0x080" size="1" desc="FIFO[70:0]. Read-write. Reset: 00h.">
      <field name="FiFo" bit="0" size="8" desc="Read-write. Reset: 00h. Contains the Data FIFO byte which is used in command mode to send or receive data." />
    </register>

    <!-- 9.2.9.4 eSPI Registers -->

    <register name="DN_TXHDR_0th" type="memory" device="ESPI" offset="0x00000000" size="4" desc="FCH::ITF::ESPI::DN_TXHDR_0th. Reset: 0000_0000h.">
      <field name="DNCMD_HDATA2" bit="24" size="8" desc="Read-write. Reset: 00h. Description: The definition for this field is dependent upon SW_CMD_TYPE. " />
      <field name="DNCMD_HDATA1" bit="16" size="8" desc="Read-write. Reset: 00h. Description: The definition for this field is dependent upon SW_CMD_TYPE. " />
      <field name="DNCMD_HDATA0" bit="8" size="8" desc="Read-write. Reset: 00h. Description: The definition for this field is dependent upon SW_CMD_TYPE. " />
      <!-- Bits 7:6 reserved. -->
      <field name="SLAVE_SEL" bit="4" size="2" desc="Read-write. Reset: 0h. Slave N selected." />
      <field name="DNCMD_STATUS" bit="3" size="1" desc="Read,Write-0-only. Reset: 0. 0=Clear: Hardware will automatically clear this bit after the packet is sent down. 1=Set: The bit needs to be set last by software after all eSPI specific registers are all programmed to inform the protocoal layer to send down command or packet. Downstream command status. Cleared when Writting to 0." />
      <field name="DNCMD_TYPE" bit="0" size="3" desc="Read-write. Reset: 0h. TX Command Type." />
    </register>

    <!-- page 455 -->

    <register name="DN_TXHDR_1" type="memory" device="ESPI" offset="0x00000004" size="4" desc="FCH::ITF::ESPI::DN_TXHDR_1. Read-write. Reset: 0000_0000h.">
      <field name="DNCMD_HDATA6" bit="24" size="8" desc="Read-write. Reset: 00h. Description: The definition for this field is dependent upon SW_CMD_TYPE.  Indipendent channel command selected: Data[31:24].  Peripheral selected: Message specific byte[2].  VW selected: Reserved, should always be 00h.  OOB selected: Reserved, should always be 00h.  FLASH selected: Reserved, should always be 00h." />
      <field name="DNCMD_HDATA5" bit="16" size="8" desc="Read-write. Reset: 00h. Description: The definition for this field is dependent upon SW_CMD_TYPE.  Indipendent channel command selected: Data[23:16].  Peripheral selected: Message specific byte[1].  VW selected: Reserved, should always be 00h. " />
      <field name="DNCMD_HDATA4" bit="8" size="8" desc="Read-write. Reset: 00h. Description: The definition for this field is dependent upon SW_CMD_TYPE. " />
      <field name="DNCMD_HDATA3" bit="0" size="8" desc="Read-write. Reset: 00h. Description: The definition for this field is dependent upon SW_CMD_TYPE.  Indipendent channel command selected: Data[7:0].    Peripheral selected: Message code [7:0].  VW selected: Reserved, should always be 00h. " />
    </register>

    <!-- page 456 -->

    <register name="DN_TXHDR_2" type="memory" device="ESPI" offset="0x00000008" size="4" desc="FCH::ITF::ESPI::DN_TXHDR_2. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:8 reserved. -->
      <field name="DNCMD_HDATA7" bit="0" size="8" desc="Read-write. Reset: 00h. Description: The definition for this field is dependent upon SW_CMD_TYPE.  Indipendent channel command selected: Reserved, should always be 00h.  Peripheral selected: Message specific byte[3].  VW selected: Reserved, should always be 00h.  OOB selected: Reserved, should always be 00h.  FLASH selected: Reserved, should always be 00h." />
    </register>
    <register name="DN_TXDATA_PORT" type="memory" device="ESPI" offset="0x0000000C" size="4" desc="FCH::ITF::ESPI::DN_TXDATA_PORT. Read-write. Reset: 0000_0000h.">
      <field name="DN_TXDATA_B3" bit="24" size="8" desc="Read-write. Reset: 00h. Description: The definition for this field is dependent upon SW_CMD_TYPE.  Indipendent channel command selected: Reserved, should always be 00h.  Peripheral selected: Message Data DWn[31:24].  VW selected: VW Index Group (2n + 1) data.  OOB selected: OOB Message DWn[31:24].  FLASH selected: Flash Cpl Data DWn[31:24]." />
      <field name="DN_TXDATA_B2" bit="16" size="8" desc="Read-write. Reset: 00h. Description: The definition for this field is dependent upon SW_CMD_TYPE.  Indipendent channel command selected: Reserved, should always be 00h.  Peripheral selected: Message Data DWn[23:16].  VW selected: VW Index Group (2n + 1).  OOB selected: OOB Message DWn[23:16].  FLASH selected: Flash Cpl Data DWn[23:16]." />
      <field name="DN_TXDATA_B1" bit="8" size="8" desc="Read-write. Reset: 00h. Description: The definition for this field is dependent upon SW_CMD_TYPE.  Indipendent channel command selected: Reserved, should always be 00h.  Peripheral selected: Message Data DWn[15:8].  VW selected: VW Index Group 2n Data.  OOB selected: OOB Message DWn[15:8].  FLASH selected: Flash Cpl Data DWn[15:8]." />
      <field name="DN_TXDATA_B0" bit="0" size="8" desc="Read-write. Reset: 00h. Description: The definition for this field is dependent upon SW_CMD_TYPE.  Indipendent channel command selected: Reserved, should always be 00h.  Peripheral selected: Message Data DWn[7:0].  VW selected: VW Index Group 2n.  OOB selected: OOB Message DWn[7:0].  FLASH selected: Flash Cpl Data DWn[7:0]." />
    </register>

    <!-- page 457 -->

    <register name="UP_RXHDR_0" type="memory" device="ESPI" offset="0x00000010" size="4" desc="FCH::ITF::ESPI::UP_RXHDR_0. Reset: 0000_0000h.">
      <field name="UPCMD_HDATA2" bit="24" size="8" desc="Read-only. Reset: 00h." />
      <field name="UPCMD_HDATA1" bit="16" size="8" desc="Read-only. Reset: 00h." />
      <field name="UPCMD_HDATA0" bit="8" size="8" desc="Read-only. Reset: 00h. Cycle Type: This field stores the cycle type from GET_FLASH_NP and GET_OOB." />
      <!-- Bits 7:6 reserved. -->
      <field name="SLAVE_SEL" bit="4" size="2" desc="Read-only. Reset: 0h. Slave N receive select." />
      <field name="UPCMD_STATUS" bit="3" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=OOB message packet or Flash request packet not received. 1=This bit will be set after OOB message packet or Flash request packet is recieved, and eSPI will not send down another GET_OOB or GET_FLASH_NP before the Valid bit. Cleared by software. Upstream  command status. Valid bit Status. This bit can be cleared by software writing 1 to this field." />
      <field name="UPCMD_TYPE" bit="0" size="3" desc="Read-only. Reset: 0h. Upstream command type." />
    </register>

    <!-- page 458 -->

    <register name="UP_RXHDR_1" type="memory" device="ESPI" offset="0x00000014" size="4" desc="FCH::ITF::ESPI::UP_RXHDR_1. Read-only. Reset: 0000_0000h.">
      <field name="UPCMD_HDATA6" bit="24" size="8" desc="Read-only. Reset: 00h. Description: The definition for this field is dependent upon RX_REQ_TYPE. - OOB selected: Reserved. - FLASH selected: Addess[7:0]." />
      <field name="UPCMD_HDATA5" bit="16" size="8" desc="Read-only. Reset: 00h. Description: The definition for this field is dependent upon RX_REQ_TYPE. - OOB selected: SMBus Byte Count. - FLASH selected: Addess[15:8]." />
      <field name="UPCMD_HDATA4" bit="8" size="8" desc="Read-only. Reset: 00h. Description: The definition for this field is dependent upon RX_REQ_TYPE. - OOB selected: SMBus Command Opcode. - FLASH selected: Addess[23:16]." />
      <field name="UPCMD_HDATA3" bit="0" size="8" desc="Read-only. Reset: 00h. Description: The definition for this field is dependent upon RX_REQ_TYPE. - OOB selected: SMBus Slave Address. - FLASH selected: Addess[31:24]." />
    </register>
    <register name="UP_RXDATA_PORT" type="memory" device="ESPI" offset="0x00000018" size="4" desc="FCH::ITF::ESPI::UP_RXDATA_PORT. Read-only. Reset: 0000_0000h.">
      <field name="UP_RXDATA" bit="0" size="32" desc="Read-only. Reset: 0000_0000h. Receive data." />
    </register>
    <register name="RESERVED_REG0" type="memory" device="ESPI" offset="0x0000001C" size="4" desc="FCH::ITF::ESPI::RESERVED_REG0. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="RESERVED_REG1" type="memory" device="ESPI" offset="0x00000020" size="4" desc="FCH::ITF::ESPI::RESERVED_REG1. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>

    <!-- page 459 -->

    <register name="RESERVED_REG2" type="memory" device="ESPI" offset="0x00000024" size="4" desc="FCH::ITF::ESPI::RESERVED_REG2. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="MASTER_CAP" type="memory" device="ESPI" offset="0x0000002C" size="4" desc="FCH::ITF::ESPI::MASTER_CAP. Read-only. Reset: Fixed,E649_E91Fh.">
      <field name="CRC_CHECK_SUPPORT" bit="31" size="1" desc="Read-only. Reset: Fixed,1. 0=Master supports CRC checking. 1=Master doesn't support CRC checking. CRC checking supported by Master." />
      <field name="ALERT_MODE_SUPPORT" bit="30" size="1" desc="Read-only. Reset: Fixed,1. 0=IO[1] pin is used to signal the Alert event. 1=A dedicated Alert# pin is used to signal the Alert event, or IO[1] pin used for Alert. Alert mode supported by the Master." />
      <field name="IO_MODE_SUPPORT" bit="28" size="2" desc="Read-only. Reset: Fixed,2h. IO Mode support by Controller, Quad mode, Dual mode, single mode" />
      <field name="CLK_FREQ_SUPPORT" bit="25" size="3" desc="Read-only. Reset: Fixed,3h. Operating frequency supported." />
      <field name="SLAVE_NUM" bit="22" size="3" desc="Read-only. Reset: Fixed,1h. Indicates the number of slaves. A value of 1 indicates one slave supported, and is the minimum requirement. A value of 0 indicates 8 slaves, and is the masimum supported number." />
      <field name="PR_MAX_SIZE" bit="19" size="3" desc="Read-only. Reset: Fixed,1h. Peripheral Channel maximum payload size supported. The payload of the transaction must not cross the naturally aligned address boundary of the corresponding maximum payload size." />
      <field name="VW_MAX_SIZE" bit="13" size="6" desc="Read-only. Reset: Fixed,0Fh. Operating maximum Virtual Wire Count supported. The maximum number of Virtual Wire groups that can be sent in a single Virtual Wire packet. This is a 0-based count. The default value of 0 indicates a count of 1." />
      <field name="OOB_MAX_SIZE" bit="10" size="3" desc="Read-only. Reset: Fixed,2h. OOB Message Channel maximum payload size supported." />
      <field name="FLASH_MAX_SIZE" bit="7" size="3" desc="Read-only. Reset: Fixed,2h. Flash Access Channel maximum payload size supported." />
      <field name="ESPI_VERSION" bit="4" size="3" desc="Read-only. Reset: Fixed,1h. eSPI version." />
      <field name="PR_SUPPORT" bit="3" size="1" desc="Read-only. Reset: Fixed,1. 0=Not supported. 1=Supported. Peripheral Channel support by Master." />
      <field name="VW_SUPPORT" bit="2" size="1" desc="Read-only. Reset: Fixed,1. 0=Not supported. 1=Supported. Virtual Wire Channel support by Master." />
      <field name="OOB_SUPPORT" bit="1" size="1" desc="Read-only. Reset: Fixed,1. 0=Not supported. 1=Supported. OOB Message Channel support by Master." />
      <field name="FLASH_SUPPORT" bit="0" size="1" desc="Read-only. Reset: Fixed,1. 0=Not supported. 1=Supported. Flash Access Channel support by Master." />
    </register>

    <!-- page 460 -->

    <register name="GLOBAL_CONTROL_0" type="memory" device="ESPI" offset="0x00000030" size="4" desc="FCH::ITF::ESPI::GLOBAL_CONTROL_0. Read-write. Reset: 0000_0008h.">
      <!-- Bits 31:30 reserved. -->
      <field name="WAIT_CNT" bit="24" size="6" desc="Read-write. Reset: 00h. Specifies the timeout count for the wait state." />
      <field name="WDG_CNT" bit="8" size="16" desc="Read-write. Reset: 0000h. Specifies the timeout retry count for PCI downstream retries." />
      <!-- Bit 7 reserved. -->
      <field name="AL_IDLE_TIMER" bit="4" size="3" desc="Read-write. Reset: 0h. Selects the idle timer timeout value. Once the idle timer reaches the timeout value and AL_STOP_EN == 1, eSPI will output ESPI_STOP_AlClk to do global Alink clock gating." />
      <field name="AL_STOP_EN" bit="3" size="1" desc="Read-write. Reset: 1. 0=Disable. 1=Enable. Global Alink clock gating enable. set this bit to enable the eSPI to generate ESPI_STOP_AlClk to do global clock gating once the global Alink Idle Timer reaches the timeout value." />
      <field name="PR_CLKGAT_EN" bit="2" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Peripheral clock gating enable. Set this bit to enable peripheral block to dynamically clock gate once the Slave peripheral channel is disabled." />
      <field name="WAIT_CHKEN" bit="1" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Wait State Control enable. Set this bit to enable the Wait State counter during eSPI bus turn around." />
      <field name="WDG_EN" bit="0" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Watchdog enable. Set this bit to enable the watchdog counter for all the PCI downstream transactions for eSPI." />
    </register>

    <!-- page 461 -->

    <register name="GLOBAL_CONTROL_1" type="memory" device="ESPI" offset="0x00000034" size="4" desc="FCH::ITF::ESPI::GLOBAL_CONTROL_1. Read-write. Reset: 0002_FF00h.">
      <!-- Bits 31:18 reserved. -->
      <field name="RGCMD_INT_MAP" bit="13" size="5" desc="Read-write. Reset: 17h. Register Command interrupt mapping, When Register command (Downstream/Upstream peripheral message, Downstream/Upstream OOB, Downstream VW, Channel Independent command) has finished, eSPI controller generated interrupt will map to the interrupt pin according to the following register setting." />
      <field name="ERR_INT_MAP" bit="8" size="5" desc="Read-write. Reset: 1Fh. Error interrupt mapping. When a Slave transaction error has happened, and the error interrupt enable has been set, the error interrupt will map to the interrupt pin according to the following register setting." />
      <!-- Bits 7:5 reserved. -->
      <field name="SUB_DECODE_SLV" bit="3" size="2" desc="Read-write. Reset: 0h. Selects which slave to do subtractive decode." />
      <field name="SUB_DECODE_EN" bit="2" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enable eSPI to do subtractive decode." />
      <field name="BUS_MASTER_EN" bit="1" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Bus Master enable. Enables eSPI Upstream Memory cycle posting." />
      <field name="SW_RST" bit="0" size="1" desc="Read-write. Reset: 0. 0=No effect. 1=Controller reset. Set the bit to perform global controller resets for the eSPI controller. All the state machines will return to idle and all the requests will be flushed. All the   configuraiton registers will reset to default values and software needs to send In-Band Resets to each Slave device after the controller reset so that both Master and Slave run in the same configuration mode." />
    </register>

    <!-- page 462 -->

    <register name="SLAVE0_IO_BASE_REG0" type="memory" device="ESPI" offset="0x00000044" size="4" desc="FCH::ITF::ESPI::SLAVE0_IO_BASE_REG0. Read-write. Reset: 0000_0000h.">
      <field name="RANGE1" bit="16" size="16" desc="Read-write. Reset: 0000h. IO decode base address for Range 1." />
      <field name="RANGE0" bit="0" size="16" desc="Read-write. Reset: 0000h. IO decode base address for Range 0." />
    </register>
    <register name="SLAVE0_IO_BASE_REG1" type="memory" device="ESPI" offset="0x00000048" size="4" desc="FCH::ITF::ESPI::SLAVE0_IO_BASE_REG1. Read-write. Reset: 0000_0000h.">
      <field name="RANGE3" bit="16" size="16" desc="Read-write. Reset: 0000h. IO decode base address for Range 3." />
      <field name="RANGE2" bit="0" size="16" desc="Read-write. Reset: 0000h. IO decode base address for Range 2." />
    </register>
    <register name="SLAVE0_IO_SIZE" type="memory" device="ESPI" offset="0x0000004C" size="4" desc="FCH::ITF::ESPI::SLAVE0_IO_SIZE. Read-write. Reset: 0000_0000h.">
      <field name="RANGE3" bit="24" size="8" desc="Read-write. Reset: 00h. Programmable IO Range3 size." />
      <field name="RANGE2" bit="16" size="8" desc="Read-write. Reset: 00h. Programmable IO Range2 size." />
      <field name="RANGE1" bit="8" size="8" desc="Read-write. Reset: 00h. Programmable IO Range1 size." />
      <field name="RANGE0" bit="0" size="8" desc="Read-write. Reset: 00h. Programmable IO Range0 size." />
    </register>
    <register name="SLAVE0_MMIO_BASE_REG0" type="memory" device="ESPI" offset="0x00000050" size="4" desc="FCH::ITF::ESPI::SLAVE0_MMIO_BASE_REG0. Read-write. Reset: 0000_0000h.">
      <field name="RANGE0" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. MMIO decode base address for Range 0." />
    </register>
    <register name="SLAVE0_MMIO_BASE_REG1" type="memory" device="ESPI" offset="0x00000054" size="4" desc="FCH::ITF::ESPI::SLAVE0_MMIO_BASE_REG1. Read-write. Reset: 0000_0000h.">
      <field name="RANGE1" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. MMIO decode base address for Range 1." />
    </register>
    <register name="SLAVE0_MMIO_BASE_REG2" type="memory" device="ESPI" offset="0x00000058" size="4" desc="FCH::ITF::ESPI::SLAVE0_MMIO_BASE_REG2. Read-write. Reset: 0000_0000h.">
      <field name="RANGE2" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. MMIO decode base address for Range 2." />
    </register>
    <register name="SLAVE0_MMIO_BASE_REG3" type="memory" device="ESPI" offset="0x0000005C" size="4" desc="FCH::ITF::ESPI::SLAVE0_MMIO_BASE_REG3. Read-write. Reset: 0000_0000h.">
      <field name="RANGE3" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. MMIO decode base address for Range 3." />
    </register>

    <!-- page 463 -->

    <register name="SLAVE0_MMIO_SIZE_REG0" type="memory" device="ESPI" offset="0x00000060" size="4" desc="FCH::ITF::ESPI::SLAVE0_MMIO_SIZE_REG0. Read-write. Reset: 0000_0000h.">
      <field name="RANGE1" bit="16" size="16" desc="Read-write. Reset: 0000h. Programmable MMIO Range1 size." />
      <field name="RANGE0" bit="0" size="16" desc="Read-write. Reset: 0000h. Programmable MMIO Range0 size." />
    </register>
    <register name="SLAVE0_MMIO_SIZE_REG1" type="memory" device="ESPI" offset="0x00000064" size="4" desc="FCH::ITF::ESPI::SLAVE0_MMIO_SIZE_REG1. Read-write. Reset: 0000_0000h.">
      <field name="RANGE3" bit="16" size="16" desc="Read-write. Reset: 0000h. Programmable MMIO Range3 size." />
      <field name="RANGE2" bit="0" size="16" desc="Read-write. Reset: 0000h. Programmable MMIO Range2 size." />
    </register>
    <register name="SLAVE0_CONFIG" type="memory" device="ESPI" offset="0x00000068" size="4" desc="FCH::ITF::ESPI::SLAVE0_CONFIG. Read-write. Reset: 0000_0000h.">
      <field name="CRC_CHECK_EN" bit="31" size="1" desc="Read-write. Reset: 0. 0=CRC checking is disabled. 1=CRC checking is enabled. This bit is set to 1 by the eSPI Master to enable CRC checking on the eSPI bus. By default, CRC checking is disabled." />
      <field name="ALERT_MODE_SEL" bit="30" size="1" desc="Read-write. Reset: 0. 0=IO bit[1] pin is used to signal the Alert event. 1=A dedicated Alert# pin is used to signal the Alert event. This bit serves to configure the Alert mechanism used by the slave to initiate a transaction on the eSPI interface. Note: This bit can only be 0 in a single Master-single Slave topology. For single Master-multiple Slave topology, this bit must be programmed to 1." />
      <field name="IO_MODE_SEL" bit="28" size="2" desc="Read-write. Reset: 0h. IO Mode Select. eSPI Master programs this field to enable the appropiate mode of operation, which takes effect at the de-assertion edge of the Chip Select#. The IO Mode configured in this field must be supported by both the Master and Slave. Single IO mode is supported by default." />
      <field name="CLK_FREQ_SEL" bit="25" size="3" desc="Read-write. Reset: 0h. Identifies the operating frequency." />
      <!-- Bits 24:4 reserved. -->
      <field name="PR_EN" bit="3" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Peripheral Channel enable. This bit is set to 1 by the eSPI Master to enable the Peripheral Channel." />
      <field name="VW_EN" bit="2" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Virtual Wire Channel enable. This bit is set to 1 by the eSPI Master to enable the Virtual Wire Channel." />
      <field name="OOB_EN" bit="1" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. OOB Message Channel enable. This bit is set to 1 by the eSPI Master to enable the OOB Message Channel." />
      <field name="FLASH_EN" bit="0" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Flash Access Channel enable. This bit is set to 1 by the eSPI Master to enable the Flash Access Channel." />
    </register>

    <!-- page 464 -->

    <register name="SLAVE0_INT_EN" type="memory" device="ESPI" offset="0x0000006C" size="4" desc="FCH::ITF::ESPI::SLAVE0_INT_EN. Read-write. Reset: 0000_0000h.">
      <field name="FLASH_REQ_INT_EN" bit="31" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Flash Request Received enable. Enables the generation of a command interrupt when an Upstream Flash Request is recieved and valid to Read." />
      <field name="RXOOB_INT_EN" bit="30" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. OOB Message Received enable. Enables the generation of a command interrupt when an Upstream OOB Message is recieved and valid to Read." />
      <field name="RXMSG_INT_EN" bit="29" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Peripheral Message Received enable. Enables the generation of a command interrupt when an Upstream Peripheral Message is recieved and valid to Read." />
      <field name="DNCMD_INT_EN" bit="28" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Downstream Register Command Complete enable. Enables the generation of a command interrupt when a Downstream eSPI register's programming command has completed." />
      <field name="RXVW_GRP3_INT_EN" bit="27" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Virtual Wire Index Group3 Received enable. Enables the generation of a command interrupt when a Virtual Wire Index Group3 register specified Virtual Wire Packet is received." />
      <field name="RXVW_GRP2_INT_EN" bit="26" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Virtual Wire Index Group2 Received enable. Enables the generation of a command interrupt when a Virtual Wire Index Group2 register specified Virtual Wire Packet is received." />
      <field name="RXVW_GRP1_INT_EN" bit="25" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Virtual Wire Index Group1 Received enable. Enables the generation of a command interrupt when a Virtual Wire Index Group1 register specified Virtual Wire Packet is received." />
      <field name="RXVW_GRP0_INT_EN" bit="24" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Virtual Wire Index Group0 Received enable. Enables the generation of a command interrupt when a Virtual Wire Index Group0 register specified Virtual Wire Packet is received." />
      <!-- Bits 23:20 reserved. -->
      <field name="WDG_TIMEOUT_INT_EN" bit="19" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Alink Bus Watchdog Timer timeout enable. Enables the generation of an error interrupt when an Alink Bus Watchdog Timer timeout occurs." />
      <field name="MST_ABORT_INT_EN" bit="18" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Alink Bus Master Abort enable. Enables the generation of an error interrupt when an eSPI is doing a Master Abort." />
      <!-- Bits 17:16 reserved. -->
      <field name="PROTOCOL_ERR_INT_EN" bit="15" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Protocol Error detected enable. Enables the generation of an error interrupt when a Protocol Error is detected." />
      <field name="RXFLASH_OVERFLOW_INT_EN" bit="14" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Flash Packet data length over 128 bytes enable. Enables the generation of an error interrupt when a Flash Packet data is over 128 bytes." />
      <field name="RXMSG_OVERFLOW_INT_EN" bit="13" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Peripheral Message data length over 32 bytes enable. Enables the generation of an error interrupt when a Peripheral Packet Message data is over 32 bytes." />
      <field name="RXOOB_OVERFLOW_INT_EN" bit="12" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. OOB Packet data length over 128 bytes enable. Enables the generation of an error interrupt when an OOB Packet data is over 128 bytes." />
      <field name="ILLEGAL_LEN_INT_EN" bit="11" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Illegal Response Length Received enable. Enables the generation of an error interrupt when an Illegal length is received." />
      <field name="ILLEGAL_TAG_INT_EN" bit="10" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Illegal Response Tag Received enable. Enables the generation of an error interrupt when an Illegal tag is received." />
      <field name="UNSUCSS_CPL_INT_EN" bit="9" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Unsuccessful CPL Received enable. Enables the generation of an error interrupt when an Unsuccessful Completion without Data is received." />
      <field name="INVALID_CT_INT_EN" bit="8" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Unrecognized/Invalid Cycle Type Received enable. Enables the generation of an error interrupt when an Unrecognized Cycle Type is received." />
      <field name="INVALID_RSP_INT_EN" bit="7" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Unrecognized/Invalid Response Code Received enable. Enables the generation of an error interrupt when an Unrecognized Response Code is received." />
      <field name="NON_FATAL_ERR_INT_EN" bit="6" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. NON_FATAL_ERROR Response Code Received enable. Enables the generation of an error interrupt when a NON_FATAL_ERROR Response Code is received." />
      <field name="FATAL_ERR_INT_EN" bit="5" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. FATAL_ERROR Response Code Received enable. Enables the generation of an error interrupt when a FATAL_ERROR Response Code is received." />
      <field name="NO_RSP_INT_EN" bit="4" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. NO_RESPONSE Response Code Received enable. Enables the generation of an error interrupt when a NO_RESPONSE Response Code is received." />
      <!-- Bit 3 reserved. -->
      <field name="CRC_ERR_INT_EN" bit="2" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. CRC Error detected enable. Enables the generation of an error interrupt when CRC Error is detected on the response phase." />
      <field name="WAIT_TIMEOUT_INT_EN" bit="1" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. eSPI Bus Wait State Insertion Maximum Out enable. Enables the generation of an error interrupt when eSPI Wait State timer timeout occurs." />
      <field name="BUS_ERR_INT_EN" bit="0" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. eSPI Bus Timing Error enable. Enables generation of an error interrupt when eSPI Bus Timing Error occurs." />
    </register>

    <!-- page 465 -->

    <register name="SLAVE0_INT_STS" type="memory" device="ESPI" offset="0x00000070" size="4" desc="FCH::ITF::ESPI::SLAVE0_INT_STS. Read,Write-1-to-clear. Reset: 0000_0000h.">
      <field name="FLASH_REQ_INT" bit="31" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Upstream Flash Request not received. 1=Upstream Flash Request has been received. Flash Request Recieved status. Upstream Flash Request has been received and is valid to Read." />
      <field name="RXOOB_INT" bit="30" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Upstream OOB Message not received. 1=Upstream OOB Message has been received. OOB Message Recieved status. Upstream OOB Message has been received and is valid to Read." />
      <field name="RXMSG_INT" bit="29" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Upstream Peripheral Message not received. 1=Upstream Peripheral Message has been received. Peripheral Message Recieved status. Upstream Peripheral Message has been received and is valid to Read." />
      <field name="DNCMD_INT" bit="28" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Downstream Register Command not complete. 1=Downstream Register Command complete. Downstream Register Command Complete status. When once set to 1, software can program the next command or get the data." />
      <field name="RXVW_GRP3_INT" bit="27" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Specified VW packet has not been received. 1=Virtual Wire Index Group3 register specified VW packet has been received. Virtual Wire Index Group3 Received status." />
      <field name="RXVW_GRP2_INT" bit="26" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Specified VW packet has not been received. 1=Virtual Wire Index Group2 register specified VW packet has been received. Virtual Wire Index Group2 Received status." />
      <field name="RXVW_GRP1_INT" bit="25" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Specified VW packet has not been received. 1=Virtual Wire Index Group1 register specified VW packet has been received. Virtual Wire Index Group1 Received status." />
      <field name="RXVW_GRP0_INT" bit="24" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Specified VW packet has not been received. 1=Virtual Wire Index Group0 register specified VW packet has been received. Virtual Wire Index Group0 Received status." />
      <!-- Bits 23:20 reserved. -->
      <field name="WDG_TIMEOUT_INT" bit="19" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=eSPI Watchdog Timer Timeout has not occurred. 1=eSPI Watchdog Timer Timeout has occurred. Alink Bus Watchdog Timer Timeout status." />
      <field name="MST_ABORT_INT" bit="18" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=eSPI not doing a Master Abort. 1=eSPI doing a Master Abort. Alink Bus Master Abort status." />
      <!-- Bits 17:16 reserved. -->
      <field name="PROTOCOL_ERR_INT" bit="15" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Protocol Error has not occurred. 1=Protocol Error has occurred. Protocol Error status." />
      <field name="RXFLASH_OVERFLOW_INT" bit="14" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Flash Packet Data Length not over 128 bytes. 1=Flash Packet Data Length over 128 bytes. Flash Packet Data Lenght over 128 bytes status." />
      <field name="RXMSG_OVERFLOW_INT" bit="13" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Peripheral Message Data Length not over 32 bytes. 1=Peripheral Message Data Length over 32 bytes. Peripheral Message Data Length over 32 bytes status." />
      <field name="RXOOB_OVERFLOW_INT" bit="12" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=OOB Packet Length not over 128 bytes. 1=OOB Packet Length over 128 bytes. OOB Packet Data Length over 128 bytes status." />
      <field name="ILLEGAL_LEN_INT" bit="11" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Illegal Response Length not received. 1=Illegal Response Length received. Illegal Response Length Received status. Set when an Illegal Response Length is received from a Slave." />
      <field name="ILLEGAL_TAG_INT" bit="10" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Illegal Response Tag not received. 1=Illegal Response Tag received. Illegal Response Tag Received status. Set when an Illegal Response Tag is received." />
      <field name="UNSUCSS_CPL_INT" bit="9" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Unsuccessful Completion Packet not received. 1=Unsuccessful Completion Packet received. Unsuccessful CPL Received status. Set when an Unsuccessful Completion without data is received." />
      <field name="UNKNOWN_CT_INT" bit="8" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Unrecognized Cycle Type not received. 1=Unrecognized Cycle Type received. Invalid Cycle Type Received status. Set when an Unrecognized Cycle Type is received." />
      <field name="UNKNOWN_RSP_INT" bit="7" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Unrecognized Response not received. 1=Unrecognized Response received. Invalid Response Code Received status. Set when an Unrecognized Response code is received." />
      <field name="NON_FATAL_ERR_INT" bit="6" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=NON_FATAL_ERROR not received. 1=NON_FATAL_ERROR received from the Slave. NON_FATAL_ERROR Response Code Received status. Set when a NON_FATAL_ERROR Response code is received from the Slave." />
      <field name="FATAL_ERR_INT" bit="5" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=FATAL_ERROR not received. 1=FATAL_ERROR received from the Slave. FATAL_ERROR Response Code Received status. Set when a FATAL_ERROR Response code is received from the Slave." />
      <field name="NO_RSP_INT" bit="4" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=NO_RESPONSE not received. 1=NO_RESPONSE received from the Slave. NO_RESPONSE Code Received status. Set when a NO_RESPONSE code is received from the Slave." />
      <!-- Bit 3 reserved. -->
      <field name="CRC_ERR_INT" bit="2" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=CRC Error not detected. 1=CRC Error detected. CRC Error detected status. CRC error detected on response phase. Set when a CRC Error is detected on the response phase." />
      <field name="WAIT_TIMEOUT_INT" bit="1" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Timer timeout has not occured. 1=Timer timeout has occured. eSPI Bus Wait State Intersection maximum out status. eSPI Wait State timer timeout. Set when the Slave inserts more Wait States than the counter specified in eSPI Global Control and Status Register0." />
      <field name="BUS_ERR_INT" bit="0" size="1" desc="Read,Write-1-to-clear. Reset: 0. 0=Timing error not detected. 1=eSPI Bus timing error detected. eSPI Bus Timing error status. Set when eSPI link block detect Slave dosen't drive 1 after response CRC and before CS# is de-asserted." />
    </register>

    <!-- page 466 -->

    <register name="SLAVE0_RXMSG_HDR0" type="memory" device="ESPI" offset="0x00000074" size="4" desc="FCH::ITF::ESPI::SLAVE0_RXMSG_HDR0. Read-only. Reset: 0000_0000h.">
      <field name="BYTE3" bit="24" size="8" desc="Read-only. Reset: 00h. Received Periperal Message code." />
      <field name="BYTE2" bit="16" size="8" desc="Read-only. Reset: 00h. Received Periperal Message Length[7:0]." />
      <field name="BYTE1" bit="8" size="8" desc="Read-only. Reset: 00h. Bits[15:12]: Tag, Bits[11:8]: Length[11:8]." />
      <field name="CYCLETYPE" bit="0" size="8" desc="Read-only. Reset: 00h. CycleType[7:0] for Periperal Msg/MsgD." />
    </register>
    <register name="SLAVE0_RXMSG_HDR1" type="memory" device="ESPI" offset="0x00000078" size="4" desc="FCH::ITF::ESPI::SLAVE0_RXMSG_HDR1. Read-only. Reset: 0000_0000h.">
      <field name="SPECIFIC_BYTE3" bit="24" size="8" desc="Read-only. Reset: 00h. Periperal Message Specific Byte3." />
      <field name="SPECIFIC_BYTE2" bit="16" size="8" desc="Read-only. Reset: 00h. Periperal Message Specific Byte2." />
      <field name="SPECIFIC_BYTE1" bit="8" size="8" desc="Read-only. Reset: 00h. Periperal Message Specific Byte1." />
      <field name="SPECIFIC_BYTE0" bit="0" size="8" desc="Read-only. Reset: 00h. Periperal Message Specific Byte0." />
    </register>

    <!-- page 467 -->

    <register name="SLAVE0_RXMSG_DATA_PORT" type="memory" device="ESPI" offset="0x0000007C" size="4" desc="FCH::ITF::ESPI::SLAVE0_RXMSG_DATA_PORT. Read-only. Reset: 0000_0000h.">
      <field name="RXMSG_DATA" bit="0" size="32" desc="Read-only. Reset: 0000_0000h. Receive message data." />
    </register>
    <register name="RESERVED_RXMSG_REG0" type="memory" device="ESPI" offset="0x00000080" size="4" desc="FCH::ITF::ESPI::RESERVED_RXMSG_REG0. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="RESERVED_RXMSG_REG1" type="memory" device="ESPI" offset="0x00000084" size="4" desc="FCH::ITF::ESPI::RESERVED_RXMSG_REG1. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="RESERVED_RXMSG_REG2" type="memory" device="ESPI" offset="0x00000088" size="4" desc="FCH::ITF::ESPI::RESERVED_RXMSG_REG2. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="RESERVED_RXMSG_REG3" type="memory" device="ESPI" offset="0x0000008C" size="4" desc="FCH::ITF::ESPI::RESERVED_RXMSG_REG3. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="RESERVED_RXMSG_REG4" type="memory" device="ESPI" offset="0x00000090" size="4" desc="FCH::ITF::ESPI::RESERVED_RXMSG_REG4. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="RESERVED_RXMSG_REG5" type="memory" device="ESPI" offset="0x00000094" size="4" desc="FCH::ITF::ESPI::RESERVED_RXMSG_REG5. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="RESERVED_RXMSG_REG6" type="memory" device="ESPI" offset="0x00000098" size="4" desc="FCH::ITF::ESPI::RESERVED_RXMSG_REG6. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="SLAVE0_RXVW" type="memory" device="ESPI" offset="0x0000009C" size="4" desc="FCH::ITF::ESPI::SLAVE0_RXVW. Reset: 0007_0C00h.">
      <!-- Bits 31:20 reserved. -->
      <field name="HOST_RST_ACK" bit="19" size="1" desc="Read-only. Reset: 0. 0=No acknowledge sent. 1=Acknowledge sent. Host Reset Acknowledge (HOST_RST_ACK). Sent by the Slave to acknowledge it received the HOST_RST_WARN virtual wire." />
      <field name="RCIN_B" bit="18" size="1" desc="Read-only. Reset: 1. 0=No INIT. 1=INIT sent. Reset CPU INIT (RCIN#). Sent to request a CPU reset   on behalf of the Keyboard controller." />
      <field name="SMI_B" bit="17" size="1" desc="Read-only. Reset: 1. 0=No interrupt. 1=System Management Interrupt sent. System Management Interrupt (SMI#). Sent as a general purpose alert resulting in an SMI code being invoked by the BIOS." />
      <field name="SCI_B" bit="16" size="1" desc="Read-only. Reset: 1. 0=No interrupt. 1=System Controller Interrupt sent. System Controller Interrupt (SCI#). Sent as a general purpose alert resulting in an ACPI method being invoked by the OS." />
      <field name="SLAVE_BOOT_LOAD_STS" bit="15" size="1" desc="Read-only. Reset: 0. 0=The boot image is corrupted, incomplete or otherwise unusable. 1=The boot code load was successful and that the integrity of the image is intact, or the boot code load from the Master attaced flash is not required. Slave boot load status. Sent upon completion of the Slave boot load from the Master attached flash. NOTE: The Slave_Boot_Load_Status must be sent in either the same or a previous virtual wire message as the Slave_Boot_Load_Done." />
      <field name="ERROR_NONFATAL" bit="14" size="1" desc="Read-only. Reset: 0. 0=No non-fatal error. 1=Non-Fatal error detected. Non-Fatal error is detected, not due to eSPI transaction on the bus. NOTE: Non-Fatal error due to transaction on the eSPI bus will be signaled through the Response (RSP) phase." />
      <field name="ERROR_FATAL" bit="13" size="1" desc="Read-only. Reset: 0. 0=No fatal error. 1=Fatal error detected. Fatal error is detected, not due to eSPI transaction on the bus. NOTE: Fatal error due to transaction on the eSPI bus will be signaled through the Response (RSP) phase." />
      <field name="SLAVE_BOOT_LOAD_DONE" bit="12" size="1" desc="Read-only. Reset: 0. 0=No event. 1=Slave Boot Load done. Slave Boot Load done. Sent upon completed boot process, as indication to eSPI Master to continue with the G3 to S0 exit." />
      <field name="PME_B" bit="11" size="1" desc="Read-only. Reset: 1. 0=No event. 1=Power Management Event occurred. PCI Power Management Event (PME#). Shared by multiple eSPI." />
      <field name="WAKE_B" bit="10" size="1" desc="Read-only. Reset: 1. 0=No effect. 1=Wake the Host. To wake the Host from Slave[x] on any evernt (WAKE#)." />
      <!-- Bit 9 reserved. -->
      <field name="OOB_RST_ACK" bit="8" size="1" desc="Read-only. Reset: 0. 0=OOB_RST_ACK not acknowledged. 1=OOB_RST_ACK acknowledged. OOB Reset acknowledge. Sent by the Slave to acknowledge the recieved OOB_RST_ACK virtual wire from the Host." />
      <field name="IRQ_STS" bit="5" size="3" desc="Read-only. Reset: 0h. IRQ status specified by IRQ selection." />
      <field name="IRQ_SEL" bit="0" size="5" desc="Read-write. Reset: 00h. This field determines the Slave[N] Received Virtual Wires Register bits[7:5] output's IRQ status." />
    </register>

    <!-- page 469 -->

    <register name="SLAVE0_RXVW_DATA" type="memory" device="ESPI" offset="0x000000A0" size="4" desc="FCH::ITF::ESPI::SLAVE0_RXVW_DATA. Read-only. Reset: 0000_0000h.">
      <field name="GRP3" bit="24" size="8" desc="Read-only. Reset: 00h. Group3 Virtual Wire Data Register. When FCH::ITF::ESPI::SLAVE0_RXVW_MISC_CNTL[GRP3_EN] == 1, eSPI Master will check each received VW Index. If the received Index matches with FCH::ITF::ESPI::SLAVE0_RXVW_INDEX[GRP3], eSPI Master will update this field with the new received value." />
      <field name="GRP2" bit="16" size="8" desc="Read-only. Reset: 00h. Group2 Virtual Wire Data Register. When FCH::ITF::ESPI::SLAVE0_RXVW_MISC_CNTL[GRP2_EN] == 1, eSPI Master will check each received VW Index. If the received Index matches with FCH::ITF::ESPI::SLAVE0_RXVW_INDEX[GRP2], eSPI Master will update this field with the new received value." />
      <field name="GRP1" bit="8" size="8" desc="Read-only. Reset: 00h. Group1 Virtual Wire Data Register. When FCH::ITF::ESPI::SLAVE0_RXVW_MISC_CNTL[GRP1_EN] == 1, eSPI Master will check each received VW Index. If the received Index matches with FCH::ITF::ESPI::SLAVE0_RXVW_INDEX[GRP1], eSPI Master will update this field with the new received value." />
      <field name="GRP0" bit="0" size="8" desc="Read-only. Reset: 00h. Group0 Virtual Wire Data Register. When FCH::ITF::ESPI::SLAVE0_RXVW_MISC_CNTL[GRP0_EN] == 1, eSPI Master will check each received VW Index. If the received Index matches with FCH::ITF::ESPI::SLAVE0_RXVW_INDEX[GRP0], eSPI Master will update this field with the new received value." />
    </register>
    <register name="SLAVE0_RXVW_INDEX" type="memory" device="ESPI" offset="0x000000A4" size="4" desc="FCH::ITF::ESPI::SLAVE0_RXVW_INDEX. Read-write. Reset: 0000_0000h.">
      <field name="GRP3" bit="24" size="8" desc="Read-write. Reset: 00h. Group3 Virtual Wire Index selection." />
      <field name="GRP2" bit="16" size="8" desc="Read-write. Reset: 00h. Group2 Virtual Wire Index selection." />
      <field name="GRP1" bit="8" size="8" desc="Read-write. Reset: 00h. Group1 Virtual Wire Index selection." />
      <field name="GRP0" bit="0" size="8" desc="Read-write. Reset: 00h. Group0 Virtual Wire Index selection." />
    </register>
    <register name="SLAVE0_RXVW_MISC_CNTL" type="memory" device="ESPI" offset="0x000000A8" size="4" desc="FCH::ITF::ESPI::SLAVE0_RXVW_MISC_CNTL. Read-write. Reset: 0000_0000h.">
      <field name="IRQ23_MASK" bit="31" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ23 will be sent to the ACPI. 1=Masked: IRQ23 will not be sent to the ACPI. When set, IRQ23 received from a Virtual Wire packet will be masked, and eSPI_IRQ23 will not be sent to the ACPI." />
      <field name="IRQ22_MASK" bit="30" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ22 will be sent to the ACPI. 1=Masked: IRQ22 will not be sent to the ACPI. When set, IRQ22 received from a Virtual Wire packet will be masked, and eSPI_IRQ22 will not be sent to the ACPI." />
      <field name="IRQ21_MASK" bit="29" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ21 will be sent to the ACPI. 1=Masked: IRQ21 will not be sent to the ACPI. When set, IRQ21 received from a Virtual Wire packet will be masked, and eSPI_IRQ21 will not be sent to the ACPI." />
      <field name="IRQ20_MASK" bit="28" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ20 will be sent to the ACPI. 1=Masked: IRQ20 will not be sent to the ACPI. When set, IRQ20 received from a Virtual Wire packet will be masked, and eSPI_IRQ20 will not be sent to the ACPI." />
      <field name="IRQ19_MASK" bit="27" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ19 will be sent to the ACPI. 1=Masked: IRQ19 will not be sent to the ACPI. When set, IRQ19 received from a Virtual Wire packet will be masked, and eSPI_IRQ19 will not be sent to the ACPI." />
      <field name="IRQ18_MASK" bit="26" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ18 will be sent to the ACPI. 1=Masked: IRQ18 will not be sent to the ACPI. When set, IRQ18 received from a Virtual Wire packet will be masked, and eSPI_IRQ18 will not be sent to the ACPI." />
      <field name="IRQ17_MASK" bit="25" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ17 will be sent to the ACPI. 1=Masked: IRQ17 will not be sent to the ACPI. When set, IRQ17 received from a Virtual Wire packet will be masked, and eSPI_IRQ17 will   not be sent to the ACPI." />
      <field name="IRQ16_MASK" bit="24" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ16 will be sent to the ACPI. 1=Masked: IRQ16 will not be sent to the ACPI. When set, IRQ16 received from a Virtual Wire packet will be masked, and eSPI_IRQ16 will not be sent to the ACPI." />
      <field name="IRQ15_MASK" bit="23" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ15 will be sent to the ACPI. 1=Masked: IRQ15 will not be sent to the ACPI. When set, IRQ15 received from a Virtual Wire packet will be masked, and eSPI_IRQ15 will not be sent to the ACPI." />
      <field name="IRQ14_MASK" bit="22" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ14 will be sent to the ACPI. 1=Masked: IRQ14 will not be sent to the ACPI. When set, IRQ14 received from a Virtual Wire packet will be masked, and eSPI_IRQ14 will not be sent to the ACPI." />
      <field name="IRQ13_MASK" bit="21" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ13 will be sent to the ACPI. 1=Masked: IRQ13 will not be sent to the ACPI. When set, IRQ13 received from a Virtual Wire packet will be masked, and eSPI_IRQ13 will not be sent to the ACPI." />
      <field name="IRQ12_MASK" bit="20" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ12 will be sent to the ACPI. 1=Masked: IRQ12 will not be sent to the ACPI. When set, IRQ12 received from a Virtual Wire packet will be masked, and eSPI_IRQ12 will not be sent to the ACPI." />
      <field name="IRQ11_MASK" bit="19" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ11 will be sent to the ACPI. 1=Masked: IRQ11 will not be sent to the ACPI. When set, IRQ11 received from a Virtual Wire packet will be masked, and eSPI_IRQ11 will not be sent to the ACPI." />
      <field name="IRQ10_MASK" bit="18" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ10 will be sent to the ACPI. 1=Masked: IRQ10 will not be sent to the ACPI. When set, IRQ10 received from a Virtual Wire packet will be masked, and eSPI_IRQ10 will not be sent to the ACPI." />
      <field name="IRQ9_MASK" bit="17" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ9 will be sent to the ACPI. 1=Masked: IRQ9 will not be sent to the ACPI. When set, IRQ9 received from a Virtual Wire packet will be masked, and eSPI_IRQ9 will not be sent to the ACPI." />
      <field name="IRQ8_MASK" bit="16" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ8 will be sent to the ACPI. 1=Masked: IRQ8 will not be sent to the ACPI. When set, IRQ8 received from a Virtual Wire packet will be masked, and eSPI_IRQ8 will not be sent to the ACPI." />
      <field name="IRQ7_MASK" bit="15" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ7 will be sent to the ACPI. 1=Masked: IRQ7 will not be sent to the ACPI. When set, IRQ7 received from a Virtual Wire packet will be masked, and eSPI_IRQ7 will not be sent to the ACPI." />
      <field name="IRQ6_MASK" bit="14" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ6 will be sent to the ACPI. 1=Masked: IRQ6 will not be sent to the ACPI. When set, IRQ6 received from a Virtual Wire packet will be masked, and eSPI_IRQ6 will not be sent to the ACPI." />
      <field name="IRQ5_MASK" bit="13" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ5 will be sent to the ACPI. 1=Masked: IRQ5 will not be sent to the ACPI. When set, IRQ5 received from a Virtual Wire packet will be masked, and eSPI_IRQ5 will not be sent to the ACPI." />
      <field name="IRQ4_MASK" bit="12" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ4 will be sent to the ACPI. 1=Masked: IRQ4 will not be sent to the ACPI. When set, IRQ4 received from a Virtual Wire packet will be masked, and eSPI_IRQ4 will not be sent to the ACPI." />
      <field name="IRQ3_MASK" bit="11" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ3 will be sent to the ACPI. 1=Masked: IRQ3 will not be sent to the ACPI. When set, IRQ3 received from a Virtual Wire packet will be masked, and eSPI_IRQ3 will not be sent to the ACPI." />
      <field name="IRQ2_MASK" bit="10" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ2 will be sent to the ACPI. 1=Masked: IRQ2 will not be sent to the ACPI. When set, IRQ2 received from a Virtual Wire packet will be masked, and eSPI_IRQ2 will not be sent to the ACPI." />
      <field name="IRQ1_MASK" bit="9" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ1 will be sent to the ACPI. 1=Masked: IRQ1 will not be sent to the ACPI. When set, IRQ1 received from a Virtual Wire packet will be masked, and eSPI_IRQ1 will not be sent to the ACPI." />
      <field name="IRQ0_MASK" bit="8" size="1" desc="Read-write. Reset: 0. 0=Unmasked: IRQ0 will be sent to the ACPI. 1=Masked: IRQ0 will not be sent to the ACPI. When set, IRQ0 received from a Virtual Wire packet will be masked, and eSPI_IRQ0 will not   be sent to the ACPI." />
      <!-- Bits 7:5 reserved. -->
      <field name="SUS_STAT_VWEN" bit="4" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. SUS_STAT# enable. Hardware sends Virtual Wire packet when SUS_STAT# changes." />
      <field name="GRP3_EN" bit="3" size="1" desc="Read-write. Reset: 0. 0=Don't check the received Index. 1=Check the received Index. Group3 enable. When set, VW channel will check the received Index. If Index is same as FCH::ITF::ESPI::SLAVE0_RXVW_INDEX[GRP3]; VW will store the Data into FCH::ITF::ESPI::SLAVE0_RXVW_DATA[GRP3]." />
      <field name="GRP2_EN" bit="2" size="1" desc="Read-write. Reset: 0. 0=Don't check the received Index. 1=Check the received Index. Group2 enable. When set, VW channel will check the received Index. If Index is same as FCH::ITF::ESPI::SLAVE0_RXVW_INDEX[GRP2]; VW will store the Data into FCH::ITF::ESPI::SLAVE0_RXVW_DATA[GRP2]." />
      <field name="GRP1_EN" bit="1" size="1" desc="Read-write. Reset: 0. 0=Don't check the received Index. 1=Check the received Index. Group1 enable. When set, VW channel will check the received Index. If Index is same as FCH::ITF::ESPI::SLAVE0_RXVW_INDEX[GRP1]; VW will store the Data into FCH::ITF::ESPI::SLAVE0_RXVW_DATA[GRP1]." />
      <field name="GRP0_EN" bit="0" size="1" desc="Read-write. Reset: 0. 0=Don't check the received Index. 1=Check the received Index. Group0 enable. When set, VW channel will check the received Index. If Index is same as FCH::ITF::ESPI::SLAVE0_RXVW_INDEX[GRP0]; VW will store the Data into FCH::ITF::ESPI::SLAVE0_RXVW_DATA[GRP0]." />
    </register>

    <!-- page 471 -->

    <register name="SLAVE0_RXVW_POLARITY" type="memory" device="ESPI" offset="0x000000AC" size="4" desc="FCH::ITF::ESPI::SLAVE0_RXVW_POLARITY. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:24 reserved. -->
      <field name="IRQ23_POLARITY" bit="23" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ23 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ22_POLARITY" bit="22" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ22 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ21_POLARITY" bit="21" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ21 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ20_POLARITY" bit="20" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ20 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ19_POLARITY" bit="19" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ19 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ18_POLARITY" bit="18" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ18 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ17_POLARITY" bit="17" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ17 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit   must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ16_POLARITY" bit="16" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ16 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ15_POLARITY" bit="15" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ15 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ14_POLARITY" bit="14" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ14 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ13_POLARITY" bit="13" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ13 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ12_POLARITY" bit="12" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ12 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ11_POLARITY" bit="11" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ11 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ10_POLARITY" bit="10" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ10 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ9_POLARITY" bit="9" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ9 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ8_POLARITY" bit="8" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ8 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ7_POLARITY" bit="7" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ7 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ6_POLARITY" bit="6" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ6 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ5_POLARITY" bit="5" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ5 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ4_POLARITY" bit="4" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ4 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit  must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ3_POLARITY" bit="3" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ3 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ2_POLARITY" bit="2" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ2 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ1_POLARITY" bit="1" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ1 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
      <field name="IRQ0_POLARITY" bit="0" size="1" desc="Read-write. Reset: 0. 0=Invert VW IRQ data. 1=Don't invert VW IRQ packet data. If the Slave IRQ0 is low active level interrupt or high active edge interrupt, no need to invert VW IRQ data, this bit must be set. If the Slave IRQ is high active level interrupt or low active edge interrupt, it needs to invert VW IRQ data and this bit must be cleared." />
    </register>

    <!-- 9.2.10.1 Miscellaneous (MISC) Registers -->

    <!-- page 473 -->

    <register name="GPPClkCntrl" type="memory" device="MISC" offset="0x000" size="4" desc="GPPClkControl. Read-write. Reset: 0000_3FFFh.">
      <!-- Bits 31:14 reserved. -->
      <field name="GPP_CLK6_Clock_Request_mapping" bit="12" size="2" desc="Read-write. Reset: 3h. Description: GPP6 PCIE clock pins (GPP_CLK6P/GPP_CLK6N) output control by CLKREQ6# pin. GPP_CLK6P/GPP_CLK6N pins are powered off when FCH is strapped to use an external clock, and powered on when FCH is strapped to operate in integrated clock mode. When FCH is in integrated clock mode, GPP6 PCIE clock can be powered off according to the CLK_REQ mapping table below, and the selected CLK_REQ6# input can power off the GPP6 PCIE clock output pins if it is asserted." />
      <field name="GPP_CLK5_Clock_Request_mapping" bit="10" size="2" desc="Read-write. Reset: 3h. Description: GPP5 PCIE clock pins (GPP_CLK5P/GPP_CLK5N) output control by CLKREQ5# pin. GPP_CLK5P/GPP_CLK5N pins are powered off when FCH is strapped to use an external clock, and powered on when FCH is strapped to operate in integrated clock mode. When FCH is in integrated clock mode, GPP5 PCIE   clock can be powered off according to the CLK_REQ mapping table below, and the selected CLK_REQ5# input can power off the GPP5 PCIE clock output pins if it is asserted." />
      <field name="GPP_CLK3_Clock_Request_mapping" bit="8" size="2" desc="Read-write. Reset: 3h. GPP3 PCIE clock pins (GPP_CLK3P/GPP_CLK3N) output control by CLKREQ3# pin. GPP_CLK3P/GPP_CLK3N pins are powered off when FCH is strapped to use an external clock, and powered on when FCH is strapped to operate in integrated clock mode. When FCH is in integrated clock mode, GPP3 PCIE clock can be powered off according to the CLK_REQ mapping table below, and the selected CLK_REQ3# input can power off the GPP3 PCIE clock output pins if it is asserted." />
      <field name="GPP_CLK2_Clock_Request_mapping" bit="6" size="2" desc="Read-write. Reset: 3h. GPP2 PCIE clock pins (GPP_CLK2P/GPP_CLK2N) output control by CLKREQ2# pin. GPP_CLK2P/GPP_CLK2N pins are powered off when FCH is strapped to use an external clock, and powered on when FCH is strapped to operate in integrated clock mode. When FCH is in integrated clock mode, GPP2 PCIE clock can be powered off according to the CLK_REQ mapping table below, and the selected CLK_REQ2# input can power off the GPP2 PCIE clock output pins if it is asserted." />
      <field name="GPP_CLK4_Clock_Request_mapping" bit="4" size="2" desc="Read-write. Reset: 3h. Description: GPP4 PCIE clock pins (GPP_CLK4P/GPP_CLK4N) output control by CLKREQ4# pin. GPP_CLK4P/GPP_CLK4N pins are powered off when FCH is strapped to use an external clock, and powered on when FCH is strapped to operate in integrated clock mode. When FCH is in the integrated clock mode, GPP4 PCIE clock can be powered off according to the CLK_REQ mapping table below and the selected CLK_REQ4# input can power off the GPP4 PCIE clock output pins if it is asserted." />
      <field name="GPP_CLK1_Clock_Request_mapping" bit="2" size="2" desc="Read-write. Reset: 3h. GPP1 PCIE clock pins (GPP_CLK1P/GPP_CLK1N) output control by CLKREQ0# pin. GPP_CLK1P/GPP_CLK1N pins are powered off when FCH is strapped to use an external clock, and powered on when FCH is strapped to operate in integrated clock mode. When FCH is in integrated clock mode, GPP1 PCIE clock can be powered off according to the CLK_REQ mapping table below, and the selected CLK_REQ1# input can power off the GPP0 PCIE clock output pins if it is asserted.  " />
      <field name="GPP_CLK0_Clock_Request_mapping" bit="0" size="2" desc="Read-write. Reset: 3h. GPP0 PCIE clock pins (GPP_CLK0P/GPP_CLK0N) output control by CLKREQ0# pin. GPP_CLK0P/GPP_CLK0N pins are powered off when FCH is strapped to use an external clock, and powered on when FCH is strapped to operate in integrated clock mode. When FCH is in integrated clock mode, GPP0 PCIE clock can be powered off according to the CLK_REQ mapping table below, and the selected CLK_REQ0# input can power off the GPP0 PCIE clock output pins if it is asserted." />
    </register>

    <!-- page 475 -->

    <register name="ClkOutCntrl" type="memory" device="MISC" offset="0x004" size="4" desc="ClkOutputCntrl. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="CGPllCfg1" type="memory" device="MISC" offset="0x008" size="4" desc="CGPLLConfig1. Read-write. Reset: 0000_0000h.">
      <field name="XTAL_REFCLK2X_CLKEN" bit="31" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. REFCLK2X clock enable/disable." />
      <field name="XTAL_CLKGEN_S5_CLKEN" bit="30" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. CLKGEN_S5 RefClk enable/disable." />
      <field name="XTAL_CLKGEN_S0_CLKEN" bit="29" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. CLKGEN_S0 RefClk enable/disable." />
      <!-- Bits 28:9 reserved. -->
      <field name="CG1_REFDIVSRC_Override" bit="8" size="1" desc="Read-write. Reset: 0. Description: CG1PLL Refclk Source Select Override. This bit is used to override CG1PLL REFCLK source select. By default, Master_die CG1PLL REFCLK source is from 48 MHz CG_XTAL and Slave_die is 100 MHz from external clock chip. " />
      <!-- Bits 7:5 reserved. -->
      <field name="RefClk_Source_Switch_Mode" bit="4" size="1" desc="Read-write. Reset: 0. 0=Need to apply a PllRstB for switching different REFCLK source. 1=Switch REFCLK source on-the-fly. For PCIe®/USB3/SATA/UFS/SSIC/GBE/DPLL REFCLK source. It can be from either CG_XTAL/CG_PLL generated or external reference source." />
      <!-- Bits 3:1 reserved. -->
      <field name="CG1PLL_SpreadSpectrumEnable" bit="0" size="1" desc="Read-write. Reset: 0. 0=Disable Spread Spectrum. 1=Enable CG1_PLL Spread Spectrum." />
    </register>

    <!-- page 476 -->

    <register name="CGPllCfg2" type="memory" device="MISC" offset="0x00C" size="4" desc="CGPLLConfig2. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="CGPllCfg3" type="memory" device="MISC" offset="0x010" size="4" desc="CGPLLConfig3. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:30 reserved. -->
      <field name="CG1PLL_fracn_en_Override" bit="29" size="1" desc="Read-write. Reset: 0. Used with CG1PLL frac-N and SSC clocking only." />
      <!-- Bits 28:13 reserved. -->
      <field name="CG1PLL_fcw0_int_Override" bit="4" size="9" desc="Read-write. Reset: 000h. CG1PLL Override: Integer portion of Frequency Control Word0 (feedback divisor0)." />
      <!-- Bits 3:2 reserved. -->
      <field name="CG1PLL_refclk_div_Override" bit="0" size="2" desc="Read-write. Reset: 0h. CG1PLL Override: Reference clock divisor." />
    </register>
    <register name="CGPllCfg4" type="memory" device="MISC" offset="0x014" size="4" desc="CGPLLConfig4. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:24 reserved. -->
      <field name="CG1PLL_fcw1_frac_Override" bit="8" size="16" desc="Read-write. Reset: 0000h. CG1PLL Override: Fractional portion of Frequency Control Word1 (feedback divisor1). Intended to be used with frequency ramping. Also used to step PLL frequency and phase for DFT." />
      <!-- Bits 7:0 reserved. -->
    </register>
    <register name="CGPllCfg5" type="memory" device="MISC" offset="0x018" size="4" desc="CGPLLConfig5. Read-write. Reset: 0000_0000h.">
      <field name="CG1PLL_fcw_slew_frac_Override" bit="16" size="16" desc="Read-write. Reset: 0000h. Description: CG1PLL Override: Sets SSC freq ramp rate. Set fractional change in programmed frequency per REFCLK cycle. e.g., 0.5% downspread SSC at 33.3 KHz and FBDIV=80. FCW_slewrate_frac = (2^16) * 0.00485 * 80 / (15us / 10ns) = 17 Need 31.5kHz and -0.375%." />
      <!-- Bits 15:0 reserved. -->
    </register>

    <!-- page 477 -->

    <register name="CGPllCfg6" type="memory" device="MISC" offset="0x01C" size="4" desc="CGPLLConfig6. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:17 reserved. -->
      <field name="CG1PLL_gp_coarse_mant_Override" bit="13" size="4" desc="Read-write. Reset: 0h. CG1PLL Override: Coarse proportional path FP multiply mantissa." />
      <!-- Bits 12:0 reserved. -->
    </register>
    <register name="ClkDrvStr1" type="memory" device="MISC" offset="0x024" size="4" desc="ClkDrvStr1. Read-write. Reset: 0000_0249h.">
      <!-- Bits 31:12 reserved. -->
      <field name="GppClk3_ClockBufferDrivingStrengthControl" bit="9" size="3" desc="Read-write. Reset: 1h. Drive Strength control for GPP_CLK_3 differential Clock Buffers. Drive strength addition/subtraction relative to IMP_CTRL[4:0]. Default: 3'b001." />
      <field name="GppClk2_ClockBufferDrivingStrengthControl" bit="6" size="3" desc="Read-write. Reset: 1h. Drive Strength control for GPP_CLK_2 differential Clock Buffers. Drive strength addition/subtraction relative to IMP_CTRL[4:0]. Default: 3'b001." />
      <field name="GppClk1_ClockBufferDrivingStrengthControl" bit="3" size="3" desc="Read-write. Reset: 1h. Drive Strength control for GPP_CLK_1 differential Clock Buffers. Drive strength addition/subtraction relative to IMP_CTRL[4:0]." />
      <field name="GppClk0_ClockBufferDrivingStrengthControl" bit="0" size="3" desc="Read-write. Reset: 1h. Drive Strength control for GPP_CLK_0 differential Clock Buffers. Drive strength addition/subtraction relative to IMP_CTRL[4:0]." />
    </register>

    <!-- page 478 -->

    <register name="ClkGatedCntl" type="memory" device="MISC" offset="0x02C" size="4" desc="ClkGatedCntl. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:18 reserved. -->
      <field name="BlinkClkGateOffEn" bit="17" size="1" desc="Read-write. Reset: 0. 0=Disable B-Link Clock Gate Off function. 1=Enable B-Link Clock Gate Off function. B-Link Clock Gate-Off Enable. Internal B-Link clock has two clock trees: one is a free running clock and the other is a gated clock. When all controllers agree to stop the gated B-Link clock and this bit is set, clock gating logic gates off the clock tree from clock root." />
      <field name="AlinkClkGateOffEn" bit="16" size="1" desc="Read-write. Reset: 0. 0=Disable A-Link Clock Gate-Off function. 1=Enable A-Link Clock Gate-Off function. A-Link Clock Gate-Off Enable. Internal A-Link clock has two clock trees: one is a free- running clock and the other is a gated clock. When all controllers agree to stop the gated A-Link clock and this bit is set, clock gating logic gates off the clock tree from clock root." />
      <!-- Bits 15:0 reserved. -->
    </register>
    <register name="CGPllCfg8" type="memory" device="MISC" offset="0x034" size="4" desc="CGPLLConfig8. Read-write. Reset: 0000_0000h.">
      <field name="CG1PLL_fcw1_int_Override" bit="23" size="9" desc="Read-write. Reset: 000h. CG1PLL Override: Integer portion of Frequency Control Word0. Intended to be used with frequency ramping." />
      <!-- Bits 22:0 reserved. -->
    </register>
    <register name="CGPllCfg10" type="memory" device="MISC" offset="0x03C" size="4" desc="CGPLLConfig10. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="MiscClkCntl1" type="memory" device="MISC" offset="0x040" size="4" desc="MiscClkCntl1. Read-write. Reset: 0000_4004h.">
      <!-- Bit 31 reserved. -->
      <field name="CG1_cfg_update_req" bit="30" size="1" desc="Read-write. Reset: 0. Setting this bit requests CG1_PLL to load spread related value into CG1_PLL. The bit is cleared by hardware after the request is sent to CG1_PLL." />
      <!-- Bits 29:26 reserved. -->
      <field name="CG1_FBDIV_LoadEn" bit="25" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Enable loading CG1_PLL FBDIV value form register." />
      <!-- Bits 24:20 reserved. -->
      <field name="USB31_CLK_Source" bit="19" size="1" desc="Read-write. Reset: 0. 0=343 MHz. 1=400 MHz. Description: USB31 Host Clock Source (in mission mode). USB31 Host Clock can be 400 MHz or 343 MHz. NOTE: In scan mode, there is a TDR bit that can make the selection. TDR default is 0 to select 400 MHz output." />
      <!-- Bit 18 reserved. -->
      <field name="USB3_Refclk_Drvier_PWDN" bit="17" size="1" desc="Read-write. Reset: 0. 1=USB3 REFCLK Driver is turned off in S5/S3 state. USB3 REFCLK Driver (differential) Power-Down in S3/S5." />
      <!-- Bits 16:15 reserved. -->
      <field name="OscClkSwitchEn" bit="14" size="1" desc="Read-write. Reset: 1. 0=OSC is 12 MHz (48 MHz CG_XTAL divided by 4). 1=OSC is average 14.318 MHz. When this bit is set, the FCH uses the 48 MHz CG_XTAL to generate the average 14 MHz  clock as OSC." />
      <!-- Bits 13:12 reserved. -->
      <field name="AZ_48MCLK_PWDN" bit="11" size="1" desc="Read-write. Reset: 0. 0=AZ 48 MHz Clock output driver is enabled. 1= AZ 48 MHz Clock output driver is disabled. AZ 48 MHz Clock Output Driver PWDN. FCH provides 48 MHz clock for Azalia (AZ) ACP." />
      <field name="The48MXtal_S0i3_PWDN_En" bit="10" size="1" desc="Read-write. Reset: 0. 0=Don't enable CG XTAL pad power down for SOi3. 1=Enable powering down CG XTAL pad in S0i3 state. CG 48 MHz XTAL Pad power down enable when in S0i3 state." />
      <field name="The48MXtal_S5_PWDN_En" bit="9" size="1" desc="Read-write. Reset: 0. 0=Don't enable CG XTAL pad power down for S5. 1=Enable to power down CG XTAL pad in S5 state. CG 48 MHz XTAL Pad power down enable when in S5 state." />
      <field name="The48MXtal_S3_PWDN_En" bit="8" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Description: When XTAL_PAD gets powered down, 48 MHz clock is off. (USB3 wake-up clock, ACP 48 MHz clock, and CGPLL REFCLK are from CG_XTAL directly). CG 48 MHz XTAL Pad power down is enabled when in S3 state, and CG XTAL pad can be powered off in following conditions. 1. S3 State with setting of FCH::MISC::MiscClkCntl1[8] == 1. 2. S5 State with setting of FCH::MISC::MiscClkCntl1[9] == 1. 3. S0i3 State (connected standby state) with setting of FCH::MISC::MiscClkCntl1[10] == 1." />
      <!-- Bits 7:3 reserved. -->
      <field name="BP_X48M0_Output_Enable" bit="2" size="1" desc="Read-write. Reset: 1. BP_X48M0 Clock Output Enable. This is S0 type clock and is OFF in sleep state. When this bit is set, 48 MHz clock is On regardless of S0A3. Programming this bit to 0 turns off the clock when in S0 state." />
      <field name="CoreSpeedMode" bit="1" size="1" desc="Read-write. Reset: 0. 0=Full speed B-Link clock. 1=Slow speed B-Link clock. Slow down Internal Core Clock (B-Link clock) for power saving." />
      <field name="BP_X48M0_OutputEn_S0i3" bit="0" size="1" desc="Read-write. Reset: 0. Description: BP_X48M0 Clock Output Enable at S0i3 state. This is S0 type clock and is Off in sleep state. If a platform does not use this clock, it can be disabled by programming FCH::MISC::MiscClkCntl1[BP_X48M0_Output_Enable] = 0. If a platform use this clock, but would like this clock always running at S0 regardless S0i3, then program BP_X48M0_Output_En_SOi3 = 1. If a platform uses this clock and would like to disable this clock when at S0i3 state, then program BP_X48M0_Output_En_SOi3 = 0 (default)." />
    </register>

    <!-- page 479 -->

    <register name="MiscClkCntl2" type="memory" device="MISC" offset="0x044" size="4" desc="MiscClkCntl2. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="MiscClkCntl3" type="memory" device="MISC" offset="0x048" size="4" desc="MiscClkCntl3. Read-write. Reset: 0C60_0000h.">
      <!-- Bit 31 reserved. -->
      <field name="GPP_CLK5_Driver_Impedance_Control" bit="26" size="5" desc="Read-write. Reset: 03h. GPP_CLK5 Driver Impedance Control. Driver impedance control. Controls the number of slices to be turned on." />
      <field name="GPP_CLK4_Driver_Impedance_Control" bit="21" size="5" desc="Read-write. Reset: 03h. GPP_CLK4 Driver Impedance Control. Driver impedance control. Controls the number of slices to be turned on." />
      <!-- Bits 20:0 reserved. -->
    </register>

    <!-- page 480 -->

    <register name="MiscClkCntl4" type="memory" device="MISC" offset="0x04C" size="4" desc="MiscClkCntl4. Read-write. Reset: 0000_0000h.">
      <field name="LowPowerDisplay400MClkEnB" bit="31" size="1" desc="Read-write. Reset: 0. 0=Enable low power display 400 MHz clock output. 1=Disable. Non-sticky bit." />
      <field name="LowPowerDisplay300MClkEnB" bit="30" size="1" desc="Read-write. Reset: 0. 0=Enable low power display 300 MHz clock output. 1=Disable. Non-sticky bit." />
      <!-- Bits 29:0 reserved. -->
    </register>
    <register name="IdleCntrl" type="memory" device="MISC" offset="0x060" size="4" desc="IdleCntrl. Read-write.">
      <field name="IdleCount" bit="24" size="8" desc="Read-write. Reset: XXh. This returns the idle count from the latest monitored period." />
      <!-- Bits 23:0 reserved. -->
    </register>
    <register name="MemPwrSavCntrl" type="memory" device="MISC" offset="0x068" size="4" desc="Memory Power Saving Control. Read-write. Reset: 0000_0006h.">
      <!-- Bits 31:3 reserved. -->
      <field name="ABBypassMemDsd" bit="2" size="1" desc="Read-write. Reset: 1. 0=Enable memory deep sleep and shutdown features. 1=Disable memory deep sleep and shutdown. AB memory BypassMemdsd control." />
      <field name="SBGBypassMemDsd" bit="1" size="1" desc="Read-write. Reset: 1. 0=Enable memory deep sleep and shutdown features. 1=Disable memory deep sleep and shutdown. SBG memory BypassMemdsd control." />
      <!-- Bit 0 reserved. -->
    </register>
    <register name="OscFreqCtr" type="memory" device="MISC" offset="0x070" size="4" desc="OscFreqCounter. Reset: 0000_0000h.">
      <field name="CountEnable" bit="31" size="1" desc="Read-write. Reset: 0. 1=Enable the internal counter to count the number of oscellator (OSC) clocks. When software is not using this function, it should always set it to 0 to conserve power." />
      <field name="CountIsValid" bit="30" size="1" desc="Read-only. Reset: 0. 1=OscCountPerSec is valid. Software should always wait for this bit to be set before reading OscCountPerSec." />
      <!-- Bits 29:28 reserved. -->
      <field name="OscCountPerSec" bit="0" size="28" desc="Read-write. Reset: 000_0000h. Number of OSC clocks per 1 second. Whenever [CountEnable] is set, an internal counter starts counting the number of OSC clocks per second and records the count value here." />
    </register>
    <register name="PostCode" type="memory" device="MISC" offset="0x078" size="4" desc="PostCode. Read-only. Reset: 0000_0000h.">
      <field name="PostCode[31:0]" bit="0" size="32" desc="Read-only. Reset: 0000_0000h. BIOS' 32-bit writes to FCH::MISC::PostCode go to this internal 32-bit PostCode Register. Reads from FCH::MISC::PostCode return PostCode[7:0]." />
    </register>

    <!-- page 481 -->

    <register name="PostCodeStack" type="memory" device="MISC" offset="0x07C" size="4" desc="PostCodeStack. Read-only. Reset: FFFF_FFFFh.">
      <field name="PostCodeStack[31:0]" bit="0" size="32" desc="Read-only. Reset: FFFF_FFFFh. 32 deep post code STACK Read out window. Reads get   32 bits of PostCode. Unused bytes return 0s. If Write is full, the oldest data is lost and the new data fills in. When software Reads out of the stack, it Reads from new data to old data and doesn't get flushed. Extra Reads produce duplicate data." />
    </register>
    <register name="StrapStat" type="memory" device="MISC" offset="0x080" size="4" desc="StrapStatus. Read-only.">
      <!-- Bits 31:18 reserved. -->
      <field name="ClkGenStrap" bit="17" size="1" desc="Read-only. Reset: X. 0=External clocking mode; Uses 100 MHz differential spread clock as the reference clock. 1=Internal clocking mode; Uses 48 MHz crystal clock as the reference clock." />
      <!-- Bits 16:12 reserved. -->
      <field name="ShortResetStrap" bit="11" size="1" desc="Read-only. Reset: 0. Generate short reset." />
      <!-- Bits 10:2 reserved. -->
      <field name="UseLpcRomStrap" bit="1" size="1" desc="Read-only. Reset: X. 0=SPI ROM strap. 1=LPC ROM strap. Use LPC ROM." />
      <!-- Bit 0 reserved. -->
    </register>
    <register name="PostCodeControl" type="memory" device="MISC" offset="0x088" size="4" desc="PostCode Control. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:1 reserved. -->
      <field name="Post_rd_ptr_rst" bit="0" size="1" desc="Read-write. Reset: 0. Software reset bit for Read pointer. When the new turn of Read is needed, set this bit and the Read pointer goes back for the next cycle's Read." />
    </register>
    <register name="AutoTransactionAllowEC" type="memory" device="MISC" offset="0x090" size="4" desc="AutoTransaction/Allow EC. Reset: 0000_0000h.">
      <!-- Bits 31:10 reserved. -->
      <field name="DisableAuto" bit="9" size="1" desc="Read,Write-1-only. Reset: 0. 1=The entire Auto Transaction logic is disabled. Once this bit is set, it cannot be cleared except by system reset." />
      <field name="AllowECToAutoTransactEn" bit="8" size="1" desc="Read-write. Reset: 0. 0=IMC cannot write to any of the registers (FCH::MISC::AutoTransactionAllowEC, FCH::MISC::AutoAddrLo, FCH::MISC::AutoAddrHi, FCH::MISC::AutoData) in the Auto Transaction Generation logic. 1=IMC can change any of these registers. Only BIOS can change this bit." />
      <field name="TransactionType" bit="4" size="4" desc="Read-write. Reset: 0h. PCI Command type used for this auto transaction. See the PCI specification for PCI command types." />
      <field name="ByteCount" bit="2" size="2" desc="Read-write. Reset: 0h." />
      <field name="DualAddr" bit="1" size="1" desc="Read-write. Reset: 0. 0=Use single address cycle. 1=Use dual address cycle." />
      <field name="AutoExecute" bit="0" size="1" desc="Read-write. Reset: 0. 1=Causes the hardware to execute the transaction defined by bits[7:1]. Writing 1 to this bit causes the hardware to execute the transaction defined by bits[7:1]. Once it is written, this bit stays set until the transaction is completed, in which case it returns to 0." />
    </register>

    <!-- page 482 -->

    <register name="AutoAddrLo" type="memory" device="MISC" offset="0x094" size="4" desc="AutoAddrLow. Read-write. Reset: 0000_0000h.">
      <field name="AutoAddrLow" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Low address to be used by the FCH::MISC::AutoTransactionAllowEC[AutoExecute] operation. See also FCH::MISC::AutoAddrHi[AutoAddrHigh]." />
    </register>
    <register name="AutoAddrHi" type="memory" device="MISC" offset="0x098" size="4" desc="AutoAddrHigh. Read-write. Reset: 0000_0000h.">
      <field name="AutoAddrHigh" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. High address to be used by the FCH::MISC::AutoTransactionAllowEC[AutoExecute] operation. This register is only applicable when FCH::MISC::AutoTransactionAllowEC[DualAddr] == 1. AutoAddr = {AutoAddrHigh,FCH::MISC::AutoAddrLo[AutoAddrLow]}." />
    </register>
    <register name="AutoData" type="memory" device="MISC" offset="0x09C" size="4" desc="AutoData. Read-write. Reset: 0000_0000h.">
      <field name="AutoData" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. If FCH::MISC::AutoTransactionAllowEC[TransactionType] is Read, this register returns the Read data. If the FCH::MISC::AutoTransactionAllowEC[TransactionType] is a Write command, this register contains the Write data. NOTE: The byte is aligned accordingly." />
    </register>
    <register name="CGPLLCntrlreg1" type="memory" device="MISC" offset="0x0A0" size="4" desc="CGPLLCntrl Reg1. Read-write. Reset: 0000_0000h.">
      <!-- Bit 31 reserved. -->
      <field name="CG1PLL_kdco_ratio[7:0]" bit="23" size="8" desc="Read-write. Reset: 00h." />
      <!-- Bits 22:0 reserved. -->
    </register>
    <register name="CGPLLCntrlReg2" type="memory" device="MISC" offset="0x0A4" size="4" desc="CGPLLCntrl Reg2. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:22 reserved. -->
      <field name="CG1PLL_lock_timer_13_0_override" bit="8" size="14" desc="Read-write. Reset: 0000h. CG1PLL Override: Lock timer control." />
      <!-- Bits 7:0 reserved. -->
    </register>
    <register name="CGPLLCntrlReg3" type="memory" device="MISC" offset="0x0A8" size="4" desc="CGPLLCntrl Reg3. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>

    <!-- page 483 -->

    <register name="CGPLLCntrlReg4" type="memory" device="MISC" offset="0x0AC" size="4" desc="CGPLLCntrl Reg4. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:24 reserved. -->
      <field name="CPU_Refclk_Selection_Override" bit="22" size="2" desc="Read-write. Reset: 0h. Description: CPU REFCLK Selection Override (XOR)." />
      <field name="SMU_100M_Refclk_Selection" bit="20" size="2" desc="Read-write. Reset: 0h. SMU_100M REFCLK Selection." />
      <!-- Bits 19:8 reserved. -->
      <field name="PHY_A3_4_Refclk_Selection" bit="6" size="2" desc="Read-write. Reset: 0h. Description: PHY_A3_4 REFCLK Selection. NOTE: FCH::MISC::CGPLLCntrlReg8[EXT_GPP0_REFCLK_SEL] to select whether EXT_GPP0_SRC is from GPP0 external input or GPP0 external input with divide-by-2." />
      <field name="PHY_A2_Refclk_Selection" bit="4" size="2" desc="Read-write. Reset: 0h. Description: PHY_A2 REFCLK Selection. NOTE: FCH::MISC::CGPLLCntrlReg8[EXT_GPP0_REFCLK_SEL] to select whether EXT_GPP0_SRC is from GPP0 external input or GPP0 external input with divide-by-2." />
      <field name="PHY_A1_Refclk_Selection" bit="2" size="2" desc="Read-write. Reset: 0h. Description: PHY_A1 REFCLK Selection. NOTE: FCH::MISC::CGPLLCntrlReg8[EXT_GPP0_REFCLK_SEL] to select whether EXT_GPP0_SRC is from GPP0 external input or GPP0 external input with divide-by-2." />
      <field name="PHY_A0_Refclk_Selection" bit="0" size="2" desc="Read-write. Reset: 0h. Description: PHY_A0 REFCLK Selection. NOTE: FCH::MISC::CGPLLCntrlReg8[EXT_GPP0_REFCLK_SEL] to select whether EXT_GPP0_SRC is from GPP0 external input or GPP0 external input with divide-by-2." />
    </register>

    <!-- page 484 -->

    <register name="CGPLLCntrlReg8" type="memory" device="MISC" offset="0x0BC" size="4" desc="CGPLLCntrl Reg8. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:28 reserved. -->
      <field name="GPP5_Refclk_Selection" bit="26" size="2" desc="Read-write. Reset: 0h. GPP5 REFCLK selection." />
      <field name="GPP4_Refclk_Selection" bit="24" size="2" desc="Read-write. Reset: 0h. GPP4 REFCLK selection." />
      <field name="GPP3_Refclk_Selection" bit="22" size="2" desc="Read-write. Reset: 0h. GPP3 REFCLK selection. NOTE: FCH::MISC::CGPLLCntrlReg8[EXT_GPP0_REFCLK_SEL] to select EXT_GPP0_SRC either is from GPP0 external input or GPP0 external input with divide-by-2." />
      <field name="GPP2_Refclk_Selection" bit="20" size="2" desc="Read-write. Reset: 0h. GPP2 REFCLK selection. NOTE: FCH::MISC::CGPLLCntrlReg8[EXT_GPP0_REFCLK_SEL] to select EXT_GPP0_SRC either is from GPP0 external input or GPP0 external input with divide-by-2." />
      <field name="GPP1_Refclk_Selection" bit="18" size="2" desc="Read-write. Reset: 0h. GPP1 REFCLK selection. NOTE: FCH::MISC::CGPLLCntrlReg8[EXT_GPP0_REFCLK_SEL] to select EXT_GPP0_SRC either is from GPP0 external input or GPP0 external input with divide-by-2." />
      <field name="GPP0_Refclk_Selection" bit="16" size="2" desc="Read-write. Reset: 0h. GPP0 REFCLK selection." />
      <field name="EXT_BYPASSCLK_EN" bit="15" size="1" desc="Read-write. Reset: 0. 0=Enable. 1=Disable. EXT_BYPASSCLK_EN. Enable/Disable REF_BYPASSCLK external input thru GFX0." />
      <field name="CLK_CGPLL_EXT_PWDN" bit="14" size="1" desc="Read-write. Reset: 0. 0=Enable. 1=Disable. CLK_CGPLL_EXT_PWDN. Enable/Disable CGPLL external REFCLK source thru GPP0 input." />
      <field name="EXT_GPP0_REFCLK_SEL" bit="13" size="1" desc="Read-write. Reset: 0. 0=GPP0 external input. 1=GPP0 external input divided-by- 2. EXT_GPP0_REFCLK_SEL." />
      <!-- Bit 12 reserved. -->
      <field name="CPU_Refclk_Driver_PWDN" bit="11" size="1" desc="Read-write. Reset: 0. 0=Enable. 1=Disable. CPU REFCLK driver power down." />
      <field name="SMU_100M_Refclk_Driver_PWDN" bit="10" size="1" desc="Read-write. Reset: 0. 0=Enable. 1=Disable. SMU_100M REFCLK driver power down." />
      <!-- Bit 9 reserved. -->
      <field name="PHY_USB3_Refclk_Driver_PWDN" bit="8" size="1" desc="Read-write. Reset: 0. 0=Enable. 1=Disable. PHY_USB3 REFCLK driver power down in S0i3." />
      <!-- Bits 7:0 reserved. -->
    </register>

    <!-- page 485 -->

    <register name="IoTrapping0IoTrapping1" type="memory" device="MISC" offset="0x0C0" size="4" desc="IoTrapping0 IoTrapping1. Read-write. Reset: 0000_0000h.">
      <field name="IoTrappingAdr1" bit="16" size="16" desc="Read-write. Reset: 0000h. Specify the IO address 1, which causes an SMI event." />
      <field name="IoTrappingAdr0" bit="0" size="16" desc="Read-write. Reset: 0000h. Specify the IO address 0, which causes an SMI event." />
    </register>
    <register name="IoTrapping2IoTrapping3" type="memory" device="MISC" offset="0x0C4" size="4" desc="IoTrapping2 IoTrapping3. Read-write. Reset: 0000_0000h.">
      <field name="IoTrappingAdr3" bit="16" size="16" desc="Read-write. Reset: 0000h. Specify the IO address 3, which causes an SMI event." />
      <field name="IoTrappingAdr2" bit="0" size="16" desc="Read-write. Reset: 0000h. Specify the IO address 2, which causes an SMI event." />
    </register>
    <register name="CfgTrapping0" type="memory" device="MISC" offset="0x0C8" size="4" desc="CfgTrapping0. Read-write. Reset: 0000_0000h.">
      <field name="CfgTrappingAdr0" bit="2" size="30" desc="Read-write. Reset: 0000_0000h. Specify the configuration address 0, which causes an SMI event." />
      <!-- Bits 1:0 reserved. -->
    </register>
    <register name="SMITrappingRwRdOvr" type="memory" device="MISC" offset="0x0CC" size="4" desc="SMITrappingRwRdOvr. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:17 reserved. -->
      <field name="CfgTrappingRw0" bit="16" size="1" desc="Read-write. Reset: 0. 0=Trap on configuration Read access on the address specified in FCH::MISC::CfgTrapping0[CfgTrappingAdr0]. 1=Trap on configuration Write access on the address specified in   FCH::MISC::CfgTrapping0[CfgTrappingAdr0]." />
      <!-- Bits 15:13 reserved. -->
      <field name="MemTrappingRdOvr0" bit="12" size="1" desc="Read-write. Reset: 0. Set to 1 to force Read data to be replaced by FCH::MISC::MemRdOvrData0." />
      <!-- Bits 11:9 reserved. -->
      <field name="MemTrappingRw0" bit="8" size="1" desc="Read-write. Reset: 0. 0=Trap on memory Read access on the address specified in FCH::MISC::MemTrapping0[MemTrappingAdr0]. 1=Trap on memory Write access on the address specified in FCH::MISC::MemTrapping0[MemTrappingAdr0]." />
      <!-- Bits 7:4 reserved. -->
      <field name="IoTrappingRw3" bit="3" size="1" desc="Read-write. Reset: 0. 0=Trap on IO Read access on the address specified in FCH::MISC::IoTrapping2IoTrapping3[IoTrappingAdr3]. 1=Trap on IO Write access on the address specified in FCH::MISC::IoTrapping2IoTrapping3[IoTrappingAdr3]." />
      <field name="IoTrappingRw2" bit="2" size="1" desc="Read-write. Reset: 0. 0=Trap on IO Read access on the address specified in FCH::MISC::IoTrapping2IoTrapping3[IoTrappingAdr2]. 1=Trap on IO Write access on the address specified in FCH::MISC::IoTrapping2IoTrapping3[IoTrappingAdr2]." />
      <field name="IoTrappingRw1" bit="1" size="1" desc="Read-write. Reset: 0. 0=Trap on IO Read access on the address specified in FCH::MISC::IoTrapping0IoTrapping1[IoTrappingAdr1]. 1=Trap on IO Write access on the address specified in FCH::MISC::IoTrapping0IoTrapping1[IoTrappingAdr1]." />
      <field name="IoTrappingRw0" bit="0" size="1" desc="Read-write. Reset: 0. 0=Trap on IO Read access on the address specified in FCH::MISC::IoTrapping0IoTrapping1[IoTrappingAdr0]. 1=Trap on IO Write access on the address specified in FCH::MISC::IoTrapping0IoTrapping1[IoTrappingAdr0]." />
    </register>

    <!-- page 486 -->

    <register name="MemTrapping0" type="memory" device="MISC" offset="0x0D0" size="4" desc="MemTrapping0. Read-write. Reset: 0000_0000h.">
      <field name="MemTrappingAdr0" bit="2" size="30" desc="Read-write. Reset: 0000_0000h. Specify the 30-bit memory address 0 which causes an SMI even. Lowest 2 bits are ignored." />
      <!-- Bits 1:0 reserved. -->
    </register>
    <register name="MemRdOvrData0" type="memory" device="MISC" offset="0x0D4" size="4" desc="MemRdOvrData0. Read-write. Reset: 0000_0000h.">
      <field name="MemTrappingRData0" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. The 32-bit data is used as the return data when the memory Read trapping is enabled in FCH::MISC::MemTrapping0, with FCH::MISC::SMITrappingRwRdOvr[MemTrappingRdOvr0] == 1." />
    </register>
    <register name="I2C0_PadCtrl" type="memory" device="MISC" offset="0x0D8" size="4" desc="I2C0_PadCtrl. Read-write. Reset: 0000_0010h.">
      <!-- Bits 31:19 reserved. -->
      <field name="Spare1" bit="18" size="1" desc="Read-write. Reset: 0. Spare pins." />
      <field name="Spare0" bit="17" size="1" desc="Read-write. Reset: 0. Spare pins." />
      <field name="BiasCrtEn" bit="16" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Pbias should be on in Fast/Fast+. To save power, it can be turned off in I2C Standard Mode." />
      <field name="RSel1p1" bit="15" size="1" desc="Read-write. Reset: 0. 1=Increases resistance by 10% for all RC timers. When asserted, increases resistance by 10% for all RC timers." />
      <field name="RSel0p9" bit="14" size="1" desc="Read-write. Reset: 0. 1=Decreases resistance by 10% for all RC timers. When asserted, decreases resistance by 10% for all RC timers." />
      <field name="CSel1p1" bit="13" size="1" desc="Read-write. Reset: 0. 1=Increases capacitance by 10% for all RC timers. When asserted, increases  capacitance by 10% for all RC timers." />
      <field name="CSel0p9" bit="12" size="1" desc="Read-write. Reset: 0. 1=Decreases capacitance by 10% for all RC timers. When asserted, decreases capacitance by 10% for all RC timers." />
      <field name="SpikeRcSel" bit="11" size="1" desc="Read-write. Reset: 0. 0=50ns. 1=20ns. Select RC constant for I2C spike suppression." />
      <field name="SpikeRcEn" bit="10" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable RX spike suppression. Enable spike suppression." />
      <field name="Slewn" bit="9" size="1" desc="Read-write. Reset: 0. 0=Disabled. 1=Enabled. Enable changing strength of pre-driver for fall time compensation." />
      <field name="FallSlewSel" bit="7" size="2" desc="Read-write. Reset: 0h. Slew rate." />
      <field name="PdEn" bit="6" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Pull-down enable for DDCCLK (PADP)." />
      <field name="I2cRxSel" bit="4" size="2" desc="Read-write. Reset: 1h. I2C Receiver select." />
      <field name="NG" bit="0" size="4" desc="N Strength Control. Read-write. Reset: 0h. Init: BIOS,Ch. N Strength control. Software should program to 0Ch for normal drive strength." />
    </register>

    <!-- page 487 -->

    <register name="I2C1_PadCtrl" type="memory" device="MISC" offset="0x0DC" size="4" desc="I2C1_PadCtrl. Read-write. Reset: 0000_0010h.">
      <!-- Bits 31:19 reserved. -->
      <field name="Spare1" bit="18" size="1" desc="Read-write. Reset: 0. Spare pins." />
      <field name="Spare0" bit="17" size="1" desc="Read-write. Reset: 0. Spare pins." />
      <field name="BiasCrtEn" bit="16" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Pbias should be on in Fast/Fast+. To save power, it can be turned off in I2C Standard Mode." />
      <field name="RSel1p1" bit="15" size="1" desc="Read-write. Reset: 0. 1=Increases resistance by 10% for all RC timers. When asserted, increases resistance by 10% for all RC timers." />
      <field name="RSel0p9" bit="14" size="1" desc="Read-write. Reset: 0. 1=Decreases resistance by 10% for all RC timers. When asserted, decreases resistance by 10% for all RC timers." />
      <field name="CSel1p1" bit="13" size="1" desc="Read-write. Reset: 0. 1=Increases capacitance by 10% for all RC timers. When asserted, increases capacitance by 10% for all RC timers." />
      <field name="CSel0p9" bit="12" size="1" desc="Read-write. Reset: 0. 1=Decreases capacitance by 10% for all RC timers. When asserted, decreases capacitance by 10% for all RC timers." />
      <field name="SpikeRcSel" bit="11" size="1" desc="Read-write. Reset: 0. 0=50ns. 1=20ns. Select RC constant for I2C spike suppression." />
      <field name="SpikeRcEn" bit="10" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable RX spike suppression. Enable spike suppression." />
      <field name="Slewn" bit="9" size="1" desc="Read-write. Reset: 0. 0=Disabled. 1=Enabled. Enable changing strength of pre-driver for fall time compensation." />
      <field name="FallSlewSel" bit="7" size="2" desc="Read-write. Reset: 0h. Slew rate." />
      <field name="PdEn" bit="6" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Pull-down enable for DDCCLK (PADP)." />
      <field name="I2cRxSel" bit="4" size="2" desc="Read-write. Reset: 1h. I2C receiver select." />
      <field name="NG" bit="0" size="4" desc="N Strength Control. Read-write. Reset: 0h. Init: BIOS,Ch. N Strength Control. Software should program to 0Ch for normal drive strength." />
    </register>

    <!-- page 488 -->

    <register name="I2C2_PadCtrl" type="memory" device="MISC" offset="0x0E0" size="4" desc="I2C2_PadCtrl. Read-write. Reset: 0000_0010h.">
      <!-- Bits 31:19 reserved. -->
      <field name="Spare1" bit="18" size="1" desc="Read-write. Reset: 0. Spare pins." />
      <field name="Spare0" bit="17" size="1" desc="Read-write. Reset: 0. Spare pins." />
      <field name="BiasCrtEn" bit="16" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Pbias should be on in Fast/Fast+. To save power, it can be turned off in I2C Standard Mode." />
      <field name="RSel1p1" bit="15" size="1" desc="Read-write. Reset: 0. 1=Increases resistance by 10% for all RC timers. When asserted, increases resistance by 10% for all RC timers." />
      <field name="RSel0p9" bit="14" size="1" desc="Read-write. Reset: 0. 1=Decreases resistance by 10% for all RC timers. When asserted, decreases resistance by 10% for all RC timers." />
      <field name="CSel1p1" bit="13" size="1" desc="Read-write. Reset: 0. 1=Increases capacitance by 10% for all RC timers. When asserted, increases capacitance by 10% for all RC timers." />
      <field name="CSel0p9" bit="12" size="1" desc="Read-write. Reset: 0. 1=Decreases capacitance by 10% for all RC timers. When asserted, decreases capacitance by 10% for all RC timers." />
      <field name="SpikeRcSel" bit="11" size="1" desc="Read-write. Reset: 0. 0=50ns. 1=20ns. Select RC constant for I2C spike suppression." />
      <field name="SpikeRcEn" bit="10" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable RX spike suppression. Enable spike suppression." />
      <field name="Slewn" bit="9" size="1" desc="Read-write. Reset: 0. 0=Disabled. 1=Enabled. Enable changing strength of pre-driver for fall time compensation." />
      <field name="FallSlewSel" bit="7" size="2" desc="Read-write. Reset: 0h. Slew rate." />
      <field name="PdEn" bit="6" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Pull-down enable for DDCCLK (PADP)." />
      <field name="I2cRxSel" bit="4" size="2" desc="Read-write. Reset: 1h. I2C receiver select." />
      <field name="NG" bit="0" size="4" desc="N Strength Control. Read-write. Reset: 0h. Init: BIOS,Ch. N Strength Control. Software should program to 0Ch for normal drive strength." />
    </register>

    <!-- page 489 -->

    <register name="I2C3_PadCtrl" type="memory" device="MISC" offset="0x0E4" size="4" desc="I2C3_PadCtrl. Read-write. Reset: 0000_0010h.">
      <!-- Bits 31:19 reserved. -->
      <field name="Spare1" bit="18" size="1" desc="Read-write. Reset: 0. Spare pin." />
      <field name="Spare0" bit="17" size="1" desc="Read-write. Reset: 0. Spare pin." />
      <field name="BiasCrtEn" bit="16" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Pbias should be on in Fast/Fast+. To save power, it can be turned off in I2C Standard Mode." />
      <field name="RSel1p1" bit="15" size="1" desc="Read-write. Reset: 0. 1=Increases resistance by 10% for all RC timers. When asserted, increases resistance by 10% for all RC timers." />
      <field name="RSel0p9" bit="14" size="1" desc="Read-write. Reset: 0. 1=Decreases resistance by 10% for all RC timers. When asserted, decreases resistance by 10% for all RC timers." />
      <field name="CSel1p1" bit="13" size="1" desc="Read-write. Reset: 0. 1=Increases capacitance by 10% for all RC timers. When asserted, increases capacitance by 10% for all RC timers." />
      <field name="CSel0p9" bit="12" size="1" desc="Read-write. Reset: 0. 1=Decreases capacitance by 10% for all RC timers. When asserted, decreases capacitance by 10% for all RC timers." />
      <field name="SpikeRcSel" bit="11" size="1" desc="Read-write. Reset: 0. 0=50ns. 1=20ns. Select RC constant for I2C spike suppression." />
      <field name="SpikeRcEn" bit="10" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable RX spike suppression. Enable spike suppression." />
      <field name="Slewn" bit="9" size="1" desc="Read-write. Reset: 0. 0=Disabled. 1=Enabled. Enable changing strength of pre-driver for fall time compensation." />
      <field name="FallSlewSel" bit="7" size="2" desc="Read-write. Reset: 0h. Slew rate." />
      <field name="PdEn" bit="6" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Pull-down enable for DDCCLK (PADP)." />
      <field name="I2cRxSel" bit="4" size="2" desc="Read-write. Reset: 1h. I2C receiver select." />
      <field name="NG" bit="0" size="4" desc="N Strength Control. Read-write. Reset: 0h. Init: BIOS,Ch. N Strength Control. Software should program to 0Ch for normal drive strength." />
    </register>
    <register name="SataPortSts" type="memory" device="MISC" offset="0x0F0" size="4" desc="SataPortSts. Read-write.">
      <!-- Bits 31:26 reserved. -->
      <field name="SataPortSel" bit="24" size="2" desc="Read-write. Reset: 0h." />
      <!-- Bits 23:2 reserved. -->
      <field name="Port1Sts" bit="1" size="1" desc="Read-write. Reset: X. The selected status of Port 1. This status bit indicates the internal status of SATA port 1." />
      <field name="Port0Sts" bit="0" size="1" desc="Read-write. Reset: X. The selected status of Port 0. This status bit indicates the internal status of SATA port 0." />
    </register>

    <!-- page 490 -->

    <register name="ClkCntrlSts" type="memory" device="MISC" offset="0x0F4" size="4" desc="ClkCntrlSts. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="ClkGatingCntrl" type="memory" device="MISC" offset="0x0FC" size="4" desc="ClkGatingCntrl. Read-write. Reset: 0000_1FFFh.">
      <!-- Bits 31:13 reserved. -->
      <field name="WatchDogTimerBlkClkGatingDis" bit="12" size="1" desc="Read-write. Reset: 1. 0=The clock of the WatchDog Timer block can be stopped if not being accessed. 1=The clock of the WatchDog Timer block can't be stopped if not being accessed. Watchdog Timer block clock gating." />
      <field name="AcDcTmrBlkClkGatingDis" bit="11" size="1" desc="Read-write. Reset: 1. 0=The clock of the AcDc Timer block can be stopped if not being accessed. 1=The clock of the AcDc Timer block can't be stopped if not being accessed. AcDc Timer block clock gating." />
      <field name="BiosRamBlkClkGatingDis" bit="10" size="1" desc="Read-write. Reset: 1. 0=The clock of the BIOS RAM block can be stopped if not being accessed. 1=The clock of the BIOS RAM block can't be stopped if not being accessed. BIOS RAM block clock gating." />
      <field name="HwThrotBlkClkGatingDis" bit="9" size="1" desc="Read-write. Reset: 1. 0=The clock of the hardware throttling block can be stopped if not being accessed. 1=The clock of the hardware throttling block can't be stopped if not being accessed. Hardware throttling block clock gating." />
      <field name="CStateBlkClkGatingDis" bit="8" size="1" desc="Read-write. Reset: 1. 0=The clock of the C-State block can be stopped if not being accessed. 1=The clock of the C-State block can't be stopped if not being accessed. C-State block clock gating." />
      <field name="FusionCBlkClkGatingDis" bit="7" size="1" desc="Read-write. Reset: 1. 0=The clock of the FusionC block can be stopped if not being accessed. 1=The clock of the FusionC block can't be stopped if not being accessed. FusionC block clock gating." />
      <field name="OBFFBlkClkGatingDis" bit="6" size="1" desc="Read-write. Reset: 1. 0=The clock of the OBFF block can be stopped if not being accessed. 1=The clock of the OBFF block can't be stopped if not being accessed. OBFF block clock gating." />
      <field name="Smbus0ClkGatingDis" bit="5" size="1" desc="Read-write. Reset: 1. 0=The clock of the SMBUS0 block can be stopped if not being accessed. 1=The clock of the SMBUS0 block can't be stopped if not being accessed. SMBUS0 block clock gating." />
      <field name="VWClkGatingDis" bit="4" size="1" desc="Read-write. Reset: 1. 0=The clock of the Virtual Wire block can be stopped if not being accessed. 1=The clock of the Virtual Wire block can't be stopped if not being accessed. Virtual Wire block clock gating." />
      <field name="AoacRegBlkClkGatingDis" bit="3" size="1" desc="Read-write. Reset: 1. 0=The clock of the AOAC register block can be stopped if not being accessed. 1=The clock of the AOAC register block can't be stopped if not being accessed. Always On Always Connected register block clock gating." />
      <field name="Pmio2RegBlkClkGatingDis" bit="2" size="1" desc="Read-write. Reset: 1. 0=The clock of PMIO2 register block can be stopped if not being accessed. 1=The clock of the PMIO2 register block can't be stopped if not being accessed. Power Management IO 2 register block clock gating." />
      <field name="PmioRegBlkClkGatingDis" bit="1" size="1" desc="Read-write. Reset: 1. 0=The clock of the PMIO register block can be stopped if not being accessed. 1=The clock of the PMIO register block can't be stopped if not being accessed. Power Management IO register block clock gating." />
      <field name="MIscRegBlkClkGatingDis" bit="0" size="1" desc="Read-write. Reset: 1. 0=The clock of the MISC register block can be stopped if not being accessed. 1=The clock of the MISC register block can't be stopped if not being accessed. Miscellaneous register block clock gating." />
    </register>

    <!-- 9.2.10.2 Power Management (PM) Registers -->

    <!-- page 491 -->

    <register name="PmDecodeEn" type="memory" device="PM" offset="0x000" size="4" desc="DecodeEn. Read-write. Reset: 2302_0B10h.">
      <!-- Bits 31:30 reserved. -->
      <field name="HpetMsiEn" bit="29" size="1" desc="Read-write. Reset: 1. 1=Expose MSI capability in HPET Capability register." />
      <field name="HpetWidthSel" bit="28" size="1" desc="Read-write. Reset: 0. 0=HPET is 32 bits. 1=HPET is 64 bits." />
      <field name="WatchDogOptions" bit="26" size="2" desc="Read-write. Reset: 0h. Enable for normal WatchDog Timer operation." />
      <field name="WatchDogFreq" bit="24" size="2" desc="Read-write. Reset: 3h. Defines the clock frequency used by the WatchDog Timer." />
      <field name="AsfClkSel" bit="21" size="3" desc="Read-write. Reset: 0h. Specifies the frequency of ASF master clock." />
      <field name="SmBus0Sel" bit="19" size="2" desc="Read-write. Reset: 0h. Specifies the SMBus port selection. There is only one SMBus engine controlling four SMBus ports. This register routes the SMBus engine to the desired port." />
      <field name="AsfClkSwitch" bit="18" size="1" desc="Read-write. Reset: 0. 1=Change ASF master clock from RTC (32 kHz) to the clock defined in AsfClkSel." />
      <field name="AsfClkStretchEn" bit="17" size="1" desc="Read-write. Reset: 1. 1=Enable clock stretching support." />
      <field name="AsfSmMasterEn" bit="16" size="1" desc="Read-write. Reset: 0. 1=Enable ASF SMBus master function." />
      <field name="SmbusAsfIoBase" bit="8" size="8" desc="Read-write. Reset: 0Bh. Description: Specifiies SMBus and ASF IO base address. • SMBus IO base={Smbus0AsfIoBase[7:0],0x00}. • ASF IO base={Smbus0AsfIoBase[7:0],0x20}. By default SMBus IO base is 0xB00 and ASF IO base is 0xB20." />
      <field name="WatchdogTmrEn" bit="7" size="1" desc="Read-write. Reset: 0. 1=Enable IOAPIC memory (FEB0_0000h ~ FEB0_0003h) decoding, and enable WatchDog Timer operation." />
      <field name="HpetEn" bit="6" size="1" desc="Read-write. Reset: 0. 1=Enable HPET memory (FED0_0000h ~ FED0_01FFh) decoding." />
      <field name="IoApicEn" bit="5" size="1" desc="Read-write. Reset: 0. 1=Enable IOAPIC memory (FEC0_0000h ~ FEC0_007Fh) decoding." />
      <field name="SmbusAsfIoEn" bit="4" size="1" desc="Read-write. Reset: 1. 1=Enable SMBus and ASF IO decoding. SMBUS and ASF IO ranges are defined in Smbus0AsfIoBase." />
      <field name="DmaPort80" bit="3" size="1" desc="Read-write. Reset: 0. 1=Pass IO ports 0x80, 0x81, 0x82, 0x83 to legacy DMA IO range." />
      <field name="LegacyDmaIoEn" bit="2" size="1" desc="Read-write. Reset: 0. 1=Enable legacy DMA IO range." />
      <field name="Cf9IoEn" bit="1" size="1" desc="Read-write. Reset: 0. 1=Enable CF9h IO port decoding." />
      <field name="LegacyIoEn" bit="0" size="1" desc="Read-write. Reset: 0. 1=Enable the following IO decoding as described. Description: 0x20, 0x21, 0xA0, 0xA1 (PIC); 0x40, 0x41, 0x42, 0x43, 0x61 (8254 timer); 0x70, 0x71, 0x72, 0x73 (RTC); 0x92." />
    </register>

    <!-- page 493 -->

    <register name="IsaControl" type="memory" device="PM" offset="0x004" size="4" desc="IsaControl. Read-write. Reset: 0000_0002h.">
      <!-- Bits 31:17 reserved. -->
      <field name="ABClkGateEn" bit="16" size="1" desc="Read-write. Reset: 0. 0=Disabled. 1=Enabled. Master switch for A-Link and B-Link clock gating." />
      <!-- Bits 15:9 reserved. -->
      <field name="DmaEnhanceEn" bit="8" size="1" desc="Read-write. Reset: 0. 1=Enable enhancement of legacy DMA." />
      <!-- Bits 7:6 reserved. -->
      <field name="ReadShadow" bit="5" size="1" desc="Read-write. Reset: 0. 1=Allow to Read PIC ICWX, OCWX registers through IO port 21h and A1h." />
      <!-- Bits 4:2 reserved. -->
      <field name="MmioEn" bit="1" size="1" desc="Read-write. Reset: 1. Init: BIOS,1. 1=Enable ACPI MMIO range (FED8_0000h-FED8_1FFFh). MmioEn." />
      <field name="BiosRamEn" bit="0" size="1" desc="Read-write. Reset: 0. 1=Enable BIOS RAM whose base is FED1_0000h (256 bytes)." />
    </register>
    <register name="PciCtl" type="memory" device="PM" offset="0x008" size="4" desc="PciControl. Read-write. Reset: 0000_0100h.">
      <!-- Bits 31:26 reserved. -->
      <field name="ForceSlpStateRetry" bit="25" size="1" desc="Read-write. Reset: 0. 1=Send out an SMI message before the completion response of IO writes to FCH::PM::PmCtl[SlpTyp]. This is to be used in conjunction with SMI trapping on writes to FCH::PM::PmCtl[SlpTyp]." />
      <!-- Bit 24 reserved. -->
      <field name="AbStallEn" bit="23" size="1" desc="Read-write. Reset: 0. 1=Allows the legacy DMA engine to hold the internal bus before completing legacy DMA transaction on the LPC bus. This is only needed for certain old LPC devices." />
      <!-- Bits 22:21 reserved. -->
      <field name="ShutDownOption" bit="20" size="1" desc="Read-write. Reset: 0. 0=Issue Init message upstream when receiving shutdown message. 1=Generate PCI reset when receiving shutdown message." />
      <field name="MasterNoWait" bit="19" size="1" desc="Read-write. Reset: 0. 0=PCI Master waits for Slave idle. 1=ACPI PCI Master doesn't wait for Slave idle when it wants to request bus." />
      <!-- Bits 18:15 reserved. -->
      <field name="ExtIntrTime" bit="12" size="3" desc="Read-write. Reset: 0h. Specifies the extended interrupt time in 2 microsecond intervals. This is used for preventing APU from re-entering C-state right away when it just breaks out from a C-state." />
      <!-- Bits 11:10 reserved. -->
      <field name="BlockAcpiS5IntrSt" bit="9" size="1" desc="Read-write. Reset: 0. Block ACPI S5 interrupt." />
      <field name="PicApicArbiter" bit="8" size="1" desc="Read-write. Reset: 1. 1=Enable arbitration between PIC request and IOAPIC request." />
      <field name="ForceSmafMatch" bit="7" size="1" desc="Read-write. Reset: 0. 1=Enable STPGNT message matching to the expected SMAF." />
      <field name="NmiMsgSel" bit="6" size="1" desc="Read-write. Reset: 0. 0=Encode NMI request as legacy PIC NMI message type. 1=NMI request as NMI message type." />
      <field name="PicMsgSel" bit="5" size="1" desc="Read-write. Reset: 0. 0=Encode PIC interrupt request as Legacy PIC external interrupt (ExtInt) message type. 1=Encode PIC interrupt request as external interrupt (ExtInt) message type." />
      <field name="MsgIntrEnable" bit="4" size="1" desc="Read-write. Reset: 0. 1=Deliver legacy PIC interrupt as message type." />
      <field name="MaskMsgBmStsEn" bit="3" size="1" desc="Read-write. Reset: 0. Set to 1 to enable A20#, IGNNE#, INIT#, NMI, SMI# message delivery." />
      <!-- Bits 2:0 reserved. -->
    </register>

    <!-- page 494 -->

    <register name="PwrResetCfg" type="memory" device="PM" offset="0x010" size="2" desc="Power Reset Config. Read-write. Reset: 0000h.">
      <!-- Bits 15:2 reserved. -->
      <field name="ToggleAllPwrGoodOnCf9" bit="1" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. 0=During CF9 reset, PG1_PwrGood stays high; PG1a_PwrGood, PG2_PwrGood and Xhc_PwrGood behavior depend on TogglePG1aPG2PGXhcOnCf9 bit during CF9 reset. 1=De-assert and then assert all PwrGood signals (for PG1, PG1a, PG2 and XHC) during CF9 reset." />
      <!-- Bit 0 reserved. -->
    </register>
    <register name="PGPwrGoodTmr" type="memory" device="PM" offset="0x014" size="4" desc="PGPwrGoodTmr. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="PllLockTmr" type="memory" device="PM" offset="0x01E" size="2" desc="PLLLockTmr. Reset: 0000h.">
      <!-- Bits 15:0 reserved. -->
    </register>
    <register name="S5ToS0EnTmr" type="memory" device="PM" offset="0x02A" size="2" desc="S5ToS0EnTmr. Reset: 0000h.">
      <!-- Bits 15:0 reserved. -->
    </register>
    <register name="SlpRstTmr" type="memory" device="PM" offset="0x02C" size="2" desc="SlpRstTmr. Reset: 0000h.">
      <!-- Bits 15:0 reserved. -->
    </register>
    <register name="OverrideDevRstTmr" type="memory" device="PM" offset="0x02E" size="2" desc="OverrideDevRstTmr. Reset: 0000h.">
      <!-- Bits 15:0 reserved. -->
    </register>
    <register name="OverridePwrRstBAsrtTmr" type="memory" device="PM" offset="0x030" size="2" desc="OverridePwrRstBAsrtTmr. Reset: 0000h.">
      <!-- Bits 15:0 reserved. -->
    </register>
    <register name="OverrideRefClkOkDsrtTmr" type="memory" device="PM" offset="0x032" size="2" desc="OverrideRefClkOkDsrtTmr. Reset: 0000h.">
      <!-- Bits 15:0 reserved. -->
    </register>

    <!-- page 495 -->

    <register name="OverrideEnable" type="memory" device="PM" offset="0x034" size="4" desc="OverrideEnable. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>
    <register name="ESPIIntrCtrl" type="memory" device="PM" offset="0x040" size="4" desc="eSPIIntrCtrl. Read-write. Reset: 00FF_FFFFh.">
      <!-- Bits 31:24 reserved. -->
      <field name="eSPIDevIntrMask" bit="0" size="24" desc="Read-write. Reset: FF_FFFFh. Set these bits to mask of eSPI Device IRQ[23:0]." />
    </register>
    <register name="BootTimerEn" type="memory" device="PM" offset="0x044" size="4" desc="BootTimerEn. Reset: Cold,1800_0000h.">
      <field name="BootTmrDisable" bit="31" size="1" desc="Read-write. Reset: Cold,0. Init: BIOS,1. 1=Boot timer is stopped. Once set it to 1, timer will reset back to 0. When this bit is set back to 0, timer starts counting from 0. This bit will clear itself on any reset (this bit is non-sticky)." />
      <field name="FailBootRstSts" bit="30" size="1" desc="Read,Write-1-to-clear. Reset: Cold,0. 0=Boot timer has not been fired. 1=Boot timer has been fired. Write-1-to-clear it to 0." />
      <field name="ExpireBootTmr" bit="29" size="1" desc="Read-write. Reset: Cold,0. 1=Force boot timer to expire; then, NB PwrGood can be asserted." />
      <field name="BootTmrStopOnGAlink" bit="28" size="1" desc="Read-write. Reset: Cold,1. Init: BIOS,0. 0=Enable the boot timer to ensure a good boot. 1=Boot timer stops when FCH observes a good boot after PCI reset or S3/S4/S5 resume. BootTmrStopOnGAlink." />
      <field name="BootTmrFuncEn" bit="27" size="1" desc="Read-write. Reset: Cold,1. Init: BIOS,1. 0=Disable boot timer function. 1=Enable boot timer function. The boot timer will start to count down and toggle NBPwrGood after 1.26s (2**24/(66.6M/5)) if software has not set ExpireBootTmr = 1 after PCI reset or resuming from S3/S4/S5, This bit is persistent through any reset or sleep (this bit is sticky)." />
      <!-- Bits 26:25 reserved. -->
      <field name="FailBootTimer" bit="0" size="25" desc="Read-only. Reset: Cold,000_0000h. Description: Specifies the counter of APU boot timer (66.6 MHz/5), which starts counting when the following" />
    </register>

    <!-- page 496 -->

    <register name="WatchdogTimerEn" type="memory" device="PM" offset="0x048" size="4" desc="PGPwrEnDly. Read-write. Reset: 5935_2B21h.">
      <field name="PG1PwrDownDlyTmr" bit="24" size="8" desc="Read-write. Reset: 59h. PG1 Power Down delay timer." />
      <field name="XhcPwrEnDlyTmr" bit="16" size="8" desc="Read-write. Reset: 35h. XHC Power Enable delay timer." />
      <field name="PG2PwrEnDlyTmr" bit="8" size="8" desc="Read-write. Reset: 2Bh. PG2 Power Enable delay timer." />
      <field name="PG1aPwrEnDlyTmr" bit="0" size="8" desc="Read-write. Reset: 21h. PG1a Power En delay timer." />
    </register>
    <register name="I2CInputThreshold" type="memory" device="PM" offset="0x04C" size="4" desc="I2CInputThreshold. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:6 reserved. -->
      <field name="I2C5InputThresholdHi" bit="5" size="1" desc="Read-write. Reset: 0. 0=Low threshold. 1=High threshold. Configure I2C5 input threshold." />
      <field name="I2C4InputThresholdHi" bit="4" size="1" desc="Read-write. Reset: 0. 0=Low threshold. 1=High threshold. Configure I2C4 input threshold." />
      <field name="I2C3InputThresholdHi" bit="3" size="1" desc="Read-write. Reset: 0. 0=Low threshold. 1=High threshold. Configure I2C3 input threshold." />
      <field name="I2C2InputThresholdHi" bit="2" size="1" desc="Read-write. Reset: 0. 0=Low threshold. 1=High threshold. Configure I2C2 input threshold." />
      <field name="I2C1InputThresholdHi" bit="1" size="1" desc="Read-write. Reset: 0. 0=Low threshold. 1=High threshold. Configure I2C1 input threshold." />
      <field name="I2C0InputThresholdHi" bit="0" size="1" desc="Read-write. Reset: 0. 0=Low threshold. 1=High threshold. Configure I2C0 input threshold." />
    </register>
    <register name="ApuPllCtrl" type="memory" device="PM" offset="0x050" size="4" desc="ApuPllCtrl. Read-write. Reset: 3F3E_0000h.">
      <field name="ApuPllRstBTmr" bit="24" size="8" desc="Read-write. Reset: 3Fh. Configure the PllLock assertion time. Unit is 16 usec." />
      <field name="ApuPllPwrRstBTmr" bit="16" size="8" desc="Read-write. Reset: 3Eh. Configure the PllRstB de-assertion time. Unit is 16 usec." />
      <!-- Bits 15:0 reserved. -->
    </register>
    <register name="SerialIrqCfg" type="memory" device="PM" offset="0x054" size="2" desc="SerialIrqConfig. Read-write.">
      <!-- Bits 15:8 reserved. -->
      <field name="SerialIrqEnable" bit="7" size="1" desc="Read-write. Reset: 0. 1=Enable the serial IRQ function." />
      <field name="SerIrqMode" bit="6" size="1" desc="Read-write. Reset: 0. 0=Continuous mode. 1=Active (quiet) mode." />
      <field name="NumSerIrqBits" bit="2" size="4" desc="Read-write. Reset: Cold,0h. Description: Specifies the total number of serial IRQs. The serial IRQ can support 15 IRQ#, SMI#, IOCHK#, INTA#, INTB#, INTC#, and INTD#." />
      <field name="NumStartBits" bit="0" size="2" desc="Read-write. Reset: Cold,0h. This field specifies the number of clocks in the start frame. Start Frame Width = 4 + 2 * NumStartBits." />
    </register>

    <!-- page 497 -->

    <register name="RTCCtl" type="memory" device="PM" offset="0x056" size="2" desc="RTC Control. Reset: Cold,1400h.">
      <!-- Bit 15 reserved. -->
      <field name="ExtraRtcCmosEn" bit="14" size="1" desc="Read-write. Reset: Cold,0. 0=Access to the extra RTC CMOS RAM space is disabled. 1=Software can access the extra 16 bytes of RTC CMOS RAM through FCH::IO::AltRTCAddrPort and FCH::IO::AltRTCDataPort; The extra RAM spaces are located at index 0x00-0x03, 0x40-0x43, 0x80-0x83, 0xC0-0xC3." />
      <field name="AltCmosMapEn" bit="13" size="1" desc="Read-write. Reset: Cold,0. 1=When accessing the RTC CMOS RAM through FCH::IO::RtcAddrPortNmiMask and FCH::IO::RtcDataPort, Bank 1 of CMOS RAM is changed: Index[0Dh:00h] still returns the time and alarm settings; Index[7Fh:0Eh] returns the absolute offset[FFh:8Eh] which maps to the extended RAM space." />
      <field name="CenturyEn" bit="12" size="1" desc="Read-write. Reset: Cold,1. 1=Enable RTC Century support." />
      <field name="MaskRtcClkOut" bit="11" size="1" desc="Read-write. Reset: Cold,0. 1=Disable RtcClk output." />
      <field name="RtcClkDrive" bit="10" size="1" desc="Read-write. Reset: Cold,1. 0=HIGHDRIVE is tied low for RtcClkOut pad. 1=HIGHDRIVE is tied high for RtcClkOut pad." />
      <!-- Bits 9:5 reserved. -->
      <field name="RtcProtectC0_CF" bit="4" size="1" desc="Write-once. Reset: Cold,0. 1=RTC RAM index[CFh:C0h] are locked from Read/Write." />
      <field name="RtcProtectD0_DF" bit="3" size="1" desc="Write-once. Reset: Cold,0. 1=RTC RAM index[DFh:D0h] are locked from Read/Write." />
      <field name="RtcProtectE0_EF" bit="2" size="1" desc="Write-once. Reset: Cold,0. 1=RTC RAM index[EFh:E0h] are locked from Read/Write." />
      <field name="RtcProtectF0_FF" bit="1" size="1" desc="Write-once. Reset: Cold,0. 1=RTC RAM index[FFh:F0h] are locked from Read/Write." />
      <field name="RtcProtect38_3F" bit="0" size="1" desc="Write-once. Reset: Cold,0. 1=RTC RAM index[3Fh:38h] are locked from Read/Write." />
    </register>
    <register name="VRT_T1" type="memory" device="PM" offset="0x058" size="1" desc="VRT_T1. Read-write. Reset: Cold,01h.">
      <field name="VRT_T1" bit="0" size="8" desc="Read-write. Reset: Cold,01h. This field specifies the time of VRT_Enable being high for RTC battery monitor circuit in milliseconds. To conserve power, the RTC battery is sampled periodically for checking its state of health. VRT_T1 and FCH::PM::VRT_T2[VRT_T2] make up the interval of the checking. When VRT_Enable is high, the battery is being sampled. When VRT_Enable is low, the battery is not being sampled." />
    </register>
    <register name="VRT_T2" type="memory" device="PM" offset="0x059" size="1" desc="VRT_T2. Read-write. Reset: Cold,FFh.">
      <field name="VRT_T2" bit="0" size="8" desc="Read-write. Reset: Cold,FFh. This field specifies the time of VRT_Enable being low for the RTC battery monitor circuit in 4 ms increments. See FCH::PM::VRT_T1 for detailed description." />
    </register>
    <register name="RTCShadow" type="memory" device="PM" offset="0x05B" size="1" desc="RTC Shadow. Read-write. Reset: Cold,00h. NOTE: These four bits don't have any default value. After power on, their values are undetermined. Software has to program PwrFailShadow to give them values.">
      <!-- Bits 7:4 reserved. -->
      <field name="PwrFailShadow" bit="0" size="4" desc="Read-write. Reset: Cold,0h. Init: BIOS,4h. Power Fail Shadow." />
    </register>
    <register name="LLBCntrl" type="memory" device="PM" offset="0x05C" size="1" desc="LLBCntrl. Read-write. Reset: 00h.">
      <!-- Bits 7:3 reserved. -->
      <field name="AllowWakeS3En" bit="2" size="1" desc="Read-write. Reset: 0. 1=Allow LLB# as wake event in S3.   Description: NOTE: LLB (Low low battery) event should trigger an SCI if system is in S0. It should block wake-" />
      <field name="UseAsWakeEn" bit="1" size="1" desc="Read-write. Reset: 0. 1=Treat LLB# as wake event." />
      <field name="BlockWakeEn" bit="0" size="1" desc="Read-write. Reset: 0. 1=Block wake event if LLB# is asserted; if (UseAsWakeEn == 1) &amp;&amp; (AllowWakeS3En == 1), LLB# and other wake events can wake the system up from S3." />
    </register>

    <!-- page 498 -->

    <register name="RTCExtIndex" type="memory" device="PM" offset="0x05E" size="1" desc="RTC ExtIndex. Read-write.">
      <field name="Index" bit="0" size="8" desc="Read-write. Reset: Cold,XXh. Specifies the offset of the RTC Extended Register to be Read or Written from FCH::PM::RTCExtData." />
    </register>
    <register name="RTCExtData" type="memory" device="PM" offset="0x05F" size="1" desc="RTC ExtData. Read-write.">
      <field name="Data" bit="0" size="8" desc="Read-write. Reset: Cold,XXh. Specifies the Read data or Write data of the RTC Extended Register." />
    </register>
    <register name="AcpiPm1EvtBlk" type="memory" device="PM" offset="0x060" size="2" desc="AcpiPm1EvtBlk. Read-write. Reset: Cold,0000h.">
      <field name="AcpiPm1EvtBlk" bit="2" size="14" desc="Read-write. Reset: Cold,0000h. Specifies the 16-bit IO range base address[15:2] of the ACPI power management event block." />
      <!-- Bits 1:0 reserved. -->
    </register>
    <register name="AcpiPm1CntBlk" type="memory" device="PM" offset="0x062" size="2" desc="AcpiPm1CntBlk. Read-write. Reset: Cold,0400h.">
      <field name="AcpiPm1CntBlk" bit="1" size="15" desc="Read-write. Reset: Cold,0200h. Specifies the 16-bit IO base address[15:1] of the ACPI power management control block." />
      <!-- Bit 0 reserved. -->
    </register>
    <register name="AcpiPmTmrBlk" type="memory" device="PM" offset="0x064" size="2" desc="AcpiPmTmrBlk. Read-write. Reset: Cold,0000h.">
      <field name="AcpiPmTmrBlk" bit="1" size="15" desc="Read-write. Reset: Cold,0000h. Specifies the 16-bit IO base address[15:1] of the ACPI power management timer block." />
      <!-- Bit 0 reserved. -->
    </register>

    <!-- page 499 -->

    <register name="PCntBlk" type="memory" device="PM" offset="0x066" size="2" desc="PCntBlk. Read-write. Reset: Cold,0000h.">
      <field name="CpuControl" bit="3" size="13" desc="Read-write. Reset: Cold,0000h. These bits define the least significant byte of the 16 bit I/O base address of the ACPI power management APU Control block. Bit 3 corresponds to Addr[3] and bit 7 corresponds   to Addr[7]. Addr[2:0] are ignored because this register is 6 byte long." />
      <!-- Bits 2:0 reserved. -->
    </register>
    <register name="AcpiGpe0Blk" type="memory" device="PM" offset="0x068" size="2" desc="AcpiGpe0Blk. Read-write. Reset: Cold,0000h.">
      <field name="AcpiGpe0Blk" bit="2" size="14" desc="Read-write. Reset: Cold,0000h. Specifies the 16-bit IO base address[15:2] of the ACPI power management general purpose event block." />
      <!-- Bits 1:0 reserved. -->
    </register>
    <register name="AcpiSmiCmd" type="memory" device="PM" offset="0x06A" size="2" desc="AcpiSmiCmd. Read-write. Reset: Cold,00B0h.">
      <field name="AcpiSmiCmd" bit="0" size="16" desc="Read-write. Reset: Cold,00B0h. Defines the 16-bit IO base address[15:0] of the ACPI SMI command block." />
    </register>
    <register name="AcpiPm2CntBlk" type="memory" device="PM" offset="0x06E" size="2" desc="AcpiPm2CntBlk. Read-write. Reset: Cold,0000h.">
      <field name="AcpiPm2CntBlk" bit="0" size="16" desc="Read-write. Reset: Cold,0000h. Defines the 16-bit IO base address[15:0] of the ACPI power management additional control block." />
    </register>
    <register name="AcpiCfg" type="memory" device="PM" offset="0x074" size="4" desc="AcpiConfig.">
      <!-- Bits 31:30 reserved. -->
      <field name="RtcWakeAlarm" bit="29" size="1" desc="Read-write. Reset: Cold,0. 0=Use FCH::IO::RTCC[IRQF] as one of the system wake-up events if IRQF is enabled. 1=Use FCH::IO::RTCC[AF] as one of the system wake-up events if AF is enabled. RTC wake alarm." />
      <field name="PcieGeventMap" bit="28" size="1" desc="Read-write. Reset: Cold,1. 1=Route PME message from NB to GEVENT 24, hot plug message from APU to GEVENT 7." />
      <field name="WakePinAsGevent" bit="27" size="1" desc="Read-write. Reset: Cold,0. 1=Treat WAKE# pin as GEVENT input." />
      <!-- Bit 26 reserved. -->
      <field name="PcieWakMask" bit="25" size="1" desc="Read-write. Reset: Cold,0. 1=Disable the PCIE_WAK_STS and PCIE_WAK_DIS function defined in FCH::PM::Pm1Stat[PciExpWakeStatus] and FCH::PM::Pm1En[PciExpWakeDis]." />
      <field name="PcieNative" bit="24" size="1" desc="Read-write. Reset: Cold,0. 1=Block PCIe® GPP PME message and hot plug message from generating SCI." />
      <field name="RstUSBS5" bit="23" size="1" desc="Read-write. Reset: Cold,0. 0=De-assert Cpl_VDDCR_S5_RESETn = 1. 1=Make Cpl_VDDCR_S5_RESETn = 0 to reset USB, MP2, etc." />
      <!-- Bits 22:10 reserved. -->
      <field name="AcpiReducedHwEn" bit="9" size="1" desc="Read-write. Reset: 0. 0=ACPI fixed register interface is enabled. 1=The decoding of ACPI fixed registers and SCI are disabled; In addition, wake function from AcpiPmEvtBlk is disabled as well." />
      <field name="PwnBtnEn" bit="8" size="1" desc="Read-write. Reset: 1. 1=Enable power button support in AcpiPmEvtBlk block." />
      <field name="BiosRls" bit="7" size="1" desc="Read,Write-1-only. Reset: Fixed,0. Writing 1 to this bit generates SMI, NMI or IRQ13 depending on FCH::SMI::SmiCtl4[Smicontrol73]." />
      <!-- Bits 6:5 reserved. -->
      <field name="TmrEnEn" bit="4" size="1" desc="Read-write. Reset: Cold,0. 1=Enable the TMR_EN function defined in FCH::PM::Pm1En[TmrEn]." />
      <!-- Bit 3 reserved. -->
      <field name="RtcEnEn" bit="2" size="1" desc="Read-write. Reset: Cold,0. 1=Enable the RTC_EN function defined in FCH::PM::Pm1En[RtcEn]." />
      <field name="GblEnEn" bit="1" size="1" desc="Read-write. Reset: Cold,0. 1=Enable the GBL_EN function defined in FCH::PM::Pm1En[GblEn]." />
      <field name="DecEnAcpi" bit="0" size="1" desc="Read-write. Reset: Cold,0. 1=Enable decoding of the standard ACPI registers." />
    </register>

    <!-- page 500 -->

    <register name="CStateEn" type="memory" device="PM" offset="0x07E" size="2" desc="CStateEn. Read-write. Reset: 0020h.">
      <!-- Bits 15:6 reserved. -->
      <field name="C1eToC3En" bit="5" size="1" desc="Read-write. Reset: 1. 1=Put APU into C3 state in C1e state. Software needs to program C1eToC3En = 1." />
      <field name="C1eToC2En" bit="4" size="1" desc="Read-write. Reset: 0. 1=Put APU into C2 state in C1e state." />
      <!-- Bits 3:0 reserved. -->
    </register>
    <register name="CStateCtl" type="memory" device="PM" offset="0x088" size="4" desc="CStateControl. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:6 reserved. -->
      <field name="SlpEn" bit="5" size="1" desc="Read-write. Reset: 0. 1=Enable LDTSTOP# as an output." />
      <!-- Bits 4:3 reserved. -->
      <field name="DlySlpEn" bit="2" size="1" desc="Read-write. Reset: 0. 1=Delay recognition of STPGNT# until there is no pending Read in AB." />
      <!-- Bits 1:0 reserved. -->
    </register>
    <register name="MsgCState" type="memory" device="PM" offset="0x0A0" size="4" desc="MessageCState. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:5 reserved. -->
      <field name="FusionSerrEn" bit="4" size="1" desc="Read-write. Reset: 0. 1=FCH C-state coordination logic causes CPU to exit from C-state when there is a system error within the FCH." />
      <field name="FusionPerrEn" bit="3" size="1" desc="Read-write. Reset: 0. 1=FCH C-state coordination logic causes CPU to exit from C-state when there is a parity error within the FCH." />
      <!-- Bit 2 reserved. -->
      <field name="TimerTickChgMsgEn" bit="1" size="1" desc="Read-write. Reset: 0. 1=FCH sends a message to APU indicating the latest periodic timer interval. FCH automatically determines which timer (PIT, RTC, or HPET) is being used." />
      <field name="BattModeChgMsgEn" bit="0" size="1" desc="Read-write. Reset: 0. 1=FCH automatically sends a message to CPU indicating the power mode (AC vs battery); In addition, every time it is changed, FCH generates a message to indicate the update." />
    </register>
    <register name="TrafStat" type="memory" device="PM" offset="0x0A4" size="4" desc="MiscDebug. Reset: 0000_0000h.">
      <!-- Bits 31:0 reserved. -->
    </register>

    <!-- page 501 -->

    <register name="TrafMonIdleTime" type="memory" device="PM" offset="0x0A8" size="4" desc="VirtualWire. Read-write. Reset: 00FF_CEF8h.">
      <field name="VW_Enable" bit="31" size="1" desc="Read-write. Reset: 0. 0=The state machine is disabled. 1=The state machine is enabled. Description: This bit enables the VirtualWire function. It is possible that Virtual Wire state machine is sending Virtual Wire messages when software clears the VW_Enable bit. In that case, finish Virtual Wire message delivery first and then disable Virtual Wire state   machine. Reading VW_Enable bit returns the current state of Virtual Wire state machine." />
      <field name="VW_InvValue" bit="30" size="1" desc="Read-write. Reset: 0. 0=Normal polarity. 1=Inverted polarity. This is to change the polarity of the virtual wire value bit in the message." />
      <!-- Bits 29:24 reserved. -->
      <field name="VW_SrcActiveLow" bit="0" size="24" desc="Read-write. Reset: FF_CEF8h. Each bit configures polarity of the corresponding interrupt wires. These 24 interrupt wires are connected to IOAPIC input and virtual wire input." />
    </register>
    <register name="DeferTimeTickOBFFCtl" type="memory" device="PM" offset="0x0B0" size="4" desc="DeferTimeTick. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:11 reserved. -->
      <field name="DeferTimerTickValue" bit="8" size="3" desc="Read-write. Reset: 0h." />
      <!-- Bits 7:2 reserved. -->
      <field name="ForceTmrTickEn" bit="1" size="1" desc="Read-write. Reset: 0. 1=If (DeferTimerTickEn == 1) &amp;&amp; FCH has skipped a timer tick interrupt, FCH immediately generates the timer tick interrupt upon C-state exit." />
      <field name="DeferTimerTickEn" bit="0" size="1" desc="Read-write. Reset: 0. 1=FCH skips a number of timer tick interrupts based on the value defined in DeterTimeTickValue when CPU is in C-state. When CPU is not in C-state, the FCH does not skip any timer tick interrupt." />
    </register>

    <!-- page 502 -->

    <register name="Tpreset2" type="memory" device="PM" offset="0x0B8" size="1" desc="Tpreset2. Read-write. Reset: 80h.">
      <field name="ClkGateCntrl" bit="6" size="2" desc="Read-write. Reset: 2h. These two bits control whether SMBUS module allows clock gating to the internal 66 MHz core clock." />
      <!-- Bits 5:0 reserved. -->
    </register>
    <register name="LpcMisc" type="memory" device="PM" offset="0x0B9" size="1" desc="LpcMisc. Read-write. Reset: 00h.">
      <!-- Bits 7:4 reserved. -->
      <field name="ClkRunDisable" bit="3" size="1" desc="Read-write. Reset: 0. 1=Disable this module's ability to support CLKRUN# function from PCIBridge; In other words, this module prevents PCIBridge from stopping the 33 MHz clock. Legacy DMA and serial IRQ logic reside in this module and they are running on the 33 MHz LPCCLK." />
      <!-- Bits 2:0 reserved. -->
    </register>
    <register name="SStateCtl" type="memory" device="PM" offset="0x0BA" size="2" desc="S_StateControl. Read-write. Reset: 0000h.">
      <field name="MaskPmeMsgEn" bit="15" size="1" desc="Read-write. Reset: 0. 1=If (PmeMsgEn == 1), PmeAck messages are ignored and ACPI S- state logic solely uses the timeout mechanism to sequence through the S3 state." />
      <field name="WakePinEnable" bit="14" size="1" desc="Read-write. Reset: 0. 1=Enable wake up from WAKE# pin. WAKE# pin enable." />
      <!-- Bits 13:1 reserved. -->
      <field name="LongSLPS3" bit="0" size="1" desc="Read-write. Reset: 0. 1=Extend SLP_S3# assertion to 1 s minimum." />
    </register>
    <register name="ThrottleCtl" type="memory" device="PM" offset="0x0BC" size="2" desc="ThrottlingControl. Read-write. Reset: 0000h.">
      <field name="Therm2SecDelay" bit="15" size="1" desc="Read-write. Reset: 0. 1=Enable 2 second delay for thermal clock throttle. This bit affects both hardware and software throttle." />
      <field name="NoWaitStpGntEn" bit="14" size="1" desc="Read-write. Reset: 0. 0=Wait for STPGNT after asserting STPCLK. 1=Do not wait for STPGNT after asserting STPCLK. This bit affects both hardware and software throttle." />
      <field name="ThermThrotPeriod" bit="13" size="1" desc="Read-write. Reset: 0. 0=30 us. 1=244 us. Specifies the clock throttle period for hardware thermal throttle." />
      <!-- Bits 12:8 reserved. -->
      <field name="ThrottleControl[3]" bit="7" size="1" desc="Read-write. Reset: 0. 1=Enable hardware thermal clock throttle. See ThrottleControl[2:0]." />
      <field name="ThrottleControl[2:0]" bit="4" size="3" desc="Read-write. Reset: 0h. Specifies the throttle interval for STPCLK de-assertion in hardware thermal clock throttle." />
      <!-- Bits 3:0 reserved. -->
    </register>

    <!-- page 503 -->

    <register name="ResetCtl1" type="memory" device="PM" offset="0x0BE" size="1" desc="ResetControl1. Read-write. Reset: 72h.">
      <field name="RstToCpuPwrGdEn" bit="7" size="1" desc="Read-write. Reset: 0. 1=FCH toggles CpuPwrGd on every reset." />
      <field name="HwmResetOption" bit="6" size="1" desc="Read-write. Reset: 1. 0=Hwm function is reset by RsmRst. 1=Hwm function is reset by PciRst." />
      <field name="SlpTypeControl" bit="5" size="1" desc="Read-write. Reset: 1. 0=FCH::PM::PmCtl[SlpTypeEn] bit has no effect. 1=Enable the function of FCH::PM::PmCtl[SlpTypeEn]." />
      <field name="KbRstEn" bit="4" size="1" desc="Read-write. Reset: 1. 1=Enable KBRST# pin to trigger keyboard reset." />
      <field name="CpuRstControl" bit="2" size="2" desc="Read-write. Reset: 0h." />
      <field name="KbPciRstEn" bit="1" size="1" desc="Read-write. Reset: 1. 1=Make PCI reset during keyboard reset, which can be triggered by KBRST# pin or IMC. This bit must not be programmed by the software. It should be left with the power up default value of 1." />
      <field name="SoftResetEn" bit="0" size="1" desc="Read-write. Reset: 0. 1=Block any reset request until the system is not in C state." />
    </register>
    <register name="S5ResetStat" type="memory" device="PM" offset="0x0C0" size="4" desc="S5/Reset Status. Reset: 0000_0800h. This register shows the source of previous reset.">
      <!-- Bits 31:28 reserved. -->
      <field name="SyncFlood" bit="27" size="1" desc="Read,Write-1-to-clear. Reset: 0. System reset was caused by a SYNC_FLOOD event which was due to an UE error or caused by a SHUTDOWN command from CPU if FCH::PM::PciCtl[ShutDownOption]. Bits[27:16] will be cleared by the last reset event, except the associated bit will be set." />
      <field name="RemoteResetFromASF" bit="26" size="1" desc="Read,Write-1-to-clear. Reset: 0. System reset was caused by a remote RESET command from ASF. Bits[27:16] will be cleared by the last reset event, except the associated bit will be set." />
      <field name="WatchdogIssueReset" bit="25" size="1" desc="Read,Write-1-to-clear. Reset: 0. Bits[27:16] will be cleared by the last reset event except the associated bit will be set." />
      <field name="FailBootRst" bit="24" size="1" desc="Read,Write-1-to-clear. Reset: 0. Bits[27:16] will be cleared by the last reset event, except the associated bit will be set." />
      <!-- Bit 23 reserved. -->
      <field name="KbReset" bit="22" size="1" desc="Read,Write-1-to-clear. Reset: 0. System reset was caused by assertion of KB_RST_L. Bits[27:16] will be cleared by the last reset event, except the associated bit will be set." />
      <field name="SleepReset" bit="21" size="1" desc="Read,Write-1-to-clear. Reset: 0. Reset status from Sleep state (s0i3, S3, S4 or S5) transition. Bits[27:16] will be cleared by the last reset event, except the associated bit will be set." />
      <!-- Bit 20 reserved. -->
      <field name="Do_k8_Reset" bit="19" size="1" desc="Read,Write-1-to-clear. Reset: 0. System reset was caused by CF9 = 0x06. Bits[27:16] will be cleared by the last reset event, except the associated bit will be set." />
      <field name="Do_k8_Init" bit="18" size="1" desc="Read,Write-1-to-clear. Reset: 0. System reset was caused by CF9 = 0x04. Bits[27:16] will be cleared by the last reset event, except the associated bit will be set." />
      <field name="SoftPciRst" bit="17" size="1" desc="Read,Write-1-to-clear. Reset: 0. System reset was caused by writing to FCH::PM::ResetCmd[Reset]. Bits[27:16] will be cleared by the last reset event, except the associated bit will be set." />
      <field name="UserRst" bit="16" size="1" desc="Read,Write-1-to-clear. Reset: 0. Last reset was caused by BP_SYS_RST_L assertion. Bits[27:16] will be cleared by the last reset event, except the associated bit will be set." />
      <field name="PmeTurnOffTime" bit="14" size="2" desc="Read-write. Reset: 0h." />
      <!-- Bits 13:10 reserved. -->
      <field name="IntThermalTrip" bit="9" size="1" desc="Read,Write-1-to-clear. Reset: 0. System was shutdown due to an internal ThermalTrip event." />
      <!-- Bits 8:5 reserved. -->
      <field name="RemotePowerDownFromASF" bit="4" size="1" desc="Read,Write-1-to-clear. Reset: 0. SOC has received a remote Power Off command from ASF." />
      <!-- Bit 3 reserved. -->
      <field name="Shutdown" bit="2" size="1" desc="Read,Write-1-to-clear. Reset: 0. System was shutdown due to ShutDown event (SHUTDOWN# pin)." />
      <field name="FourSecondPwrBtn" bit="1" size="1" desc="Read,Write-1-to-clear. Reset: 0. System was shutdown due to 4s PwrButton event." />
      <field name="ThermalTrip" bit="0" size="1" desc="Read,Write-1-to-clear. Reset: 0. System was shutdown due to BP_THERMTRIP_L assertion." />
    </register>

    <!-- page 504 -->

    <register name="ResetCmd" type="memory" device="PM" offset="0x0C4" size="1" desc="ResetCommand. Reset: 28h.">
      <field name="ResetEn" bit="7" size="1" desc="Read-write. Reset: 0. 0=Writing to bit [Reset] is not allowed. 1=Writing to bit [Reset] is allowed." />
      <field name="ResetAllAcpi" bit="6" size="1" desc="Write-1-only. Reset: 0. Writing 1 to this bit emulates a reset button event." />
      <field name="ResetButtonEn" bit="5" size="1" desc="Read-write. Reset: 1. 0=Disable Reset button. 1=Enable Reset button. 1=Reset from reset button (SYS_RESET_L) will generate S5Reset. 0=Disable SYS_RESET_L to generate S5Reset, which can be used as GEVENT19/GPIO1." />
      <field name="ResetPcie" bit="4" size="1" desc="Read-write. Reset: 0. 0=Release the PCIe® reset. 1=Reset the GPP ports. Set to 1 to reset GPP ports." />
      <field name="UsrRst2Pll" bit="3" size="1" desc="Read-write. Reset: 1. 1=Stop the PLL when the reset button is pressed." />
      <field name="SelectDebug" bit="2" size="1" desc="Read-write. Reset: 0. 0=Select FCH::PM::S5ResetStat to be S5/Reset Status register. 1=Select FCH::PM::S5ResetStat to be a debug status register." />
      <field name="MemRstDisable" bit="1" size="1" desc="Read-write. Reset: 0. 1=The memory reset function at DDR_RST# pin is disabled." />
      <field name="Reset" bit="0" size="1" desc="Write-1-only. Reset: 0. Writing 1 to this bit causes a PCI reset. This bit is enabled by the [ResetEn] bit." />
    </register>

    <!-- page 505 -->

    <register name="CF9Shadow" type="memory" device="PM" offset="0x0C5" size="1" desc="CF9 Shadow. Reset: 00h.">
      <!-- Bits 7:4 reserved. -->
      <field name="FullRst" bit="3" size="1" desc="Read-write. Reset: 0. 0=Assert reset signals only. 1=Place system in S5 state for 3 to 5 seconds." />
      <field name="RstCmd" bit="2" size="1" desc="Write-only. Reset: 0. Write to 1 to generate reset as specified by bits [FullRst] and [SysRst]. Always Read as 0." />
      <field name="SysRst" bit="1" size="1" desc="Read-write. Reset: 0. 0=Send INIT HT message. 1=Reset as specified by [FullRst]." />
      <!-- Bit 0 reserved. -->
    </register>
    <register name="HTCtl" type="memory" device="PM" offset="0x0C6" size="2" desc="HTControl. Reset: 0000h.">
      <!-- Bits 15:0 reserved. -->
    </register>
    <register name="Misc" type="memory" device="PM" offset="0x0C8" size="4" desc="Misc. Read-write. Reset: 0008_000Ch.">
      <field name="ClkIntrVectorOrd" bit="24" size="8" desc="Read-write. Reset: 00h. Specifies the value used to identify the clock interrupt." />
      <!-- Bit 23 reserved. -->
      <field name="ClkIntrVectorOrdEn" bit="22" size="1" desc="Read-write. Reset: 0. 1=The system timer interrupt in the IOAPIC is tagged with a value defined by [ClkIntrVectorOrd]." />
      <!-- Bits 21:20 reserved. -->
      <field name="UseCpuRst" bit="19" size="1" desc="Read-write. Reset: 1. 0=System reset causes INIT# instead of CPURST#." />
      <field name="UseBypassRom" bit="18" size="1" desc="Read-write. Reset: 0. 1=Override the ROM straps and use BypassRomSel to determine which type of ROM to use. This is for BIOS debugging purposes or for systems having multiple BIOSes on board." />
      <field name="BypassRomSel" bit="16" size="2" desc="Read-write. Reset: 0h. These two bits override the two ROM strap pins if [UseBypassRom] == 1." />
      <field name="HideSmbus" bit="15" size="1" desc="Read-write. Reset: 0. 1=Hide the SMBUS PCI configuration space and promote LPC bridge PCI configuration space to function 0." />
      <!-- Bit 14 reserved. -->
      <field name="IdChangeEn" bit="13" size="1" desc="Read-write. Reset: 0. 1=Allow the software to change." />
      <field name="S5ResetOverride" bit="12" size="1" desc="Read-write. Reset: 0. 1=Mask off internet PCI reset used in ACPI." />
      <field name="WriteBackEnable" bit="11" size="1" desc="Read-write. Reset: 0. 1=The WakeOnRing status bit is written back to HD audio controller upon system power up." />
      <field name="LlbEn" bit="10" size="1" desc="Read-write. Reset: 0. 1=LLB function is enabled and system won't wake up from ACPI S-State until LLB# is de-asserted." />
      <field name="TempPolarity" bit="8" size="2" desc="Read-write. Reset: 0h. Temperature polarity control for THRMTRIP and TALERT respectively." />
      <field name="DisablePciRom" bit="7" size="1" desc="Read-write. Reset: 0. 1=Disable PCI from strap." />
      <field name="TwarnEn" bit="6" size="1" desc="Read-write. Reset: 0. 1=Enable TALERT# pin." />
      <!-- Bits 5:4 reserved. -->
      <field name="TDeadEn" bit="3" size="1" desc="Read-write. Reset: 1. 1=GEVENT2 takes up the THRMTRIP function; When THRMTRIP pin is low and [TFatalEn] is set, hardware switches the system to S5 automatically." />
      <field name="TFatalEn" bit="2" size="1" desc="Read-write. Reset: 1. 1=Enable both the soft PciRst and the THRMTRIP function." />
      <!-- Bit 1 reserved. -->
      <field name="CpuIoPullDownDrvStrength" bit="0" size="1" desc="Read-write. Reset: 0. 1=The integrated pull-down drive strength of all CPU IOs are increased by 50%." />
    </register>

    <!-- page 506 -->

    <register name="ManualReset" type="memory" device="PM" offset="0x0D3" size="1" desc="ManualReset. Read-write. Reset: 01h.">
      <!-- Bits 7:1 reserved. -->
      <field name="AssertLdtRstB" bit="0" size="1" desc="Read-write. Reset: 1. 0=Assert LDT_RST# low." />
    </register>
    <register name="AltAcpiMmioEn" type="memory" device="PM" offset="0x0D5" size="1" desc="AltAcpiMmioEn. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="Alt_addr_width_sel" bit="1" size="1" desc="Read-write. Reset: 0. 0=Alternate address is 32-bit width. 1=Alternate address is 64-bit width." />
      <field name="Alt_addr_en" bit="0" size="1" desc="Read-write. Reset: 0. 0=Alternate address disable. 1=Alternate address enable." />
    </register>
    <register name="AltAcpiMmioBase" type="memory" device="PM" offset="0x0D6" size="2" desc="AltAcpiMmioBase. Read-write. Reset: 0000h.">
      <field name="Lower_addr_alt" bit="0" size="16" desc="Read-write. Reset: 0000h. Lower bits of base address. Its value only takes effect when alternate address is enabled (FCH::PM::AltAcpiMmioEn[Alt_addr_en] == 1). For example, when it is set as 0xABCD and alternate address width is 32-bit (FCH::PM::AltAcpiMmioEn[Alt_addr_width_sel] == 0), base address is 0xABCD_0000. If it is 64-bit then the base address is 0xFFFF_FFFF_ ABCD_0000." />
    </register>
    <register name="EpromEfuseIndex" type="memory" device="PM" offset="0x0D8" size="1" desc="Eprom Index. Reset: 00h.">
      <!-- Bits 7:0 reserved. -->
    </register>
    <register name="EpromEfuseData" type="memory" device="PM" offset="0x0D9" size="1" desc="Eprom Data. Reset: 00h.">
      <!-- Bits 7:0 reserved. -->
    </register>

    <!-- page 507 -->

    <register name="SataCfg2" type="memory" device="PM" offset="0x0DC" size="4" desc="SataConfig2. Read-write. Reset: 0000_0000h.">
      <field name="Pmio_xDC_SataConfig" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Used by Sata DEVSLP. This register only reset by RsmRstB or UserRstB, BIOS need to clear this register to 0x0 after Warm Reset so that device can response with  SATA controller's OOB." />
    </register>
    <register name="ABRegBar" type="memory" device="PM" offset="0x0E0" size="4" desc="ABRegBar. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="ABRegBar" bit="3" size="13" desc="Read-write. Reset: 0000h. IO Base address of AB Configuration Registers." />
      <!-- Bits 2:0 reserved. -->
    </register>
    <register name="ABDbg" type="memory" device="PM" offset="0x0E4" size="4" desc="AB Misc Control. Read-write. Reset: 0000_0000h.">
      <!-- Bits 31:2 reserved. -->
      <field name="BlinkControl" bit="0" size="2" desc="Read-write. Reset: 0h. This field controls the BLINK pin behavior. BLINK pin can be used to control the on-off state of an LED on the board." />
    </register>
    <register name="LpcGating" type="memory" device="PM" offset="0x0EC" size="1" desc="LpcGating. Read-write. Reset: 01h.">
      <!-- Bits 7:3 reserved. -->
      <field name="AbNoBypassEn" bit="2" size="1" desc="Read-write. Reset: 0. Init: BIOS,1. 0=Disable. 1=Enable. Signals the A-Link that the LPC cycle should not be bypassed when a retry has timed out." />
      <!-- Bit 1 reserved. -->
      <field name="LpcEnable" bit="0" size="1" desc="Read-write. Reset: 1. 0=Disable. 1=Enable LPC bridge." />
    </register>
    <register name="TraceMemoryEn" type="memory" device="PM" offset="0x0FC" size="4" desc="TraceMemoryEn. Read-write. Reset: 0000_0000h.">
      <field name="TraceMemoryBaseAddr" bit="20" size="12" desc="Read-write. Reset: 000h. The base address of trace memory. It is 1M memory space." />
      <!-- Bits 19:1 reserved. -->
      <field name="TraceMemoryEn" bit="0" size="1" desc="Read-write. Reset: 0. 0=Disable trace memory decoding. 1=Enable trace memory decoding. Set to 1 to enable trace memory decoding." />
    </register>

    <!-- 9.2.10.3 Power Management (PM2) Registers -->

    <!-- page 508 -->

    <register name="Fan0InCtlI" type="indirect" device="PM2" offset="0x000" size="1" desc="Fan0InputControl. Read-write. Reset: 05h.">
      <!-- Bits 7:4 reserved. -->
      <field name="TwoRampAlgorithmEn" bit="3" size="1" desc="Read-write. Reset: 0. 0=Disabled. 1=The two ramp fan control algorithm is enabled." />
      <field name="FanInputControl" bit="0" size="3" desc="Read-write. Reset: 5h." />
    </register>
    <register name="Fan0InCtl" type="memory" device="PM2" offset="0x000" size="1" desc="Fan0InputControl. Read-write. Reset: 05h.">
      <!-- Bits 7:4 reserved. -->
      <field name="TwoRampAlgorithmEn" bit="3" size="1" desc="Read-write. Reset: 0. 0=Disabled. 1=The two ramp fan control algorithm is enabled." />
      <field name="FanInputControl" bit="0" size="3" desc="Read-write. Reset: 5h." />
    </register>
    <register name="Fan0Ctl" type="memory" device="PM2" offset="0x001" size="1" desc="Fan0Control. Read-write. Reset: 00h. When [AutoMode] == 1, the active duty cycle is controlled by the hardware automatically. • If ActualTemperature &lt; LowTemp{FCH::PM2::LoTemp0Hi,FCH::PM2::LoTemp0Lo}, DutyCycle = 0; • If LowTemp{FCH::PM2::LoTemp0Hi,FCH::PM2::LoTemp0Lo} &lt;= ActualTemperature &lt; MedTemp{FCH::PM2::MedTemp0Hi,FCH::PM2::MedTemp0Lo}, DutyCycle = FCH::PM2::LoDuty0[LowDuty0]. • If MedTemp{FCH::PM2::MedTemp0Hi,FCH::PM2::MedTemp0Lo} &lt;= ActualTemperature &lt; HighTemp{FCH::PM2::HiTemp0Hi,FCH::PM2::HiTemp0Lo}, • If [LinearMode] == 0, DutyCycle = FCH::PM2::MedDuty0[MedDuty]. • If [LinearMode] == 1, DutyCycle = ((ActualTemperature - LowTemp{FCH::PM2::LoTemp0Hi,FCH::PM2::LoTemp0Lo }) * (FCH::PM2::Multiplier0[Multiplier] + 1) >> FCH::PM2::Multiplier0[DutySel]) + FCH::PM2::LoDuty0[LowDuty0]. • If ActualTemperature >= HighTemp{FCH::PM2::HiTemp0Hi,FCH::PM2::HiTemp0Lo}, DutyCycle = 100%. In Automode, the hysteresis limit defined by FCH::PM2::LinearRng0 is applied to keep the fan from oscillating erratically.">
      <field name="LinearAdjust" bit="3" size="5" desc="Read-write. Reset: 00h. Specifies the additional offset to effective duty cycle under linear mode." />
      <field name="FanPolarity" bit="2" size="1" desc="Read-write. Reset: 0. 0=FanOut0 drives low. 1=FanOut0 drives high." />
      <field name="LinearMode" bit="1" size="1" desc="Read-write. Reset: 0. 0=Use step function. 1=Use Linear function. See above description for details." />
      <field name="AutoMode" bit="0" size="1" desc="Read-write. Reset: 0. 0=FanOut0 is controlled by FCH::PM2::LoDuty0. 1=FanOut0 is controlled by the temperature input. See the above description for details on AutoMode." />
    </register>

    <!-- page 509 -->

    <register name="Fan0Freq" type="memory" device="PM2" offset="0x002" size="1" desc="Fan0Freq. Read-write. Reset: 00h.">
      <field name="FanFreq" bit="0" size="8" desc="Read-write. Reset: 00h. Normally, 4-wire fan runs at 25 KHz and 3-wire fan runs at 100 Hz. FanOut0 frequency is programmed as follows." />
    </register>
    <register name="LoDuty0" type="memory" device="PM2" offset="0x003" size="1" desc="LowDuty0. Read-write. Reset: 00h.">
      <field name="LowDuty0" bit="0" size="8" desc="Read-write. Reset: 00h. Specifies Fan0 duty number if (LowTemp{FCH::PM2::LoTemp0Hi, FCH::PM2::LoTemp0Lo} &lt;= temperature &lt; MedTemp{FCH::PM2::MedTemp0Hi, FCH::PM2::MedTemp0Lo}).There are 256 time slots in one fan cycle. Duty number N represents the (N+1)th time slot. Fan actively spins in time slot 0 ~ slot N, and stops from slot (N+1) ~ slot 255." />
    </register>
    <register name="MedDuty0" type="memory" device="PM2" offset="0x004" size="1" desc="MedDuty0. Read-write. Reset: 00h.">
      <field name="MedDuty" bit="0" size="8" desc="Read-write. Reset: 00h. Specifies Fan0 duty number using step function if (MedTemp{FCH::PM2::MedTemp0Hi,FCH::PM2::MedTemp0Lo} &lt;= temperature &lt;= HighTemp{FCH::PM2::HiTemp0Hi, FCH::PM2::HiTemp0Lo}). There are 256 time slots in one fan cycle. Duty number N represents the (N+1)th time slot. Fan actively spins in time slot0 ~ slotN, and stops from slot (N+1) ~ slot255." />
    </register>

    <!-- page 510 -->

    <register name="Multiplier0" type="memory" device="PM2" offset="0x005" size="1" desc="Multiplier0. Read-write. Reset: 00h. • HighTemp0[15:0] = {FCH::PM2::HiTemp0Hi[HighTemp0[15:8]],FCH::PM2::HiTemp0Lo[HighTemp0[7:0]]}. • Hysteresis0[15:0] = FCH::PM2::Fan0Hysteresis[HysteresisHi,HysteresisLo]. • Med2Temp0[15:0] = {FCH::PM2::Med2Temp0Hi[Med2Temp0[15:8]],FCH::PM2::Med2Temp0Lo[Med2Temp0[7:0]]}. • SlopeHi[7:2] are the integer bits and SlopeHi[1:0] are the fractional bits of the ramp slope. • BIOS has to calculate SlopeHi[7:0] using the following equation: • SlopeHi = (16'hFF00 – {FCH::PM2::Med2Duty0[Med2Duty0[7:0]], 8'b0}) / (HighTemp0[15:0] – Hysteresis0[15:0] – Med2Temp0[15:0]) For example, if our setting is: • Med2Duty0[7:0] = 25% = 40h • HighTemp0[15:0] = 90°C = 5A00h • Med2Temp0[15:0] = 40°C = 2800h • Hysteresis0[15:0] = 10°C = 0A00h Then: • SlopeHi = (FF00h – 4000h ) / ( 5A00h – 0A00h – 2800h ) = 48896 / 10240 = 4.775 Converting the number 4.775 into the 8-bit format: 00010011 (13h), BIOS should program the Multiplier0 register as 13h in this example.">
      <field name="DutySel" bit="6" size="2" desc="Read-write. Reset: 0h. When Fan0 is programmed in AutoMode with linear function being selected, this field selects part of duty to be fed into fan as described in FCH::PM2::Fan0Ctl register description. When Fan0 is programmed in TwoRamp mode, this field specifies the upper 2 bits in Slope[7:0]. See the above register description for detail." />
      <field name="Multiplier" bit="0" size="6" desc="Read-write. Reset: 00h. When Fan0 is programmed in AutoMode with linear function being selected, this field specifies the factor to calculate duty number as described in FCH::PM2::Fan0Ctl register description. When Fan0 is programmed in TwoRamp mode, this field specifies the lower 6 bits in Slope[7:0]. See the above register description for detail." />
    </register>
    <register name="LoTemp0Lo" type="memory" device="PM2" offset="0x006" size="1" desc="LowTemp0Lo. Read-write. Reset: 00h.">
      <field name="LowTemp0[7:0]" bit="0" size="8" desc="Read-write. Reset: 00h. Specifies the lower 8 bits of the low temperature threshold. See also FCH::PM2::LoTemp0Hi[LowTemp0[15:8]]." />
    </register>
    <register name="LoTemp0Hi" type="memory" device="PM2" offset="0x007" size="1" desc="LowTemp0Hi. Read-write. Reset: 00h.">
      <field name="LowTemp0[15:8]" bit="0" size="8" desc="Read-write. Reset: 00h. Specifies the higher 8 bits of the low temperature threshold. LowTemp0 = {LowTemp0[15:8],FCH::PM2::LoTemp0Lo[LowTemp0[7:0]]}." />
    </register>
    <register name="MedTemp0Lo" type="memory" device="PM2" offset="0x008" size="1" desc="MedTemp0Lo. Read-write. Reset: 00h.">
      <field name="MedTemp0[7:0]" bit="0" size="8" desc="Read-write. Reset: 00h. Specifies the lower 8 bits of the medium temperature threshold. See also FCH::PM2::MedTemp0Hi[MedTemp0[15:8]]." />
    </register>

    <!-- page 511 -->

    <register name="MedTemp0Hi" type="memory" device="PM2" offset="0x009" size="1" desc="MedTemp0Hi. Read-write. Reset: 00h.">
      <field name="MedTemp0[15:8]" bit="0" size="8" desc="Read-write. Reset: 00h. Specifies the higher 8 bits of the medium temperature threshold. MedTemp0 = {MedTemp0[15:8],FCH::PM2::MedTemp0Lo[MedTemp0[7:0]]}." />
    </register>
    <register name="HiTemp0Lo" type="memory" device="PM2" offset="0x00A" size="1" desc="HighTemp0Lo. Read-write. Reset: 00h.">
      <field name="HighTemp0[7:0]" bit="0" size="8" desc="Read-write. Reset: 00h. Specifies the lower 8 bits of the high temperature threshold. See also FCH::PM2::HiTemp0Hi[HighTemp0[15:8]]." />
    </register>
    <register name="HiTemp0Hi" type="memory" device="PM2" offset="0x00B" size="1" desc="HighTemp0Hi. Read-write. Reset: 00h.">
      <field name="HighTemp0[15:8]" bit="0" size="8" desc="Read-write. Reset: 00h. Specifies the higher 8 bits of the high temperature threshold. HighTemp0 = {HighTemp0[15:8],FCH::PM2::HiTemp0Lo[HighTemp0[7:0]]}." />
    </register>
    <register name="LinearRng0" type="memory" device="PM2" offset="0x00C" size="1" desc="LinearRange0. Read-write. Reset: 00h.">
      <field name="LinearRange" bit="0" size="8" desc="Read-write. Reset: 00h. Specifies a variable range that Fan0 can tolerate. Fan0 is not affected if temperature varies within this range." />
    </register>
    <register name="LinearHoldCnt0" type="memory" device="PM2" offset="0x00D" size="1" desc="LinearHoldCount0. Read-write. Reset: 00h.">
      <field name="LinearHoldCount" bit="0" size="8" desc="Read-write. Reset: 00h. Specifies the fan cycles to wait before the duty cycle can be changed." />
    </register>
    <register name="Fan0Hysteresis" type="memory" device="PM2" offset="0x00E" size="2" desc="Fan0Hysteresis. Read-write. Reset: 0000h.">
      <field name="HysteresisHi" bit="8" size="8" desc="Read-write. Reset: 00h. Specifies the hysteresis value (in temperature) of the Two Ramp Fan Control Algorithm. The unit is °C. See FCH::PM2::Multiplier0 on how to program this register." />
      <field name="HysteresisLo" bit="0" size="8" desc="Read-write. Reset: 00h. This byte should always be programmed as 0." />
    </register>
    <register name="Med2Temp0Lo" type="memory" device="PM2" offset="0x050" size="1" desc="Med2Temp0Lo. Read-write. Reset: 00h.">
      <field name="Med2Temp0[7:0]" bit="0" size="8" desc="Read-write. Reset: 00h. IF (FCH::PM2::Fan0InCtl[TwoRampAlgorithmEn] == 1) THEN It specifies the lower byte of the temperature value of the turning point on the ramp. See also FCH::PM2::Med2Temp0Hi[Med2Temp0[15:8]]. ELSE Unused. ENDIF." />
    </register>

    <!-- page 512 -->

    <register name="Med2Temp0Hi" type="memory" device="PM2" offset="0x051" size="1" desc="Med2Temp0Hi. Read-write. Reset: 00h.">
      <field name="Med2Temp0[15:8]" bit="0" size="8" desc="Read-write. Reset: 00h. IF (FCH::PM2::Fan0InCtl[TwoRampAlgorithmEn] == 1) THEN It specifies the higher byte of the temperature value of the turning point on the ramp. Med2Temp0 = {Med2Temp0[15:8],FCH::PM2::Med2Temp0Lo[Med2Temp0[7:0]]}. ELSE Unused. ENDIF." />
    </register>
    <register name="Med2Duty0" type="memory" device="PM2" offset="0x052" size="1" desc="Med2Duty0. Read-write. Reset: 00h.">
      <field name="Med2Duty0[7:0]" bit="0" size="8" desc="Read-write. Reset: 00h. IF (FCH::PM2::Fan0InCtl[TwoRampAlgorithmEn] == 1) THEN It specifies the fan duty value of the turning point on the ramp. ELSE Unused. ENDIF." />
    </register>
    <register name="Multiplier20" type="memory" device="PM2" offset="0x053" size="1" desc="Multiplier2_0. Read-write. Reset: 00h. • MedTemp0[15:0] = {FCH::PM2::MedTemp0Hi[MedTemp0[15:8]],FCH::PM2::MedTemp0Lo[MedTemp0[7:0]]}. • Med2Temp0[15:0] = {FCH::PM2::Med2Temp0Hi[Med2Temp0[15:8]],FCH::PM2::Med2Temp0Lo[Med2Temp0[7:0]]}. • Multiplier2_0[7:2] are the integer bits and Multiplier2_0[1:0] are the fractional bits of the ramp slope. • BIOS has to calculate Multiplier2_0[7:0] using the following equation: • Multiplier2_0 = ({FCH::PM2::Med2Duty0[Med2Duty0[7:0]], 8'b0} – {FCH::PM2::LoDuty0[LowDuty0[7:0]], 8'b0}) / (Med2Temp0[15:0] – MedTemp0[15:0]) For example, if our setting is: • Med2Duty0[7:0] = 50% = 80h • LowDuty0[7:0] = 25% = 40h • Med2Temp0[15:0] = 70°C = 4600h • MedTemp0[15:0] = 40°C = 2800h Then: • Multiplier2_0 = (8000h – 4000h ) / ( 4600h – 2800h ) = 16384 / 7680 = 2.133 Converting the number 2.133 into the 8-bit format: 00001000b (08h), BIOS should program Multiplier20 register to 08h in this example.">
      <field name="Multiplier2_0[7:0]" bit="0" size="8" desc="Read-write. Reset: 00h. IF (FCH::PM2::Fan0InCtl[TwoRampAlgorithmEn] == 1) THEN Specifies the slope value of ramp1lo and ramp0lo in Fan Control Algorithm. Bits[7:2] are integer bits. Bits[1:0] are fractional bits. ELSE Unused. ENDIF." />
    </register>
    <register name="FanStat" type="memory" device="PM2" offset="0x060" size="1" desc="FanStatus. Read,Write-1-to-clear. Reset: 00h.">
      <!-- Bits 7:1 reserved. -->
      <field name="Fan0SpeedTooSlow" bit="0" size="1" desc="Read,Write-1-to-clear. Reset: 0. 1=Fan0 runs slower than the value in the Fan0SpeedLimit{FCH::PM2::Fan0SpeedLimitHi, FCH::PM2::Fan0SpeedLimitLo}. Fan0 speed too slow." />
    </register>
    <register name="FanINTRouteLo" type="memory" device="PM2" offset="0x061" size="1" desc="FanINTRouteLo. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="Fan0INTRoute" bit="0" size="2" desc="Read-write. Reset: 0h." />
    </register>

    <!-- page 513 -->

    <register name="SampleFreqDiv" type="memory" device="PM2" offset="0x063" size="1" desc="SampleFreqDiv. Read-write. Reset: 00h.">
      <field name="LinearRangeOutLimit[4:1]" bit="4" size="4" desc="Read-write. Reset: 0h. LinearRangeOutLimit[7:0] = {000b, LinearRangeOutLimit[4:1], 1b}. LinearRangeOutLimit specifies how close the fan duty follows the target duty cycle and is only used when the fan duty is changing. It is different from the FCH::PM2::LinearRng0, which works like a hysteresis and used when fan duty is not changing." />
      <!-- Bit 3 reserved. -->
      <field name="FanLinearEnhanceEn2" bit="2" size="1" desc="Read-write. Reset: 0. 1=The positive hysteresis of fan duty is removed; FCH::PM2::LinearRng0 only applies to the negative direction; as a result, the fan duty increases once the temperature is increased instead of waiting for a hysteresis." />
      <field name="SampleFreqDiv" bit="0" size="2" desc="Read-write. Reset: 0h. This field specifies the sampling rate of Fan Speed." />
    </register>
    <register name="FanDebounceCtrLo" type="memory" device="PM2" offset="0x064" size="1" desc="FanDebounceCounterLo. Read-write. Reset: 00h.">
      <field name="FanDebounceCounter[7:0]" bit="0" size="8" desc="Read-write. Reset: 00h. Specifies the lower 8 bits of the debounce counter when measuring fan speed. See also FCH::PM2::FanDebounceCtrHi[FanDebounceCounter[15:8]]." />
    </register>
    <register name="FanDebounceCtrHi" type="memory" device="PM2" offset="0x065" size="1" desc="FanDebounceCounterHi. Read-write. Reset: 00h.">
      <field name="FanDebounceCounter[15:8]" bit="0" size="8" desc="Read-write. Reset: 00h. Specifies the high 8 bits of the debounce counter when measuring fan speed. FanDebounceCounter = {FanDebounceCounter[15:8],FCH::PM2::FanDebounceCtrLo[FanDebounceCounter[7:0]]}." />
    </register>
    <register name="Fan0DetectorCtl" type="memory" device="PM2" offset="0x066" size="1" desc="Fan0DetectorControl. Read-write. Reset: 00h.">
      <!-- Bits 7:5 reserved. -->
      <field name="ShutDownEnable" bit="4" size="1" desc="Read-write. Reset: 0. 1=The system is shutdown if FCH::PM2::FanStat[Fan0SpeedTooSlow] remains 1 for more than 4 seconds." />
      <!-- Bits 3:2 reserved. -->
      <field name="UseAverage" bit="1" size="1" desc="Read-write. Reset: 0. 0=Do not use average fan0 speed. 1=Use average fan0 speed." />
      <field name="FanDetectorEnable" bit="0" size="1" desc="Read-write. Reset: 0. 0=Disable fan0 speed measurement. 1=Enable fan0 speed measurement." />
    </register>

    <!-- page 514 -->

    <register name="Fan0SpeedLimitLo" type="memory" device="PM2" offset="0x067" size="1" desc="Fan0SpeedLimitLo. Read-write. Reset: 00h.">
      <field name="FanSpeedLimit[7:0]" bit="0" size="8" desc="Read-write. Reset: 00h. Specifies the lower 8 bits of Fan0SpeedLimit. See also FCH::PM2::Fan0SpeedLimitHi[FanSpeedLimit[15:8]]." />
    </register>
    <register name="Fan0SpeedLimitHi" type="memory" device="PM2" offset="0x068" size="1" desc="Fan0SpeedLimitHi. Read-write. Reset: 00h.">
      <field name="FanSpeedLimit[15:8]" bit="0" size="8" desc="Read-write. Reset: 00h. Specifies the higher 8 bits of Fan0SpeedLimit. FanSpeedLimit = {FanSpeedLimit[15:8],FCH::PM2::Fan0SpeedLimitLo[FanSpeedLimit[7:0]]}." />
    </register>
    <register name="Fan0SpeedLo" type="memory" device="PM2" offset="0x069" size="1" desc="Fan0SpeedLo. Read-only. Reset: 00h.">
      <field name="FanSpeed[7:0]" bit="0" size="8" desc="Read-only. Reset: 00h. Specifies the lower 8 bits of fan0 speed. See also FCH::PM2::Fan0SpeedHi[FanSpeed[15:8]]." />
    </register>
    <register name="Fan0SpeedHi" type="memory" device="PM2" offset="0x06A" size="1" desc="Fan0SpeedHi. Read-only. Reset: 00h.">
      <field name="FanSpeed[15:8]" bit="0" size="8" desc="Read-only. Reset: 00h. Specifies the higher 8 bits of fan0 speed. FanSpeed = {FanSpeed[15:8],FCH::PM2::Fan0SpeedLo[FanSpeed[7:0]]}." />
    </register>
    <register name="TempTsiLo" type="memory" device="PM2" offset="0x08A" size="1" desc="TempTsiLo. Reset: 00h.">
      <field name="TempTsi[7:0]" bit="0" size="8" desc="Reset: 00h. Specifies the lower 8 bits of TempTsi. See also FCH::PM2::TempTsiHi[TempTsi[15:8]]. AccessType: FCH::PM2::TempTsiWe[TempTsiWe] ? Read-write,Volatile : Read-only,Volatile." />
    </register>
    <register name="TempTsiHi" type="memory" device="PM2" offset="0x08B" size="1" desc="TempTsiHi. Reset: 00h.">
      <field name="TempTsi[15:8]" bit="0" size="8" desc="Reset: 00h. Specifies the higher 8 bits of TempTsi. TempTsi = {TempTsi[15:8],FCH::PM2::TempTsiLo[TempTsi[7:0]]}. AccessType: FCH::PM2::TempTsiWe[TempTsiWe] ? Read-write,Volatile : Read-only,Volatile." />
    </register>
    <register name="TempTsiLimitLo" type="memory" device="PM2" offset="0x08C" size="1" desc="TempTsiLimitLo. Read-write. Reset: 00h.">
      <field name="TempTsiLimit[7:0]" bit="0" size="8" desc="Read-write. Reset: 00h. Specifies the lower 8 bits of TempTsiLimit. See FCH::PM2::TempTsiLimitHi[TempTsiLimit[15:8]]." />
    </register>

    <!-- page 515 -->

    <register name="TempTsiLimitHi" type="memory" device="PM2" offset="0x08D" size="1" desc="TempTsiLimitHi. Read-write. Reset: 00h.">
      <field name="TempTsiLimit[15:8]" bit="0" size="8" desc="Read-write. Reset: 00h. Specifies the higher 8 bits of TempTsiLimit. TempTsiLimit[15:0] = {TempTsiLimit[15:8],FCH::PM2::TempTsiLimitLo[TempTsiLimit[7:0]]}." />
    </register>
    <register name="TempTsiChangeLimit" type="memory" device="PM2" offset="0x08E" size="1" desc="TempTsiChangeLimit. Read-write. Reset: 00h. If (TempTsiChangeLimit != 0), filtering is applied to TempTsi{FCH::PM2::TempTsiHi, FCH::PM2::TempTsiLo} as below: • If TempTsi_New > (TempTsi_Old + (TempTsiChangeLimit&lt;&lt;6)), then … (Action to take.) • If TempTsi_New &lt; (TempTsi_Old - (TempTsiChangeLimit&lt;&lt;6)), then … (Action to take.) • If (Temp_Old - (TempTsiChangLimit&lt;&lt;6)) &lt;= TempTsi_New &lt;= (TempTsi_Old + (TempChangeLimit&lt;&lt;6)), then … (Action to take.)">
      <field name="TempTsiChangeLimit" bit="0" size="8" desc="Read-write. Reset: 00h. Limit of the chance seen by the temperature sensor to be used when defining actions to be taken on temperature changes." />
    </register>
    <register name="TempTsiWe" type="memory" device="PM2" offset="0x08F" size="1" desc="TempTsiWe. Read-write. Reset: 00h.">
      <!-- Bits 7:6 reserved. -->
      <field name="TempTsiWe" bit="5" size="1" desc="TempTsi Write Enable. Read-write. Reset: 0. 0=TempTsi registers, FCH::PM2::TempTsiHi and FCH::PM2::TempTsiLo, are Read-only and updated by hardware with the result from TempTsi sensor. 1=TempTsi registers are Writable only by host and IMC; they are not updated by hardware with the result from the TempTsi sensor." />
      <!-- Bits 4:0 reserved. -->
    </register>
    <register name="TempTsiStat" type="memory" device="PM2" offset="0x090" size="1" desc="TempTsiStatus. Read,Write-1-to-clear. Reset: 00h.">
      <!-- Bits 7:6 reserved. -->
      <field name="TempTsiStatus" bit="5" size="1" desc="Read,Write-1-to-clear. Reset: 0. 1=TempTsi{FCH::PM2::TempTsiHi, FCH::PM2::TempTsiLo} is out of the limit." />
      <!-- Bits 4:0 reserved. -->
    </register>
    <register name="TempTsiCtl" type="memory" device="PM2" offset="0x092" size="1" desc="TempTsiControl. Read-write. Reset: 00h.">
      <!-- Bits 7:4 reserved. -->
      <field name="TempTsiControl" bit="2" size="2" desc="Read-write. Reset: 0h. TempTsi sensor is enabled if (TempTsiControl != 0)." />
      <!-- Bits 1:0 reserved. -->
    </register>

    <!-- page 516 -->

    <register name="TempTsiINTRoute" type="memory" device="PM2" offset="0x094" size="1" desc="TempTsiINTRoute. Read-write. Reset: 00h.">
      <!-- Bits 7:4 reserved. -->
      <field name="TempTsiINTRoute" bit="2" size="2" desc="Read-write. Reset: 0h." />
      <!-- Bits 1:0 reserved. -->
    </register>
    <register name="TempTsiRstSel" type="memory" device="PM2" offset="0x0DF" size="1" desc="TempTsiRstSel. Read-write. Reset: 00h.">
      <!-- Bits 7:6 reserved. -->
      <field name="TempTsiRstSel" bit="5" size="1" desc="Read-write. Reset: 0. 1=Thermal diode monitoring function is not stopped by reset." />
      <!-- Bits 4:0 reserved. -->
    </register>
    <register name="AlertThermtripStat" type="memory" device="PM2" offset="0x0E0" size="1" desc="AlertThermaltripStatus. Read-only. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="ThermalTripStatus" bit="1" size="1" desc="Read-only. Reset: 0. 0=Current temperature is not above ThermalTripLimit. 1=Current temperature is above ThermalTripLimit." />
      <field name="AlertStatus" bit="0" size="1" desc="Read-only. Reset: 0. 0=Current temperature is not above AlertLimit. 1=Current temperature is above AlertLimit." />
    </register>
    <register name="AlertLimitLo" type="memory" device="PM2" offset="0x0E1" size="1" desc="AlertLimitLo. Read-write. Reset: 00h.">
      <field name="AlertLimit[7:0]" bit="0" size="8" desc="Read-write. Reset: 00h. Thermal alert limit lower 8 bits. See also FCH::PM2::AlertLimitHi[AlertLimit[15:8]]." />
    </register>
    <register name="AlertLimitHi" type="memory" device="PM2" offset="0x0E2" size="1" desc="AlertLimitHi. Read-write. Reset: 00h.">
      <field name="AlertLimit[15:8]" bit="0" size="8" desc="Read-write. Reset: 00h. Thermal alert limit upper 8 bits. AlertLimit[15:0] = {AlertLimit[15:8],FCH::PM2::AlertLimitLo[AlertLimit[7:0]]}." />
    </register>

    <!-- page 517 -->

    <register name="ThermTripLimitLo" type="memory" device="PM2" offset="0x0E3" size="1" desc="ThermalTripLimitLo. Read-write. Reset: 00h.">
      <field name="ThermalTripLimit[7:0]" bit="0" size="8" desc="Read-write. Reset: 00h. Thermal trip limit to enable system shutdown. Lower 8 bit of the trip limit. See also FCH::PM2::ThermTripLimitHi[ThermalTripLimit[15:8]]." />
    </register>
    <register name="ThermTripLimitHi" type="memory" device="PM2" offset="0x0E4" size="1" desc="ThermalTripLimitHi. Read-write. Reset: 00h.">
      <field name="ThermalTripLimit[15:8]" bit="0" size="8" desc="Read-write. Reset: 00h. Thermal trip limit upper 8 bits. ThermalTripLimit[15:0] = {ThermalTripLimit[15:8],FCH::PM2::ThermTripLimitLo[ThermalTripLimit[7:0]]}." />
    </register>
    <register name="AlertThermtripCtl" type="memory" device="PM2" offset="0x0E5" size="1" desc="AlertThermaltripControl. Read-write. Reset: 00h.">
      <field name="TempSelAlert" bit="5" size="3" desc="Read-write. Reset: 0h. This field selects which temperature sensor is the event source. It converts the selected Temp input pin into either TAlert or ThermalTrip function." />
      <!-- Bits 4:2 reserved. -->
      <field name="AlertControl" bit="0" size="2" desc="Read-write. Reset: 0h. Enable ThermalTrip or Talert on the selected Temp input." />
    </register>

    <!-- 9.2.10.4.1 AcpiPmEvtBlk -->

    <register name="Pm1Stat" type="memory" device="ACPI" offset="0x0800" size="2" desc="Pm1Status. Read,Write-1-to-clear. Reset: 0000h.">
      <field name="WakeStatus" bit="15" size="1" desc="Read,Write-1-to-clear. Reset: 0. 1=The system is in the sleep state and a wake-up event occurs. Wake status." />
      <field name="PciExpWakeStatus" bit="14" size="1" desc="Read,Write-1-to-clear. Reset: 0. 1=The system wake is due to a PCI Express wakeup event. PCI Express® wake status." />
      <!-- Bits 13:11 reserved. -->
      <field name="RtcStatus" bit="10" size="1" desc="Read,Write-1-to-clear. Reset: 0. 1=RTC generates an alarm. RTC status, set-by-hardware. If both FCH::PM::Pm1En[RtcEn] and this bit are set to 1, a power management event: SCI, SMI or resume event, is generated." />
      <!-- Bit 9 reserved. -->
      <field name="PwrBtnStatus" bit="8" size="1" desc="Read,Write-1-to-clear. Reset: 0. 1=The Power Button is pressed. Power Button status bit. In the system working state, if FCH::PM::Pm1En[PwrBtnEn] and this bit are both set to 1, an interrupt event is raised. In the sleeping or soft-off state, a wake event is generated when the Power Button is pressed regardless of the setting of FCH::PM::Pm1En[PwrBtnEn]." />
      <!-- Bits 7:6 reserved. -->
      <field name="GblStatus" bit="5" size="1" desc="Read,Write-1-to-clear. Reset: 0. 1=An SCI is generated due to the BIOS wanting the attention of the SCI handler; Writing 1 to FCH::PM::AcpiCfg[BiosRls] sets this bit. Global status." />
      <!-- Bits 4:1 reserved. -->
      <field name="TmrStatus" bit="0" size="1" desc="Read,Write-1-to-clear. Reset: 0. 1=The 31st bit of the 32-bit counter changes from low to high or high to low. Timer status, set-by-hardware. Timer carry status bit. If both FCH::PM::Pm1En[TmrEn] and this bit are set to 1, an interrupt event is raised." />
    </register>

    <!-- page 518 -->

    <register name="Pm1En" type="memory" device="ACPI" offset="0x0802" size="2" desc="Pm1Enable. Read-write. Reset: 4000h.">
      <!-- Bit 15 reserved. -->
      <field name="PciExpWakeDis" bit="14" size="1" desc="Read-write. Reset: 1. 1=Disable the inputs to FCH::PM::Pm1Stat[PciExpWakeStatus] from waking the system." />
      <!-- Bits 13:11 reserved. -->
      <field name="RtcEn" bit="10" size="1" desc="Read-write. Reset: 0. 1=A wake event is generated whenever FCH::PM::Pm1Stat[RtcStatus] is also set to 1." />
      <!-- Bit 9 reserved. -->
      <field name="PwrBtnEn" bit="8" size="1" desc="Read-write. Reset: 0. 1=A power management event (SCI or wake) is generated whenever FCH::PM::Pm1Stat[PwrBtnStatus] is also set to 1." />
      <!-- Bits 7:6 reserved. -->
      <field name="GblEn" bit="5" size="1" desc="Read-write. Reset: 0. 1=An SCI is raised whenever FCH::PM::Pm1Stat[GblStatus] is also set to 1." />
      <!-- Bits 4:1 reserved. -->
      <field name="TmrEn" bit="0" size="1" desc="Read-write. Reset: 0. 0=No interrupt is generated when the FCH::PM::Pm1Stat[TmrStatus] bit is set to 1. 1=An SCI event is generated whenever the FCH::PM::Pm1Stat[TmrStatus] is set to 1. This is the timer carry interrupt enable bit." />
    </register>

    <!-- 9.2.10.4.2 AcpiPm1CntBlk -->

    <register name="PmCtl" type="memory" device="ACPI" offset="0x0804" size="4" desc="PmControl. Reset: 0000_0000h.">
      <!-- Bits 31:14 reserved. -->
      <field name="SlpTypeEn" bit="13" size="1" desc="Write-1-only. Reset: 0. 1=The system sequences into the sleeping state defined by [SlpTyp] when FCH::PM::ResetCtl1[SlpTypeControl] is set to 1." />
      <field name="SlpTyp" bit="10" size="3" desc="Read-write. Reset: 0h. Specifies the sleep state the system enters when SlpTypeEn == 1. This design currently implements 5 states: S0, S1, S3, S4, and S5." />
      <!-- Bits 9:3 reserved. -->
      <field name="GblRls" bit="2" size="1" desc="Write-only. Reset: 0. If FCH::SMI::SmiCtl4[Smicontrol72] is set to 01b, writing 1 to this bit generates SMI and sets FCH::SMI::SmiStat2[GblRlsEvent72]." />
      <!-- Bit 1 reserved. -->
      <field name="SciEn" bit="0" size="1" desc="Read-write. Reset: 0. 0=Power management events generate SMI interrupts. 1=Power management events generate SCI interrupts. Selects the power management event to be either an SCI or SMI interrupt for the power management events." />
    </register>

    <!-- 9.2.10.4.3 AcpiPmTmrBlk -->

    <!-- page 519 -->

    <register name="TmrValue_ETmrValu" type="memory" device="ACPI" offset="0x0808" size="4" desc="TmrValue/ETmrValue. Read-only.">
      <field name="TmrValue" bit="0" size="32" desc="Read-only. Reset: XXXX_XXXXh. It returns the running count of the power management timer (ACPI timer)." />
    </register>

    <!-- 9.2.10.4.4 AcpiGpe0Blk -->

    <!-- page 520 -->

    <register name="EventStat" type="memory" device="ACPI" offset="0x0814" size="4" desc="EventStatus. Read,Write-1-to-clear.">
      <field name="EventStatus" bit="0" size="32" desc="Read,Write-1-to-clear. Reset: XXXX_XXXXh. Each bit represents an ACPI event status. For each bit, configuration for the events are located at FCH::SMI::SciTrig through FCH::SMI::SciMap14. The status bits are also mirrored in FCH::PM::EventStat." />
    </register>
    <register name="EventEnable" type="memory" device="ACPI" offset="0x0818" size="4" desc="EventEnable. Read-write. Reset: 0000_0000h.">
      <field name="EventEnable" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Each bit controls whether ACPI should generate wakeup and SCI interrupt. The enable bits are also mirrored in FCH::SMI::EventEn." />
    </register>

    <!-- 9.2.10.4.5 SmiCmdBlk -->

    <!-- page 521 -->

    <register name="SmiCmdPort" type="memory" device="ACPI" offset="0x081C" size="1" desc="SmiCmdPort. Read-write. Reset: 00h.">
      <field name="SmiCmdPort" bit="0" size="8" desc="Read-write. Reset: 00h. When SMI command port is enabled, a Write to this port generates SMI# (only IOW can generate SMI#, MEMW does not generate SMI#). A Read of this address will return the previously Written value but does not generate an SMI." />
    </register>
    <register name="SmiCmdStat" type="memory" device="ACPI" offset="0x081D" size="1" desc="SmiCmdStatus. Read-write. Reset: 00h.">
      <field name="SmiCmdStatus" bit="0" size="8" desc="Read-write. Reset: 00h. Used by BIOS and OS." />
    </register>

    <!-- 9.2.11.1 IOMUX Registers -->

    <!-- page 526 -->

    <register name="Gpio0" type="memory" device="IOMUX" offset="0x000" size="1" desc="PWR_BTN_L_AGPIO0. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="PWR_BTN_L_AGPIO0" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin PWR_BTN_L. The default IO state is pull-up." />
    </register>

    <!-- page 527 -->

    <register name="Gpio1" type="memory" device="IOMUX" offset="0x001" size="1" desc="RST_strap_SYS_RESET_L_AGPIO1. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="RST_strap_SYS_RESET_L_AGPIO1" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin SYS_RESET_L. The default IO state is pull-up." />
    </register>
    <register name="Gpio2" type="memory" device="IOMUX" offset="0x002" size="1" desc="WAKE_L_AGPIO2. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="WAKE_L_AGPIO2" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin WAKE_L. The default IO state is pull-up." />
    </register>
    <register name="Gpio3" type="memory" device="IOMUX" offset="0x003" size="1" desc="AGPIO3. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="AGPIO3" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin AGPIO3. The default IO state is pull-up." />
    </register>
    <register name="Gpio4" type="memory" device="IOMUX" offset="0x004" size="1" desc="AGPIO4. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="AGPIO4" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin AGPIO4. The default IO state is pull-down." />
    </register>

    <!-- page 528 -->

    <register name="Gpio5" type="memory" device="IOMUX" offset="0x005" size="1" desc="AGPIO5_DEVSLP0. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="AGPIO5_DEVSLP0" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin AGPIO5. The default IO state is pull-down." />
    </register>
    <register name="Gpio6" type="memory" device="IOMUX" offset="0x006" size="1" desc="AGPIO6_DEVSLP1. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="AGPIO6_DEVSLP1" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin AGPIO6. The default IO state is pull-down." />
    </register>
    <register name="Gpio7" type="memory" device="IOMUX" offset="0x007" size="1" desc="AGPIO7_FCH_ACP_I2S_SDIN. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="AGPIO7_FCH_ACP_I2S_SDIN" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin AGPIO7. The default IO state is pull-down." />
    </register>
    <register name="Gpio8" type="memory" device="IOMUX" offset="0x008" size="1" desc="AGPIO8_FCH_ACP_I2S_LRCLK. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="AGPIO8_FCH_ACP_I2S_LRCLK" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin AGPIO8. The default IO state is pull-down." />
    </register>

    <!-- page 529 -->

    <register name="Gpio9" type="memory" device="IOMUX" offset="0x009" size="1" desc="AGPIO9_SGPIO_DATAOUT_MDIO1_SCL. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="AGPIO9_SGPIO_DATAOUT_MDIO1_SCL" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin AGPIO9. The default IO state is pull-down." />
    </register>
    <register name="Gpio10" type="memory" device="IOMUX" offset="0x00A" size="1" desc="S0A3_GPIO_AGPIO10_SGPIO_CLK_MDIO0_SCL. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="S0A3_GPIO_AGPIO10_SGPIO_CLK_MDIO0_SCL" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin S0A3_GPIO." />
    </register>
    <register name="Gpio11" type="memory" device="IOMUX" offset="0x00B" size="1" desc="BLINK_AGPIO11. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="BLINK_AGPIO11" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin BLINK. The default IO state is pull-up." />
    </register>
    <register name="Gpio12" type="memory" device="IOMUX" offset="0x00C" size="1" desc="AGPIO12_LLB_L. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="PWRGD_OUT_AGPIO12" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin LLB_L." />
    </register>

    <!-- page 530 -->

    <register name="Gpio13" type="memory" device="IOMUX" offset="0x00D" size="1" desc="AGPIO13_USB_OC5_L. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="AGPIO13_USB_OC5_L" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin USB_OC5_L." />
    </register>
    <register name="Gpio14" type="memory" device="IOMUX" offset="0x00E" size="1" desc="AGPIO14_USB_OC4_L. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="AGPIO14_USB_OC4_L" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin USB_OC4_L." />
    </register>
    <register name="Gpio16" type="memory" device="IOMUX" offset="0x010" size="1" desc="USB_OC0_L_AGPIO16. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="USB_OC0_L_AGPIO16" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin USB_OC0_L. The default IO state is pull-up." />
    </register>
    <register name="Gpio17" type="memory" device="IOMUX" offset="0x011" size="1" desc="USB_OC1_L_AGPIO17. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="USB_OC1_L_AGPIO17" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin USB_OC1_L. The default IO state is pull-up." />
    </register>

    <!-- page 531 -->

    <register name="Gpio18" type="memory" device="IOMUX" offset="0x012" size="1" desc="USB_OC2_L_AGPIO18. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="USB_OC2_L_AGPIO18" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin USB_OC2_L. The default IO state is pull-up." />
    </register>
    <register name="Gpio19" type="memory" device="IOMUX" offset="0x013" size="1" desc="SCL1_I2C3_SCL_AGPIO19. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="SCL1_I2C3_SCL_AGPIO19" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin SCL1." />
    </register>
    <register name="Gpio20" type="memory" device="IOMUX" offset="0x014" size="1" desc="SDA1_I2C3_SDA_AGPIO20. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="SDA1_I2C3_SDA_AGPIO20" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin SDA1." />
    </register>
    <register name="Gpio21" type="memory" device="IOMUX" offset="0x015" size="1" desc="LPC_PD_L_EMMC_CMD_AGPIO21. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="LPC_PD_L_EMMC_CMD_AGPIO21" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin LPC_PD_L." />
    </register>

    <!-- page 532 -->

    <register name="Gpio22" type="memory" device="IOMUX" offset="0x016" size="1" desc="LPC_PME_L_EMMC_PWR_CTRL_AGPIO22. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="LPC_PME_L_EMMC_PWR_CTRL_AGPIO22" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin LPC_PME_L. The default IO state is pull-up." />
    </register>
    <register name="Gpio23" type="memory" device="IOMUX" offset="0x017" size="1" desc="AGPIO23_AC_PRES_SGPIO_LOAD_MDIO1_SDA. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="AGPIO23_AC_PRES_SGPIO_LOAD_MDIO1_SDA" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin AGPIO23. The default IO state is pull-up." />
    </register>
    <register name="Gpio24" type="memory" device="IOMUX" offset="0x018" size="1" desc="USB_OC3_L_AGPIO24. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="USB_OC3_L_AGPIO24" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin USB_OC3_L. The default IO state is pull-up." />
    </register>
    <register name="Gpio26" type="memory" device="IOMUX" offset="0x01A" size="1" desc="PCIE_RST_L_EGPIO26. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="PCIE_RST_L_EGPIO26" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin PCIE_RST_L." />
    </register>

    <!-- page 533 -->

    <register name="Gpio27" type="memory" device="IOMUX" offset="0x01B" size="1" desc="EGPIO27_PCIE_RST1_L. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="X48M0_EGPIO27" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin PCIE_RST1_L. The default IO state is pull-down." />
    </register>
    <register name="Gpio29" type="memory" device="IOMUX" offset="0x01D" size="1" desc="SPI_TPM_CS_L_AGPIO29_USB_OC6_L. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="SPI_TPM_CS_L_AGPIO29_USB_OC6_L" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin AGPIO29. The default IO state is pull-down." />
    </register>
    <register name="Gpio30" type="memory" device="IOMUX" offset="0x01E" size="1" desc="SPI_CS2_L_ESPI_CS_L_AGPIO30. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="SPI_CS2_L_ESPI_CS_L_AGPIO30" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin AGPIO30. The default IO state is pull-down." />
    </register>

    <!-- page 534 -->

    <register name="Gpio31" type="memory" device="IOMUX" offset="0x01F" size="1" desc="SPI_CS3_L_AGPIO31. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="SPI_CS3_L_AGPIO31" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin AGPIO31. The default IO state is pull-down." />
    </register>
    <register name="Gpio32" type="memory" device="IOMUX" offset="0x020" size="1" desc="LPC_RST_L_SD_WP_L_AGPIO32. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="LPC_RST_L_SD_WP_L_AGPIO32" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin AGPIO32. The default IO state is pull-down." />
    </register>
    <register name="Gpio40" type="memory" device="IOMUX" offset="0x028" size="1" desc="AGPIO40_SGPIO_DATAIN_MDIO0_SDA. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="AGPIO40_SGPIO_DATAIN_MDIO0_SDA" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin AGPIO40." />
    </register>
    <register name="Gpio42" type="memory" device="IOMUX" offset="0x02A" size="1" desc="EGPIO42. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="EGPIO42" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin EGPIO42." />
    </register>

    <!-- page 535 -->

    <register name="Gpio67" type="memory" device="IOMUX" offset="0x043" size="1" desc="EGPIO67_SPI_ROM_REQ. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="EGPIO67_SPI_ROM_REQ" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin EGPIO67. The default IO state is pull-down." />
    </register>
    <register name="Gpio68" type="memory" device="IOMUX" offset="0x044" size="1" desc="AGPIO68_EMMC_CD. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="AGPIO68_EMMC_CD" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin AGPIO68. The default IO state is pull-down." />
    </register>
    <register name="Gpio69" type="memory" device="IOMUX" offset="0x045" size="1" desc="AGPIO69. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="AGPIO69" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin AGPIO69. The default IO state is pull-down." />
    </register>
    <register name="Gpio70" type="memory" device="IOMUX" offset="0x046" size="1" desc="EGPIO70_EMMC_CLK. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="EGPIO70_EMMC_CLK" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin EGPIO70. The default IO state is pull-down." />
    </register>

    <!-- page 536 -->

    <register name="Gpio74" type="memory" device="IOMUX" offset="0x04A" size="1" desc="LPCCLK0_EMMC_DATA4_EGPIO74. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="LPCCLK0_EMMC_DATA4_EGPIO74" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin LPCCLK0." />
    </register>
    <register name="Gpio75" type="memory" device="IOMUX" offset="0x04B" size="1" desc="LPCCLK1_EMMC_DATA6_EGPIO75. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="LPCCLK1_EMMC_DATA6_EGPIO75" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin LPCCLK1." />
    </register>
    <register name="Gpio76" type="memory" device="IOMUX" offset="0x04C" size="1" desc="EGPIO76_SPI_ROM_GNT. Read-write. Reset: 01h.">
      <!-- Bits 7:2 reserved. -->
      <field name="EGPIO76_SPI_ROM_GNT" bit="0" size="2" desc="Read-write. Reset: 1h. Multi-function IO pin function select for pin EGPIO76. The default IO state is pull-up." />
    </register>
    <register name="Gpio84" type="memory" device="IOMUX" offset="0x054" size="1" desc="FANIN0_AGPIO84. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="FANIN0_AGPIO84" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin FANIN0. The default IO state is pull-up." />
    </register>

    <!-- page 537 -->

    <register name="Gpio85" type="memory" device="IOMUX" offset="0x055" size="1" desc="FanOut_intB_FANOUT0_AGPIO85. Read-write. Reset: 01h.">
      <!-- Bits 7:2 reserved. -->
      <field name="FanOut_intB_FANOUT0_AGPIO85" bit="0" size="2" desc="Read-write. Reset: 1h. Multi-function IO pin function select for pin FANOUT0. The default IO state is pull-up." />
    </register>
    <register name="Gpio86" type="memory" device="IOMUX" offset="0x056" size="1" desc="LPC_SMI_L_AGPIO86. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="LPC_SMI_L_AGPIO86" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin LPC_SMI_L. The default IO state is pull-up." />
    </register>
    <register name="Gpio87" type="memory" device="IOMUX" offset="0x057" size="1" desc="SERIRQ_EMMC_DATA7_AGPIO87. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="SERIRQ_EMMC_DATA7_AGPIO87" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin SERIRQ. The default IO state is pull-up." />
    </register>
    <register name="Gpio88" type="memory" device="IOMUX" offset="0x058" size="1" desc="LPC_CLKRUN_L_EMMC_DATA5_AGPIO88. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="LPC_CLKRUN_L_EMMC_DATA5_AGPIO88" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin LPC_CLKRUN_L. The default IO state is pull-up." />
    </register>

    <!-- page 538 -->

    <register name="Gpio89" type="memory" device="IOMUX" offset="0x059" size="1" desc="GENINT1_L_PSP_INTR0_AGPIO89. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="GENINT1_L_PSP_INTR0_AGPIO89" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin GENINT1_L. The default IO state is pull-up." />
    </register>
    <register name="Gpio90" type="memory" device="IOMUX" offset="0x05A" size="1" desc="GENINT2_L_PSP_INTR1_AGPIO90. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="GENINT2_L_PSP_INTR1_AGPIO90" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for GENINT2_L. The default IO state is pull-up." />
    </register>
    <register name="Gpio91" type="memory" device="IOMUX" offset="0x05B" size="1" desc="SPKR_AGPIO91. Read-write. Reset: 01h.">
      <!-- Bits 7:2 reserved. -->
      <field name="SPKR_AGPIO91" bit="0" size="2" desc="Read-write. Reset: 1h. Multi-function IO pin function select for SPKR. The default IO state is pull-down." />
    </register>
    <register name="Gpio92" type="memory" device="IOMUX" offset="0x05C" size="1" desc="CLK_REQ0_L_SATA_IS0_L_SATA_ZP0_L_AGPIO92. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="CLK_REQ0_L_SATA_IS0_L_SATA_ZP0_L_AGPIO92" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin CLK_REQ0_L. The default IO state is pull-up.  " />
    </register>

    <!-- page 539 -->

    <register name="Gpio95" type="memory" device="IOMUX" offset="0x05F" size="1" desc="SD0_CLK_EGPIO95. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="SD0_CLK_EGPIO95" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin SD0_CLK. The default IO state is pull-down." />
    </register>
    <register name="Gpio96" type="memory" device="IOMUX" offset="0x060" size="1" desc="SD0_CMD_EGPIO96. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="SD0_CMD_EGPIO96" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin SD0_CMD. The default IO state is pull-up." />
    </register>
    <register name="Gpio97" type="memory" device="IOMUX" offset="0x061" size="1" desc="SD0_DATA0_EGPIO97. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="SD0_DATA0_EGPIO97" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin SD0_DATA0. The default IO state is pull-up." />
    </register>

    <!-- page 540 -->

    <register name="Gpio98" type="memory" device="IOMUX" offset="0x062" size="1" desc="SD0_DATA1_EGPIO98. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="SD0_DATA1_EGPIO98" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin SD0_DATA1. The default IO state is pull-up." />
    </register>
    <register name="Gpio99" type="memory" device="IOMUX" offset="0x063" size="1" desc="SD0_DATA2_EGPIO99. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="SD0_DATA2_EGPIO99" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin SD0_DATA2. The default IO state is pull-up." />
    </register>
    <register name="Gpio100" type="memory" device="IOMUX" offset="0x064" size="1" desc="SD0_DATA3_EGPIO100. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="SD0_DATA3_EGPIO100" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin SD0_DATA3. The default IO state is pull-up." />
    </register>
    <register name="Gpio104" type="memory" device="IOMUX" offset="0x068" size="1" desc="LAD0_EMMC_DATA0_EGPIO104. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="LAD0_EMMC_DATA0_EGPIO104" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for LAD0. The default IO state is pull-up." />
    </register>

    <!-- page 541 -->

    <register name="Gpio105" type="memory" device="IOMUX" offset="0x069" size="1" desc="LAD1_EMMC_DATA1_EGPIO105. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="LAD1_EMMC_DATA1_EGPIO105" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for LAD1. The default IO state is pull-up." />
    </register>
    <register name="Gpio106" type="memory" device="IOMUX" offset="0x06A" size="1" desc="LAD2_EMMC_DATA2_EGPIO106. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="LAD2_EMMC_DATA2_EGPIO106" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for LAD2. The default IO state is pull-up." />
    </register>
    <register name="Gpio107" type="memory" device="IOMUX" offset="0x06B" size="1" desc="LAD3_EMMC_DATA3_EGPIO107. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="LAD3_EMMC_DATA3_EGPIO107" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for LAD3. The default IO state is pull-up." />
    </register>
    <register name="Gpio108" type="memory" device="IOMUX" offset="0x06C" size="1" desc="ESPI_ALERT_L_LDRQ0_L_ESPI_ALERT_D1_EGPIO108. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="ESPI_ALERT_L_LDRQ0_L_ESPI_ALERT_D1_EGPIO108" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for LDRQ0_L. The default IO state is pull-down." />
    </register>

    <!-- page 542 -->

    <register name="Gpio109" type="memory" device="IOMUX" offset="0x06D" size="1" desc="ROMTYPE_strap_LFRAME_L_EMMC_DS_EGPIO109. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="ROMTYPE_strap_LFRAME_L_EMMC_DS_EGPIO109" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for LFRAME_L." />
    </register>
    <register name="Gpio113" type="memory" device="IOMUX" offset="0x071" size="1" desc="SCL0_I2C2_SCL_EGPIO113. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="SCL0_I2C2_SCL_EGPIO113" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for SCL0." />
    </register>
    <register name="Gpio114" type="memory" device="IOMUX" offset="0x072" size="1" desc="SDA0_I2C2_SDA_EGPIO114. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="SDA0_I2C2_SDA_EGPIO114" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for SDA0." />
    </register>
    <register name="Gpio115" type="memory" device="IOMUX" offset="0x073" size="1" desc="CLK_REQ1_L_AGPIO115. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="CLK_REQ1_L_AGPIO115" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for CLK_REQ1_L. The default IO state is pull-up." />
    </register>

    <!-- page 543 -->

    <register name="Gpio116" type="memory" device="IOMUX" offset="0x074" size="1" desc="CLK_REQ2_L_AGPIO116. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="CLK_REQ2_L_AGPIO116" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for CLK_REQ2_L. The default IO state is pull-up." />
    </register>
    <register name="Gpio120" type="memory" device="IOMUX" offset="0x078" size="1" desc="CLK_REQ5_L_EGPIO120. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="CLK_REQ5_L_EGPIO120" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin CLK_REQ5_L. The default IO state is pull-down." />
    </register>
    <register name="Gpio121" type="memory" device="IOMUX" offset="0x079" size="1" desc="CLK_REQ6_L_EGPIO121. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="CLK_REQ6_L_EGPIO121" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin EGPIO121. The default IO state is pull-down." />
    </register>
    <register name="Gpio129" type="memory" device="IOMUX" offset="0x081" size="1" desc="ESPI_RESET_L_KBRST_L_AGPIO129. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="ESPI_RESET_L_KBRST_L_AGPIO129" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin KBRST_L. The default IO state is pull-up.  " />
    </register>

    <!-- page 544 -->

    <register name="Gpio130" type="memory" device="IOMUX" offset="0x082" size="1" desc="SATA_ACT_L_AGPIO130. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="SATA_ACT_L_AGPIO130" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin SATA_ACT_L. The default IO state is pull-up." />
    </register>
    <register name="Gpio131" type="memory" device="IOMUX" offset="0x083" size="1" desc="CLK_REQ3_L_SATA_IS1_L_SATA_ZP1_L_EGPIO131. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="CLK_REQ3_L_SATA_IS1_L_SATA_ZP1_L_EGPIO131" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin CLK_REQ3_L. The default IO state is pull-up." />
    </register>
    <register name="Gpio132" type="memory" device="IOMUX" offset="0x084" size="1" desc="CLK_REQG_L_OSCIN_EGPIO132. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="CLK_REQG_L_OSCIN_EGPIO132" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin CLK_REQG_L. The default IO state is pull-up." />
    </register>

    <!-- page 545 -->

    <register name="Gpio135" type="memory" device="IOMUX" offset="0x087" size="1" desc="UART0_CTS_L_UART2_TXD_EGPIO135. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="UART0_CTS_L_UART2_TXD_EGPIO135" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin UART0_CTS_L. The default IO state is pull-down." />
    </register>
    <register name="Gpio136" type="memory" device="IOMUX" offset="0x088" size="1" desc="UART0_RXD_EGPIO136. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="UART0_RXD_EGPIO136" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin UART0_RXD. The default IO state is pull-down." />
    </register>
    <register name="Gpio137" type="memory" device="IOMUX" offset="0x089" size="1" desc="UART0_RTS_L_UART2_RXD_EGPIO137. Read-write. Reset: 01h.">
      <!-- Bits 7:2 reserved. -->
      <field name="UART0_RTS_L_UART2_RXD_EGPIO137" bit="0" size="2" desc="Read-write. Reset: 1h. Multi-function IO pin function select for pin UART0_RTS_L. The default IO state is pull-up." />
    </register>
    <register name="Gpio138" type="memory" device="IOMUX" offset="0x08A" size="1" desc="UART0_TXD_EGPIO138. Read-write. Reset: 01h.">
      <!-- Bits 7:2 reserved. -->
      <field name="UART0_TXD_EGPIO138" bit="0" size="2" desc="Read-write. Reset: 1h. Multi-function IO pin function select for pin UART0_TXD. The default IO state is pull-up." />
    </register>

    <!-- page 546 -->

    <register name="Gpio139" type="memory" device="IOMUX" offset="0x08B" size="1" desc="UART0_INTR_AGPIO139. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="UART0_INTR_AGPIO139" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin UART0_INTR. The default IO state is pull-down." />
    </register>
    <register name="Gpio140" type="memory" device="IOMUX" offset="0x08C" size="1" desc="UART1_CTS_L_UART3_TXD_EGPIO140. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="UART1_CTS_L_UART3_TXD_EGPIO140" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin UART1_CTS_L. The default IO state is pull-down." />
    </register>
    <register name="Gpio141" type="memory" device="IOMUX" offset="0x08D" size="1" desc="UART1_RXD_EGPIO141. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="UART1_RXD_EGPIO141" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin UART1_RXD. The default IO state is pull-down." />
    </register>
    <register name="Gpio142" type="memory" device="IOMUX" offset="0x08E" size="1" desc="UART1_RTS_L_UART3_RXD_EGPIO142. Read-write. Reset: 01h.">
      <!-- Bits 7:2 reserved. -->
      <field name="UART1_RTS_L_UART3_RXD_EGPIO142" bit="0" size="2" desc="Read-write. Reset: 1h. Multi-function IO pin function select for pin UART1_RTS_L. The default IO state is pull-up." />
    </register>

    <!-- page 547 -->

    <register name="Gpio143" type="memory" device="IOMUX" offset="0x08F" size="1" desc="UART1_TXD_EGPIO143. Read-write. Reset: 01h.">
      <!-- Bits 7:2 reserved. -->
      <field name="UART1_TXD_EGPIO143" bit="0" size="2" desc="Read-write. Reset: 1h. Multi-function IO pin function select for pin UART1_TXD. The default IO state is pull-up." />
    </register>
    <register name="Gpio144" type="memory" device="IOMUX" offset="0x090" size="1" desc="UART1_INTR_AGPIO144. Read-write. Reset: 00h.">
      <!-- Bits 7:2 reserved. -->
      <field name="UART1_INTR_AGPIO144" bit="0" size="2" desc="Read-write. Reset: 0h. Multi-function IO pin function select for pin UART1_INTR. The default IO state is pull-down." />
    </register>

    <!-- 9.2.11.2 GPIO Registers -->

    <!-- page 554 -->

    <!-- TODO Multiple BAR instances, keeping only first one: GPIOx000[00...F8] [GPIO Bank 0 Control Register] (FCH::GPIO::GPIOBank0Ctl) -->
    <register name="GPIOBank0Ctl" type="memory" device="GPIO" offset="0x00000" size="4" desc="GPIO Bank 0 Control Register. Each GPIO pin is controlled by 4 bytes. These registers control GPIO bank 0 pins: GPIO[62:00]. GPIOx000[F8,F4,F0,EC,E8,E4,E0,DC,D8,D4,D0,CC,C8,C4,C0,BC,B8,B4,B0,AC,A8,A4,A0,9C,98,94,90,8C,88,84,80,7C,78,74,70,6C,68,64,60,5C,58,54,50,4C,48, 44,40,3C,38,34,30,2C,28,24,20,1C,18,14,10,0C,08,04,00]; GPIO=FED8_1500h">
      <field name="Less10secSts" bit="31" size="1" desc="Read-only. Reset: X. 1=The power button is pressed for less than 10 second in S0 state. This bit is only valid for PWR_BTN_L_AGPIO0. For other GPIOs, this bit is Reserved. This bit can be cleared by writing 1 to InterruptSts bit." />
      <field name="Less2secSts" bit="30" size="1" desc="Read-only. Reset: X. 1=The power button is pressed for less than 2 second in S0 state. This bit is only valid for PWR_BTN_L_AGPIO0. For other GPIOs, this bit is Reserved. When Less2secSts becomes 1, Less10secSts also becomes 1. This bit can be cleared by writing 1 to InterruptSts bit." />
      <field name="WakeSts" bit="29" size="1" desc="Read,Write-1-to-clear. Reset: X. 0=The pin didn't generate a wake event. 1=The pin is a wake source. Wake Status." />
      <field name="InterruptSts" bit="28" size="1" desc="Read,Write-1-to-clear. Reset: X. 0=The pin did not generate an interrupt. 1=The pin is an interrupt source. Interrupt status." />
      <!-- Bits 27:24 reserved. -->
      <field name="OutputEnable" bit="23" size="1" desc="Read-write. Reset: X. 0=Output is disabled on the pin. 1=Output is enabled on the pin. NOTE: I2C buffers are OD only and cannot support push-pull regardless if they are set in GPIO mode or I2C mode." />
      <field name="OutputValue" bit="22" size="1" desc="Read-write. Reset: X. 0=Low. 1=High. When selecting I2C pad, OutputValue == don't care. NOTE: I2C buffers are OD only and cannot support push-pull regardless if they are set in GPIO mode or I2C mode." />
      <field name="PullDownEnable" bit="21" size="1" desc="Read-write. Reset: X. 0=Pull-down is disabled on the pin. 1=Pull-down is enabled on the pin. Pull-down enable is not applicable for an I2C pad." />
      <field name="PullUpEnable" bit="20" size="1" desc="Read-write. Reset: X. 0=Pull-up is disabled on the pin. 1=Pull-up is enabled on the pin. Pull-up enable is not applicable for an I2C pad." />
      <!-- Bit 19 reserved. -->
      <field name="DrvStrengthSel" bit="17" size="2" desc="Read-write. Reset: XXb. 3.3V PAD: x0: Z=40ohms x1: Z=80ohms; 1.8VPAD. NOTE: Drive strengths of 40/60/80 ohms using DrvStrengthSel bit of this GPIO Bank Control Register are not applicable for an I2C pad. I2C pad parameters are controlled by FCH::MISC::I2C3_PadCtrl and FCH::MISC::I2C2_PadCtrl. For example, Drive strength is defined by bits[3:0]." />
      <field name="PinSts" bit="16" size="1" desc="Read-only. Reset: X. 0=The pin is low. 1=The pin is high. This bit is not affected by the debounce logic." />
      <field name="WakeCntrl[2:0]" bit="13" size="3" desc="Read-write. Reset: XXXb. Wake control." />
      <field name="InterruptEnable[1]" bit="12" size="1" desc="Read-write. Reset: X. 0=Disable. 1=Enable interrupt delivery." />
      <field name="InterruptEnable[0]" bit="11" size="1" desc="Read-write. Reset: X. 0=Disable. 1=Enable interrupt status." />
      <field name="ActiveLevel" bit="9" size="2" desc="Read-write. Reset: XXb." />
      <field name="LevelTrig" bit="8" size="1" desc="Read-write. Reset: X. 0=Edge trigger. 1=Level trigger." />
      <field name="DebounceTmrLarge" bit="7" size="1" desc="Read-write. Reset: X. Combined with DebounceTmrOutUnit, this bit changes the unit and max debounce time for the debounce timer. See Table 86 [Debounce Timer Definition]." />
      <field name="DebounceCntrl" bit="5" size="2" desc="Read-write. Reset: XXb." />
      <field name="DebounceTmrOutUnit" bit="4" size="1" desc="Read-write. Reset: X. DebounceTmrLarge and DebounceTmrOutUnit defines the unit and max debounce time for the debounce timer. See Table 86 [Debounce Timer Definition]." />
      <field name="DebounceTmrOut" bit="0" size="4" desc="Read-write. Reset: XXXXb. Specifies the debounce timer out number." />
    </register>

    <!-- page 555 -->

    <register name="GPIOWakeIntMasSwitch" type="memory" device="GPIO" offset="0x00FC" size="4" desc="GPIO_Wake_Inter_Master Switch. Read-write. Reset: FF00_0000h.">
      <field name="GpioWakeEn" bit="31" size="1" desc="Read-write. Reset: 1. 0=All GPIO wakes are blocked." />
      <field name="GpioInterruptEn" bit="30" size="1" desc="Read-write. Reset: 1. 0=All GPIO interrupts are blocked." />
      <field name="EOI" bit="29" size="1" desc="Read-write. Reset: 1. 0=The GPIO interrupt is blocked. 1=Allow GPIO interrupt, hardware clears this bit when interrupt occurs. This software/hardware handshake mechanism is the same as EOS of SMI." />
      <field name="MaskStsEn" bit="28" size="1" desc="Read-write. Reset: 1. 1=Enable hardware to block all wake/interrupt status generation when software Writes to any debounce registers. The length of blocking depends on mask_sts_length[3:0]." />
      <field name="MaskStsLength[3:0]" bit="24" size="4" desc="Read-write. Reset: Fh. See MaskStsEn and MaskStsLength[11:4]. The length of blocking = {MaskStsLength[11:0],14'h3FFF}." />
      <field name="MaskStsLength[11:4]" bit="16" size="8" desc="Read-write. Reset: 00h. See MaskStsEn and MaskStsLength[3:0]." />
      <field name="EnWinBlueBtn" bit="15" size="1" desc="Read-write. Reset: 0. 0=GPIO0 detects debounced power button; Power button override is 4 sec. 1=GPIO0 detects debounced power button in S3/S5/S0I3, and detects &quot;pressed less than 2 sec&quot; and &quot;pressed 2~10 sec&quot; in S0; Power button override is 10 sec." />
      <field name="IntrOutActiveHi" bit="14" size="1" desc="Read-write. Reset: 0. 0=GPIO controller interrupt output is active low. 1=GPIO controller interrupt output is active high." />
      <field name="SelGpio0Src" bit="13" size="1" desc="Select the source for GPIO0 detection. Read-write. Reset: 0. 0=Power button goes to a processing logic first and then goes to GPIO0 detection logic. 1=Power button goes to GPIO0 debounce and then goes to GPIO0 detection logic. The &quot;processing logic&quot; includes 16 ms debounce counter and a logic to detect how long the button has been pressed to generate press_less2s_sts and press_less4s_sts. Only &quot;GPIO0 debounce block&quot; has debounce function." />
      <field name="IntrOutPulse" bit="12" size="1" desc="Read-write. Reset: 0. 0=GPIO controller interrupt output is a level signal. 1=GPIO controller interrupt output is pulse signal. The polarity is defined by IntrOutActiveHi register bit." />
      <!-- Bits 11:0 reserved. -->
    </register>

    <!-- page 556 -->

    <!-- TODO Multiple BAR instances, keeping only first one: GPIOx001[00...FC] [GPIO Bank 1 Control Register] (FCH::GPIO::GPIOBank1Ctl) -->
    <register name="GPIOBank1Ctl" type="memory" device="GPIO" offset="0x00100" size="4" desc="GPIO Bank 1 Control Register. Each GPIO pin is controlled by 4 bytes. These registers control GPIO bank 1 pins: GPIO[127:64]. GPIOx001[FC,F8,F4,F0,EC,E8,E4,E0,DC,D8,D4,D0,CC,C8,C4,C0,BC,B8,B4,B0,AC,A8,A4,A0,9C,98,94,90,8C,88,84,80,7C,78,74,70,6C,68,64,60,5C,58,54,50,4C, 48,44,40,3C,38,34,30,2C,28,24,20,1C,18,14,10,0C,08,04,00]; GPIO=FED8_1500h">
      <!-- Bits 31:30 reserved. -->
      <field name="WakeSts" bit="29" size="1" desc="Read,Write-1-to-clear. Reset: X. 0=The pin didn't generate a wake event. 1=The pin is a wake source. Wake status." />
      <field name="InterruptSts" bit="28" size="1" desc="Read,Write-1-to-clear. Reset: X. 0=The pin didn't generate an interrupt. 1=The pin is an interrupt source. Interrupt status." />
      <!-- Bits 27:24 reserved. -->
      <field name="OutputEnable" bit="23" size="1" desc="Read-write. Reset: X. 0=Output is disabled on the pin. 1=Output is enabled on the pin. NOTE: I2C buffers are OD only and cannot support push-pull regardless if they are set in GPIO mode or I2C mode." />
      <field name="OutputValue" bit="22" size="1" desc="Read-write. Reset: X. 0=Low. 1=High. When selecting I2C pad, OutputValue == don't care. NOTE: I2C buffers are OD only and cannot support push-pull regardless if they are set in GPIO mode or I2C mode." />
      <field name="PullDownEnable" bit="21" size="1" desc="Read-write. Reset: X. 0=Pull-down is disabled on the pin. 1=Pull-down is enabled on the pin. Pull-down enable is not applicable for an I2C pad." />
      <field name="PullUpEnable" bit="20" size="1" desc="Read-write. Reset: X. 0=Pull-up is disabled on the pin. 1=Pull-up is enabled on the pin. Pull-up enable is not applicable for an I2C pad." />
      <!-- Bit 19 reserved. -->
      <field name="DrvStrengthSel" bit="17" size="2" desc="Read-write. Reset: XXb. 3.3V PAD: x0: Z=40ohms x1: Z=80ohms; 1.8VPAD. NOTE: Drive strengths of 40/60/80 ohms using DrvStrengthSel bit of this GPIO Bank Control Register are not applicable for an I2C pad. I2C pad parameters are controlled by FCH::MISC::I2C3_PadCtrl and FCH::MISC::I2C2_PadCtrl. For example, Drive strength is defined by bits[3:0]." />
      <field name="PinSts" bit="16" size="1" desc="Read-only. Reset: X. 0=The pin is low. 1=The pin is high. This bit is not affected by the debounce logic." />
      <field name="WakeCntrl[2:0]" bit="13" size="3" desc="Read-write. Reset: XXXb. Wake control." />
      <field name="InterruptEnable[1:0]" bit="11" size="2" desc="Read-write. Reset: XXb. Enable interrupt status and delivery." />
      <field name="ActiveLevel" bit="9" size="2" desc="Read-write. Reset: XXb." />
      <field name="LevelTrig" bit="8" size="1" desc="Read-write. Reset: X. 0=Edge trigger. 1=Level trigger." />
      <field name="DebounceTmrLarge" bit="7" size="1" desc="Read-write. Reset: X. Combined with DebounceTmrOutUnit, this bit changes the unit and max debounce time for the debounce timer. See Table 86 [Debounce Timer Definition]." />
      <field name="DebounceCntrl" bit="5" size="2" desc="Read-write. Reset: XXb." />
      <field name="DebounceTmrOutUnit" bit="4" size="1" desc="Read-write. Reset: X. DebounceTmrLarge and DebounceTmrOutUnit defines the unit and max debounce time for the debounce timer. See Table 86 [Debounce Timer Definition]." />
      <field name="DebounceTmrOut" bit="0" size="4" desc="Read-write. Reset: XXXXb. Specifies the debounce timer out number." />
    </register>

    <!-- page 557 -->

    <!-- TODO Multiple BAR instances, keeping only first one: GPIOx002[00...EC] [GPIO Bank 2 Control Register] (FCH::GPIO::GPIOBank2Ctl) -->
    <register name="GPIOBank2Ctl" type="memory" device="GPIO" offset="0x00200" size="4" desc="GPIO Bank 2 Control Register. Each GPIO pin is controlled by 4 bytes. These registers control GPIO Bank 2 pins: GPIO[187:128]. GPIOx002[EC,E8,E4,E0,DC,D8,D4,D0,CC,C8,C4,C0,BC,B8,B4,B0,AC,A8,A4,A0,9C,98,94,90,8C,88,84,80,7C,78,74,70,6C,68,64,60,5C,58,54,50,4C,48,44,40,3C, 38,34,30,2C,28,24,20,1C,18,14,10,0C,08,04,00]; GPIO=FED8_1500h">
      <!-- Bits 31:30 reserved. -->
      <field name="WakeSts" bit="29" size="1" desc="Read,Write-1-to-clear. Reset: X. 0=The pin did not generate a wake event. 1=The pin is a wake source. Wake status." />
      <field name="InterruptSts" bit="28" size="1" desc="Read,Write-1-to-clear. Reset: X. 0=The pin did not generate an interrupt. 1=The pin is an interrupt source. Interrupt status." />
      <!-- Bits 27:24 reserved. -->
      <field name="OutputEnable" bit="23" size="1" desc="Read-write. Reset: X. 0=Output is disabled on the pin. 1=Output is enabled on the pin. NOTE: I2C buffers are OD only and cannot support push-pull regardless if they are set in GPIO mode or I2C mode." />
      <field name="OutputValue" bit="22" size="1" desc="Read-write. Reset: X. 0=Low. 1=High. When selecting I2C pad, Outputvalue == don't care. NOTE: I2C buffers are OD only and cannot support push-pull regardless if they are set in GPIO mode or I2C mode." />
      <field name="PullDownEnable" bit="21" size="1" desc="Read-write. Reset: X. 0=Pull-down is disabled on the pin. 1=Pull-down is enabled on the pin. Pull-down enable is not applicable to I2C pad." />
      <field name="PullUpEnable" bit="20" size="1" desc="Read-write. Reset: X. 0=Pull-up is disabled on the pin. 1=Pull-up is enabled on the pin. Pull-up enable is not applicable to I2C pad." />
      <!-- Bit 19 reserved. -->
      <field name="DrvStrengthSel" bit="17" size="2" desc="Read-write. Reset: XXb. 3.3V PAD: x0: Z=40ohms x1: Z=80ohms; 1.8VPAD. NOTE: Drive strengths of 40/60/80 ohms using DrvStrengthSel bit of this GPIO Bank Control Register are not applicable to I2C pad. I2C pad parameters are controlled by FCH::MISC::I2C3_PadCtrl and FCH::MISC::I2C2_PadCtrl. For example, Drive strength is defined by bits[3:0]." />
      <field name="PinSts" bit="16" size="1" desc="Read-only. Reset: X. 0=The pin is low. 1=The pin is high. This bit is not affected by the debounce logic." />
      <field name="WakeCntrl[2:0]" bit="13" size="3" desc="Read-write. Reset: XXXb. Wake control." />
      <field name="InterruptEnable[1:0]" bit="11" size="2" desc="Read-write. Reset: XXb. Enable interrupt status and delivery." />
      <field name="ActiveLevel" bit="9" size="2" desc="Read-write. Reset: XXb." />
      <field name="LevelTrig" bit="8" size="1" desc="Read-write. Reset: X. 0=Edge trigger. 1=Level trigger." />
      <field name="DebounceTmrLarge" bit="7" size="1" desc="Read-write. Reset: X. Combined with DebounceTmrOutUnit, this bit changes the unit and max debounce time for the debounce timer. See Table 86 [Debounce Timer Definition]." />
      <field name="DebounceCntrl" bit="5" size="2" desc="Read-write. Reset: XXb." />
      <field name="DebounceTmrOutUnit" bit="4" size="1" desc="Read-write. Reset: X. DebounceTmrLarge and DebounceTmrOutUnit defines the unit and max debounce time for the debounce timer. See Table 86 [Debounce Timer Definition]." />
      <field name="DebounceTmrOut" bit="0" size="4" desc="Read-write. Reset: XXXXb. Specifies the debounce timer out number." />
    </register>

    <!-- page 559 -->

    <register name="GPIOWakeStatIndex0" type="memory" device="GPIO" offset="0x02F0" size="4" desc="GPIO_Wake_Status_Index_0. Read-only. Reset: 0000_0000h.">
      <field name="WakeStatusIndex[31:16]" bit="16" size="16" desc="Read-only. Reset: 0000h. When bit[N] is1, at least one wake status of GPIO N*4 ~ N*4+3 is 1." />
      <field name="WakeStatusIndex[15]" bit="15" size="1" desc="Read-only. Reset: 0. 0=None of the GPIO[62:60] wake status are 1. 1=At least one wake status of GPIO[62:60] is 1. When this bit is 1, at least one wake status of GPIO[62:60] is 1." />
      <field name="WakeStatusIndex[14:0]" bit="0" size="15" desc="Read-only. Reset: 0000h. When bit[N] is1, at least one wake status of GPIO N*4 ~ N*4+3 is 1." />
    </register>
    <register name="GPIOWakeStatIndex1" type="memory" device="GPIO" offset="0x02F4" size="4" desc="GPIO_Wake_Status_Index_1. Read-only. Reset: 0000_0000h.">
      <!-- Bits 31:16 reserved. -->
      <field name="NBGppPmeWake" bit="15" size="1" desc="Read-only. Reset: 0. 0=No NBGPP PME wake event. 1=NBGPP has sent PME to wake the system. One wake status is set in GPIO Bank3 register." />
      <!-- Bit 14 reserved. -->
      <field name="WakeStatusIndex[13:0]" bit="0" size="14" desc="Read-only. Reset: 0000h. For each bit, 1=At least one of the wake status of GPIO N*4 ~ N*4+3 is 1." />
    </register>

    <!-- page 560 -->

    <register name="GPIOIntStatIndex0" type="memory" device="GPIO" offset="0x02F8" size="4" desc="GPIO_Interrupt_Status_Index_0. Read-only. Reset: 0000_0000h.">
      <field name="InterruptStatusIndex[31:16]" bit="16" size="16" desc="Read-only. Reset: 0000h. When bit[N] is 1, at least one interrupt status of GPIO N*4 ~ N*4+3 is 1." />
      <field name="InterruptStatusIndex[15]" bit="15" size="1" desc="Read-only. Reset: 0. 0=None of the GPIO[62:60] interrupt status are 1. 1=At least one interrupt status of GPIO[62:60] is 1. When this bit is 1, at least one of the interrupt status of GPIO[62:60] is 1." />
      <field name="InterruptStatusIndex[14:0]" bit="0" size="15" desc="Read-only. Reset: 0000h. When bit[N] is 1, at least one interrupt status of GPIO N*4 ~ N*4+3 is 1." />
    </register>

    <!-- page 561 -->

    <register name="GPIOIntStatIndex1" type="memory" device="GPIO" offset="0x02FC" size="4" desc="GPIO_Interrupt_Status_Index_1. Reset: 1F00_0000h.">
      <!-- Bits 31:29 reserved. -->
      <field name="MaskStsEn" bit="28" size="1" desc="Read-write. Reset: 1. 0=Disable. 1=Enable hardware to block all wake/interrupt status generation when software writes to any debounce registers. The length of blocking depends on MaskStsLength[3:0]." />
      <field name="MaskStsLength[3:0]" bit="24" size="4" desc="Read-write. Reset: Fh. See also MaskStsEn and MaskStsLength[11:4]. The length of blocking = {MaskStsLength[11:0], 14'h3FFF}." />
      <field name="MaskStsLength[11:4]" bit="16" size="8" desc="Read-write. Reset: 00h. See MaskStsEn and MaskStsLength[3:0]. MaskStsLength[11:0] = {MaskStsLength[11:4],MaskStsLength[3:0]}." />
      <field name="NBGppPmeIntr" bit="15" size="1" desc="Read-only. Reset: 0. 0=No NB GPP PME event. 1=NB GPP has sent PME (one of the interrupt status bits are set in the GPIO Bank3 register)." />
      <!-- Bit 14 reserved. -->
      <field name="InterruptStatusIndex[13:0]" bit="0" size="14" desc="Read-only. Reset: 0000h. For each bit, at least one interrupt status of GPIO N*4 ~ N*4+3 is 1." />
    </register>

    <!-- TODO Multiple BAR instances, keeping only first one: GPIOx003[00...FC] [GPIO Bank 3 Control Register] (FCH::GPIO::GPIOBank3Ctl) -->
    <register name="GPIOBank3Ctl" type="memory" device="GPIO" offset="0x00300" size="4" desc="GPIO Bank 3 Control Register. Each GPIO pin is controlled by 4 bytes. These registers control GPIO bank 3 pins: GPIO[224:193]. GPIOx003[FC,F8,F4,F0,EC,E8,E4,E0,DC,D8,D4,D0,CC,C8,C4,C0,BC,B8,B4,B0,AC,A8,A4,A0,9C,98,94,90,8C,88,84,80,7C,78,74,70,6C,68,64,60,5C,58,54,50,4C, 48,44,40,3C,38,34,30,2C,28,24,20,1C,18,14,10,0C,08,04,00]; GPIO=FED8_1500h">
      <!-- Bits 31:30 reserved. -->
      <field name="WakeSts" bit="29" size="1" desc="Read,Write-1-to-clear. Reset: X. 0=The pin did not generate a wake event. 1=The pin is a wake source. Wake status." />
      <field name="InterruptSts" bit="28" size="1" desc="Read,Write-1-to-clear. Reset: X. 0=The pin did not generate an interrupt. 1=The pin is an interrupt source. Interrupt status." />
      <!-- Bits 27:17 reserved. -->
      <field name="PinSts" bit="16" size="1" desc="Read-only. Reset: X. 0=The pin is low. 1=The pin is high. This bit is not affected by the debounce logic." />
      <field name="WakeCntrl[2:0]" bit="13" size="3" desc="Read-write. Reset: XXXb. Wake control." />
      <field name="InterruptEnable[1:0]" bit="11" size="2" desc="Read-write. Reset: XXb. Enable interrupt status and delivery." />
      <field name="ActiveLevel" bit="9" size="2" desc="Read-write. Reset: XXb." />
      <field name="LevelTrig" bit="8" size="1" desc="Read-write. Reset: X. 0=Edge trigger. 1=Level trigger." />
      <!-- Bits 7:0 reserved. -->
    </register>

    <!-- 9.2.12.1 SD Configuration Registers (SD) -->

    <!-- page 562 -->

    <register name="SD_PCI_DEV_VEN_ID" type="pcicfg" device="SD" offset="0x000" size="4" desc="FCH::SD::SD_PCI_DEV_VEN_ID. Read-only. Reset: 7906_1022h.">
      <field name="DEV_ID" bit="16" size="16" desc="Read-only. Reset: 7906h. Device ID." />
      <field name="VEND_ID" bit="0" size="16" desc="Read-only. Reset: 1022h. Vendor ID." />
    </register>
    <register name="SD_PCI_CMD_STS" type="pcicfg" device="SD" offset="0x004" size="4" desc="FCH::SD::SD_PCI_CMD_STS.">
      <field name="Det_Perr" bit="31" size="1" desc="Read-only. Reset: 0. This bit is set by the device whenever it detects a parity error, even if parity error handling is disabled (as controlled by Parity_EN bit)." />
      <field name="Sig_SysErr" bit="30" size="1" desc="Read-only. Reset: 0. 0=SERR# not asserted. 1=SERR# asserted. Set whenever the device asserts SERR#." />
      <field name="Rec_Mabort" bit="29" size="1" desc="Read-only. Reset: 0. 0=Cycle not terminted with Master Abort. 1=Cycle terminted with Master Abort. This bit is set by a master device whenever its transaction (except for Special Cycle) is terminated with   Master Abort." />
      <field name="Rec_Tabort" bit="28" size="1" desc="Read-only. Reset: 0. 0=PCI cycle not aborted. 1=PCI cycle is aborted by a PCI terget. This bit is set by a master device whenever its transaction is terminated with Target-Abort." />
      <field name="Sig_Tabort" bit="27" size="1" desc="Read-only. Reset: 0. 0=Target Abort not signaled. 1=Target Abort signaled. This bit is set by a target device whenever it terminates a transaction with Target Abort." />
      <field name="DEVSEL_Timing" bit="25" size="2" desc="Read-only. Reset: Fixed,1h. Medium timing selected." />
      <field name="Master_DPerr" bit="24" size="1" desc="Read-only. Reset: 0. 0=No data parity error. 1=Detects PERR# asserted while acting as PCI master. Master Data Parity error." />
      <field name="Fast_B2B_Cap" bit="23" size="1" desc="Read-only. Reset: Fixed,0. 0=Disallow. 1=Allow. Allows Fast Back-to-Back capability." />
      <field name="PCI_ST_Reserved2" bit="22" size="1" desc="Read-only. Reset: Fixed,0. Reserved." />
      <field name="En_66MHz" bit="21" size="1" desc="Read-only. Reset: Fixed,1. indicating 66MHz capable." />
      <field name="Cap_List" bit="20" size="1" desc="Read-only. Reset: 1. indicating no Capabilities linked list available." />
      <field name="Int_status" bit="19" size="1" desc="Read-only. Reset: 0. Reflects the state of the interrupt in the device/function." />
      <field name="PCI_ST_Reserved1" bit="16" size="3" desc="Read-only. Reset: Fixed,0h. Reserved." />
      <field name="PCI_CMD_Reserved2" bit="11" size="5" desc="Read-write. Reset: Fixed,00h. Reserved." />
      <field name="Int_Dis" bit="10" size="1" desc="Read-write. Reset: 0. 0=Enables the assertion of the device/function's INTx# signal. 1=Disable. Interrutp disable." />
      <field name="Fast_B2B_En" bit="9" size="1" desc="Read-only. Reset: Fixed,0. 0=Fast back-to-back transactions allowed only to the same agent. 1=Fast back-to-back transactions not allowed. Hard-wired to 0, indicating fast back-to-back transactions to the same agent only are allowed." />
      <field name="SERRB_En" bit="8" size="1" desc="Read-write. Reset: 0. 0=Disable the SERR# driver. 1=Enable the SERR# driver. SERR# driver enable." />
      <field name="PCI_CMD_Reserved1" bit="7" size="1" desc="Read-only. Reset: Fixed,0. Reserved." />
      <field name="Parity_En" bit="6" size="1" desc="Read-write. Reset: 0. 0=Parity check disabled. 1=Device must take action when a parity error is detected. Parity error detect." />
      <field name="VGA_Pal_Access" bit="5" size="1" desc="Read-only. Reset: Fixed,0. 0=Disallow. 1=Allow. Allow snoop VGA palette cycles." />
      <field name="MemWr_Inv_Cmd" bit="4" size="1" desc="Read-only. Reset: Fixed,0. 0=Disallow. 1=Allow. Allow Memory Write and Invalidate command." />
      <field name="Special_Cycle" bit="3" size="1" desc="Read-only. Reset: Fixed,0. 0=Special cycle recognition disable. 1=Special cycle recognition enable. Special cycle recognition." />
      <field name="Bus_Master" bit="2" size="1" desc="Read-write. Reset: 0. 0=Disallow. 1=Allow. Allow the device to behave as a bus master." />
      <field name="Mem_Space_Access" bit="1" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Memory Space access enable." />
      <field name="IO_Space_Access" bit="0" size="1" desc="Read-only. Reset: Fixed,0. 0=Disable. 1=Enable. IO Space access enable." />
    </register>

    <!-- page 563 -->

    <register name="SD_PCI_REV_ID" type="pcicfg" device="SD" offset="0x008" size="4" desc="FCH::SD::SD_PCI_REV_ID.">
      <field name="BC" bit="24" size="8" desc="Read-write. Reset: 08h. Base Class Code. Hard-wired to 08h, indicating general peripheral." />
      <field name="SC" bit="16" size="8" desc="Read-write. Reset: 05h. Sub Class Code. Hard-wired to 05h, indicating SD host controller." />
      <field name="PI" bit="8" size="8" desc="Read-only. Reset: 01h. Programming Interface Code. Hard-wired to 01h for Standard host supporting DMA." />
      <field name="Revision_ID" bit="0" size="8" desc="Read-only. Reset: Fixed,01h. Revision ID." />
    </register>
    <register name="SD_PCI_MISC" type="pcicfg" device="SD" offset="0x00C" size="4" desc="FCH::SD::SD_PCI_MISC.">
      <field name="BIST" bit="24" size="8" desc="Read-only. Reset: Fixed,00h. Hard-wired to 00h, indicating no build-in BIST support." />
      <field name="Header_Type" bit="16" size="8" desc="Read-only. Reset: Fixed,80h. Bit[23] hard-wired to 1, indicating a single-function device. Bit[22:16] hard-wired to 00h." />
      <field name="Latency_Timer" bit="11" size="5" desc="Read-write. Reset: 00h. Latency_timer_HW bits[10:8] hard-wired to 000b, resulting in a timer granularity of at least eight clocks. This field specifies, in units of PCI bus clocks, the value of the Latency Timer for this PCI bus master." />
      <field name="Latency_Timer_HW" bit="8" size="3" desc="Read-only. Reset: Fixed,0h. Specifies the value of the Latency Timer in units of PCICLKs." />
      <field name="Cache_Size" bit="0" size="8" desc="Read-write. Reset: 00h. This Read/Write field specifies the system cacheline size in units of DWORDs and must be initialized to 00h." />
    </register>

    <!-- page 564 -->

    <register name="SD_PCI_BAR" type="pcicfg" device="SD" offset="0x010" size="4" desc="FCH::SD::SD_PCI_BAR.">
      <field name="BAR" bit="8" size="24" desc="Read-write. Reset: 00_0000h. Base Address. Specifies the upper 15 bits of the 32-bit starting base address." />
      <field name="BAR_Reserved" bit="4" size="4" desc="Read-only. Reset: Fixed,0h. Reserved." />
      <field name="PM" bit="3" size="1" desc="Read-only. Reset: Fixed,0. Prefetch memory. A constant value of 0 indicates that there is no support for memory prefetch." />
      <field name="TP" bit="1" size="2" desc="Read-only. Reset: 2h. 2'b10 indicates that the base register is 64-bit width" />
      <field name="IND" bit="0" size="1" desc="Read-only. Reset: Fixed,0. Resource Type Indicator. A constant value of 0 indicates that the operational registers of the device are mapped into memory space of the main memory of the PC host system." />
    </register>
    <register name="SD_PCI_UPPER_BAR" type="pcicfg" device="SD" offset="0x014" size="4" desc="FCH::SD::SD_PCI_UPPER_BAR. Read-write. Reset: 0000_0000h.">
      <field name="UBAR" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Upper 32 bits of Base Address." />
    </register>
    <register name="SD_PCI_SUB_VEN_SYS_ID" type="pcicfg" device="SD" offset="0x02C" size="4" desc="FCH::SD::SD_PCI_SUB_VEN_SYS_ID. Read,Write-once. Reset: 7806_1022h.">
      <field name="Sub_System_ID" bit="16" size="16" desc="Read,Write-once. Reset: 7806h. Can only be written once by software." />
      <field name="Sub_Vendor_ID" bit="0" size="16" desc="Read,Write-once. Reset: 1022h. Can only be written once by software." />
    </register>
    <register name="SD_PCI_CAP_PTR" type="pcicfg" device="SD" offset="0x034" size="1" desc="FCH::SD::SD_PCI_CAP_PTR. Read-only. Reset: 80h.">
      <field name="CAP_PTR" bit="0" size="8" desc="Read-only. Reset: 80h. The first pointer of the Capability block. To the Function Level Reset (FLR) register." />
    </register>
    <register name="SD_PCI_INT_LINE" type="pcicfg" device="SD" offset="0x03C" size="4" desc="FCH::SD::SD_PCI_INT_LINE. Reset: 0000_0100h.">
      <field name="MAX_LAT" bit="24" size="8" desc="Read-only. Reset: 00h. Hardwired to 00h to indicate no major requirements for the settings of the Latency Timers." />
      <field name="MIN_GNT" bit="16" size="8" desc="Read-only. Reset: 00h. Hardwired to 00h to indicate no major requirements for the settings of the Latency Timers." />
      <field name="Int_Pin" bit="8" size="8" desc="Read-write. Reset: 01h. Hard-wired to 01h, corresponding to using INTA#" />
      <field name="Int_Line" bit="0" size="8" desc="Read-write. Reset: 00h. The Interrupt Line register used to communicate interrupt line routing information." />
    </register>

    <!-- page 565 -->

    <register name="SLOT_IMFORMATION" type="pcicfg" device="SD" offset="0x040" size="4" desc="FCH::SD::SLOT_IMFORMATION. Read-only.">
      <!-- Bits 31:8 reserved. -->
      <field name="Slot_Reserved2" bit="7" size="1" desc="Read-only. Reset: Fixed,0. Reserved." />
      <field name="Num_Of_Slot" bit="4" size="3" desc="Read-only. Reset: Fixed,0h. Hardwired to 000h to indicate only 1 slot." />
      <field name="Slot_Reserved1" bit="3" size="1" desc="Read-only. Reset: Fixed,0. Reserved." />
      <field name="First_BAR" bit="0" size="3" desc="Read-only. Reset: 0h. Hardwired to 000b to indicate BAR0 (Base address 10h)." />
    </register>
    <register name="SD_PCI_MSI_CAP_HEADER" type="pcicfg" device="SD" offset="0x080" size="2" desc="FCH::SD::SD_PCI_MSI_CAP_HEADER. Read-only. Reset: 9005h.">
      <field name="CAP_NXT_PTR" bit="8" size="8" desc="Read-only. Reset: 90h. Pointer to the next item in the capabilities list." />
      <field name="CAP_ID" bit="0" size="8" desc="Read-only. Reset: 05h. 05h indicates MSI." />
    </register>
    <register name="SD_PCI_MSI_CTRL" type="pcicfg" device="SD" offset="0x082" size="2" desc="FCH::SD::SD_PCI_MSI_CTRL.">
      <field name="MSI_CTRL_Reserved" bit="8" size="8" desc="Read-only. Reset: Fixed,00h. Reserved." />
      <field name="Extend_Addr_En" bit="7" size="1" desc="Read-only. Reset: 1. 0=Not capable. 1=Capable. 64-bit Address Capable." />
      <field name="Mul_Msg_En" bit="4" size="3" desc="Read-write. Reset: 0h. Multiple Message Enable." />
      <field name="Mul_Msg_Cap" bit="1" size="3" desc="Read-only. Reset: Fixed,0h. Multiple Message Capable." />
      <field name="MSI_Enable" bit="0" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. MSI Enable." />
    </register>
    <register name="SD_PCI_MSI_ADDR" type="pcicfg" device="SD" offset="0x084" size="4" desc="FCH::SD::SD_PCI_MSI_ADDR.">
      <field name="Msg_Addr" bit="2" size="30" desc="Read-write. Reset: 0000_0000h. Message Address." />
      <field name="MSI_ADDR_Reserved" bit="0" size="2" desc="Read-only. Reset: Fixed,0h. Reserved." />
    </register>
    <register name="SD_PCI_MSI_U_ADDR" type="pcicfg" device="SD" offset="0x088" size="4" desc="FCH::SD::SD_PCI_MSI_U_ADDR. Read-write. Reset: 0000_0000h.">
      <field name="Msg_Upper_Addr" bit="0" size="32" desc="Read-write. Reset: 0000_0000h. Message Upper Address." />
    </register>
    <register name="SD_PCI_MSI_DATA" type="pcicfg" device="SD" offset="0x08C" size="2" desc="FCH::SD::SD_PCI_MSI_DATA. Read-write. Reset: 0000h.">
      <field name="Msg_Data" bit="0" size="16" desc="Read-write. Reset: 0000h. Message Data." />
    </register>
    <register name="SD_PCI_PMC_CAP_HEADER" type="pcicfg" device="SD" offset="0x090" size="2" desc="FCH::SD::SD_PCI_PMC_CAP_HEADER. Read-only. Reset: 0001h.">
      <field name="CAP_NXT_PTR" bit="8" size="8" desc="Read-only. Reset: 00h. Pointer to the next item in the capabilities list." />
      <field name="CAP_ID" bit="0" size="8" desc="Read-only. Reset: 01h. Power Management." />
    </register>

    <!-- page 566 -->

    <register name="SD_PCI_PMC_CAP" type="pcicfg" device="SD" offset="0x092" size="2" desc="FCH::SD::SD_PCI_PMC_CAP. Read-only. Reset: Fixed,8003h.">
      <field name="PME_Support" bit="11" size="5" desc="Read-only. Reset: Fixed,10h. This 5-bit field indicates the power states in which the function may assert PME#. A value of 0 for any bits indicates that the function is not capable of asserting the PME# signal while in that power state." />
      <field name="D2_Support" bit="10" size="1" desc="Read-only. Reset: Fixed,0. D2 Power Management State." />
      <field name="D1_Support" bit="9" size="1" desc="Read-only. Reset: Fixed,0. D1 Power Management State." />
      <field name="Aux_Current" bit="6" size="3" desc="Read-only. Reset: Fixed,0h. 3.3V auxillary current requirements." />
      <field name="DSI" bit="5" size="1" desc="Read-only. Reset: Fixed,0. Device Specific Initialization." />
      <field name="PMC_Reserved" bit="4" size="1" desc="Read-only. Reset: Fixed,0. Reserved." />
      <field name="PME_Clock" bit="3" size="1" desc="Read-only. Reset: Fixed,0. If PME depends on PCI clock." />
      <field name="PMC_Version" bit="0" size="3" desc="Read-only. Reset: Fixed,3h. 011b indicates compliance to revision 1.2 of the PCI Power Management Interface Spec." />
    </register>
    <register name="SD_PCI_PMCSR" type="pcicfg" device="SD" offset="0x094" size="2" desc="FCH::SD::SD_PCI_PMCSR.">
      <field name="PME_Status" bit="15" size="1" desc="Read-write. Reset: 0. Set when the function normally asserts the PME# signal independent of the state of PME# Enable" />
      <field name="Data_Scale" bit="13" size="2" desc="Read-only. Reset: Fixed,0h. Indicates the scaling factor to be used when interpreting the value of the Data register. The value and meaning of this field varries depending on which data value has been selected by the Data_Select field." />
      <field name="Data_Select" bit="9" size="4" desc="Read-write. Reset: 0h. Selects which data is to be reported through the Data register and Data_Scale field." />
      <field name="PME_EN" bit="8" size="1" desc="Read-write. Reset: 0. 0=PME# assertion is disabled. 1=Enable the function to assert PME#. PME# Enable." />
      <field name="PMCSR_Reserved2" bit="4" size="4" desc="Read-only. Reset: Fixed,0h. Reserved." />
      <field name="No_Soft_Reset" bit="3" size="1" desc="Read-only. Reset: Fixed,1. 1=Indicates that devices transitioning from D3hot to D0 because of PowerState commands do not perform an internal reset." />
      <field name="PMCSR_Reserved1" bit="2" size="1" desc="Read-only. Reset: Fixed,0. Reserved." />
      <field name="PowerState" bit="0" size="2" desc="Read-write. Reset: 0h. Initiates Power State." />
    </register>
    <register name="SD_PCI_PMC_BSE" type="pcicfg" device="SD" offset="0x096" size="1" desc="FCH::SD::SD_PCI_PMC_BSE. Read-only. Reset: Fixed,00h.">
      <field name="BPCC_En" bit="7" size="1" desc="Read-only. Reset: Fixed,0. Bus Power/Clock Control enable." />
      <field name="B2_B3" bit="6" size="1" desc="Read-only. Reset: Fixed,0. B2/B3 support for D3hot" />
      <field name="PMC_BSE_Reserved" bit="0" size="6" desc="Read-only. Reset: Fixed,00h. Reserved." />
    </register>
    <register name="SD_PCI_PMC_DATA" type="pcicfg" device="SD" offset="0x097" size="1" desc="FCH::SD::SD_PCI_PMC_DATA. Read-only. Reset: 00h.">
      <field name="PMC_Data" bit="0" size="8" desc="Read-only. Reset: 00h. Reports the state dependent data requested by the Data_Select field. The value of this register is scaled by the value reported by the Data_Scale field." />
    </register>

    <!-- 9.2.12.2 SD Host Controller Memory Mapped Registers (SDHC) -->

    <!-- page 567 -->

    <register name="SDHC_SYS_ADDR" type="mmio" bar="SDHC" offset="0x000" size="4" desc="FCH::SD::MMIO::SDHC_SYS_ADDR. Read-write. Reset: 0000_0000h.">
      <field name="SYS_ADDR1" bit="16" size="16" desc="Read-write. Reset: 0000h. Upper bits. By updating this register, DMA_WAIT will be cleared. System Address. It indicates system memory address for the DMA. When DMA transfer detects the DMA Buffer Boundary specified by FCH::SD::MMIO::SDHC_BLK_CS[DMA_BUF_BNDRY], the SD controller asserts DMA_WAIT. Also, the SD controller generates a DMA interrupt at this time in the case that corresponding bits in the Normal Interrupt Status Enable register and Normal Interrupt Signal Enable register are set. While ADMA is enabled, this regiseter will not be used." />
      <field name="SYS_ADDR0" bit="0" size="16" desc="Read-write. Reset: 0000h. Lower bits. By updating this register, DMA_WAIT will be cleared." />
    </register>
    <register name="SDHC_BLK_CS" type="mmio" bar="SDHC" offset="0x004" size="4" desc="FCH::SD::MMIO::SDHC_BLK_CS.">
      <field name="BLK_CNT" bit="16" size="16" desc="Read-write. Reset: 0000h. Block count. It indicates block count of multiple data transfer. It is enabled when FCH::SD::MMIO::SDHC_CMD_TRN[BLK_CNT_EN] == 1. It is decremented after each block data transmission. During infinite data transmission, the setting of this bit is meaningless." />
      <!-- Bit 15 reserved. -->
      <field name="DMA_BUF_BNDRY" bit="12" size="3" desc="Read-write. Reset: 0h. Host DMA buffer boundary. Indicates the contiguous buffer size in the system memory. When this boundary is reached internally, a DMA interrupt will be generated." />
      <field name="BLK_SIZE" bit="0" size="12" desc="Read-write. Reset: 000h. Transfer data length (Max. block size is 2K bytes). When FCH::SD::MMIO::SDHC_CE_ATA_CTRL[CE_ATA_EN] == 1, a value of 0x000 indicates a block size of 4K bytes." />
    </register>
    <register name="SDHC_CMD_ARG" type="mmio" bar="SDHC" offset="0x008" size="4" desc="FCH::SD::MMIO::SDHC_CMD_ARG. Read-write. Reset: 0000_0000h.">
      <field name="ARGUMENT1" bit="16" size="16" desc="Read-write. Reset: 0000h. Upper bits. Command Argument. Command arguments specified as bits[39:8] of the command format." />
      <field name="ARGUMENT0" bit="0" size="16" desc="Read-write. Reset: 0000h. Lower bits." />
    </register>
    <register name="SDHC_CMD_TRN" type="mmio" bar="SDHC" offset="0x00C" size="4" desc="FCH::SD::MMIO::SDHC_CMD_TRN.">
      <!-- Bits 31:30 reserved. -->
      <field name="CMD_IDX" bit="24" size="6" desc="Read-write. Reset: 00h. Command index." />
      <field name="CMD_TYPE" bit="22" size="2" desc="Read-write. Reset: 0h. Command type." />
      <field name="DATA_PRSNT" bit="21" size="1" desc="Read-write. Reset: 0. 0=No data. 1=Data. Data present select. Indicates that data is present and will be transferred on the DAT line. When a command is issued with this bit enabled, the internal buffer will be cleared." />
      <field name="CMD_IDX_CHK_EN" bit="20" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Command index check enable." />
      <field name="CRC_CHK_EN" bit="19" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Command CRC check enable." />
      <!-- Bit 18 reserved. -->
      <field name="RESP_TYPE" bit="16" size="2" desc="Read-write. Reset: 0h. Response type select." />
      <!-- Bits 15:6 reserved. -->
      <field name="MULTI_BLK" bit="5" size="1" desc="Read-write. Reset: 0. 0=Single block. 1=Multiple blocks. Multiple/Single block select." />
      <field name="DATA_DIR" bit="4" size="1" desc="Read-write. Reset: 0. 0=Write. 1=Read. Data transfer direction." />
      <!-- Bit 3 reserved. -->
      <field name="ACMD12_EN" bit="2" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Auto CMD12 enable. It is not valid when FCH::SD::MMIO::SDHC_CMD_TRN[BLK_CNT_EN] == 0." />
      <field name="BLK_CNT_EN" bit="1" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Block count enable." />
      <field name="DMA_EN" bit="0" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. DMA enable." />
    </register>

    <!-- page 568 -->

    <register name="SDHC_RESP1_0" type="mmio" bar="SDHC" offset="0x010" size="4" desc="FCH::SD::MMIO::SDHC_RESP1_0. Read-only. Reset: 0000_0000h.">
      <field name="RESPONSE1" bit="16" size="16" desc="Read-only. Reset: 0000h. Response. R[39:24] of the response is saved in this field. The value is preseved until the next response." />
      <field name="RESPONSE0" bit="0" size="16" desc="Read-only. Reset: 0000h. R[23:8] of the response is saved in this field." />
    </register>
    <register name="SDHC_RESP3_2" type="mmio" bar="SDHC" offset="0x014" size="4" desc="FCH::SD::MMIO::SDHC_RESP3_2. Read-only. Reset: 0000_0000h.">
      <field name="RESPONSE3" bit="16" size="16" desc="Read-only. Reset: 0000h. Response. R[71:56] of response is saved in this field. The value is preseved until the next response." />
      <field name="RESPONSE2" bit="0" size="16" desc="Read-only. Reset: 0000h. R[55:40] of response is saved in this field." />
    </register>
    <register name="SDHC_RESP5_4" type="mmio" bar="SDHC" offset="0x018" size="4" desc="FCH::SD::MMIO::SDHC_RESP5_4. Read-only. Reset: 0000_0000h.">
      <field name="RESPONSE5" bit="16" size="16" desc="Read-only. Reset: 0000h. Response. R[103:88] of response is saved in this field. The value is preseved until the next response." />
      <field name="RESPONSE4" bit="0" size="16" desc="Read-only. Reset: 0000h. R[87:72] of response is saved in this field." />
    </register>

    <!-- page 569 -->

    <register name="SDHC_RESP7_6" type="mmio" bar="SDHC" offset="0x01C" size="4" desc="FCH::SD::MMIO::SDHC_RESP7_6. Read-only. Reset: 0000_0000h.">
      <field name="RESPONSE7" bit="16" size="16" desc="Read-only. Reset: 0000h. Response. R[127:120] of response or R[39:24] of Auto CMD12 response is saved in this field. The value is preseved until the next response." />
      <field name="RESPONSE6" bit="0" size="16" desc="Read-only. Reset: 0000h. R[119:104] of response or R[23:8] of Auto CMD12 response is saved in this field." />
    </register>
    <register name="SDHC_BUFFER" type="mmio" bar="SDHC" offset="0x020" size="4" desc="FCH::SD::MMIO::SDHC_BUFFER. Read-write. Reset: 0000_0000h.">
      <field name="BUFF_DATA1" bit="16" size="16" desc="Read-write. Reset: 0000h. Data buffer. Upper bits. Data will be accessed through this register. Data which exceeds the size designated by FCH::SD::MMIO::SDHC_BLK_CS[BLK_SIZE] will not be written in the data buffer." />
      <field name="BUFF_DATA0" bit="0" size="16" desc="Read-write. Reset: 0000h. Lower bits." />
    </register>
    <register name="SDHC_PRSNT_STATE" type="mmio" bar="SDHC" offset="0x024" size="4" desc="FCH::SD::MMIO::SDHC_PRSNT_STATE. Read-only.">
      <!-- Bits 31:20 reserved. -->
      <field name="WP_LEVEL" bit="19" size="1" desc="Read-only. Reset: 0. 0=Write protected. 1=Write enable. Write Protect switch Level." />
      <field name="CD_LEVEL" bit="18" size="1" desc="Read-only. Reset: 0. 0=No card present. 1=Card present. Card Detect pin level. This bit is used for testing." />
      <!-- Bit 17 reserved. -->
      <field name="CARD_INS" bit="16" size="1" desc="Read-only. Reset: 0. 0=No card inserted or debouncing state or resetting. 1=Card inserted. Card inserted." />
      <!-- Bits 15:12 reserved. -->
      <field name="BUF_RD_EN" bit="11" size="1" desc="Read-only. Reset: 0. 0=Read disable. 1=Read enable. Buffer Read enable. Indicates buffer is ready for reading." />
      <field name="BUF_WR_EN" bit="10" size="1" desc="Read-only. Reset: 0. 0=Write disable. 1=Write enable. Buffer Write enable. Indicates buffer is ready for writing." />
      <field name="RD_TX_ACTIVE" bit="9" size="1" desc="Read-only. Reset: 0. 0=No data transferring. 1=Read data transferring. Read Transfer active. Indicates duration of read data transfer." />
      <field name="WR_TX_ACTIVE" bit="8" size="1" desc="Read-only. Reset: 0. 0=No data transferring. 1=Write data transferring. Write Transfer active. Indicates duration of write data transfer." />
      <!-- Bits 7:3 reserved. -->
      <field name="DAT_LINE_ACTIVE" bit="2" size="1" desc="Read-only. Reset: 0. 0=DAT line inactive. 1=DAT line active. DAT Line Active. Indicates DAT line on SD Bus is active." />
      <field name="CMD_INHIB_DAT" bit="1" size="1" desc="Read-only. Reset: 0. 0=Can issue commands which uses the DAT line. 1=Cannot issue any commands which uses the DAT line. Command inhibit (DAT). Indicates that commands which use also use the DAT line can be issued." />
      <field name="CMD_INHIB_CMD" bit="0" size="1" desc="Read-only. Reset: 0. 0=Can issue commands which use CMD line. 1=Cannot issue any commands. Command Inhibit (CMD). Indicates that commands which use only the CMD line can be issued." />
    </register>
    <register name="SDHC_CTRL1" type="mmio" bar="SDHC" offset="0x028" size="4" desc="FCH::SD::MMIO::SDHC_CTRL1.">
      <!-- Bits 31:27 reserved. -->
      <field name="SD_REM_WAKE_EN" bit="26" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. SD Card removal wakeup." />
      <field name="SD_INS_WAKE_EN" bit="25" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. SD Card insertion wakeup." />
      <field name="SD_INT_WAKE_EN" bit="24" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. SD Card interrupt wakeup." />
      <!-- Bits 23:20 reserved. -->
      <field name="BG_INT_EN" bit="19" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Interrupt at Block Gap. Enable interrupt detection during 4-bit block transmission." />
      <field name="READ_WAIT_EN" bit="18" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Read Wait Control. Indicates Read Wait will be inserted when needed." />
      <field name="CONT_REQ" bit="17" size="1" desc="Read-write. Reset: 0. 0=No effect. 1=Restart. Continue request. Writing 1 to this bit triggers a restart of halted data transaction with the current register setting. Once this bit is 1, the internal buffer is cleared and the data transfer sequence will be restarted." />
      <field name="BG_STOP_REQ" bit="16" size="1" desc="Read-write. Reset: 0. 0=Transfer. 1=Stop. Stop at Block Gap request. Writing 1 to this bit triggers the halting of the current data transfer after the next block gap. For using this request, the Read Wait function is necessary in the Read transaction. Even if FCH::SD::MMIO::SDHC_CMD_TRN[ACMD12_EN] == 1, Auto CMD12 is not issued in the case of this bit being set to 1. This bit is cleared by not only Writing 0 to this bit, but also issuing abort commands." />
      <!-- Bits 15:12 reserved. -->
      <field name="SD_BUS_VOLTAGE" bit="9" size="3" desc="Read-write. Reset: 0h. SD bus voltage." />
      <field name="SD_BUS_EN" bit="8" size="1" desc="Read-write. Reset: 0. 0=Off. 1=On. SD bus power. When card is removed, this bit is cleared automatically." />
      <!-- Bits 7:6 reserved. -->
      <field name="MMC_WIDTH" bit="5" size="1" desc="Read-write. Reset: 0. 0=Use width set by FCH::SD::MMIO::SDHC_CTRL1[DAT_TX_WIDTH]. 1=8-bit. Extended data transfer width (MMC)." />
      <field name="DMA_SELECT" bit="3" size="2" desc="Read-write. Reset: 0h. DMA select. Valid only when DMA is enabled." />
      <field name="HIGH_SPEED_EN" bit="2" size="1" desc="Read-write. Reset: 0. 0=Normal speed. 1=High speed. High Speed enable. When disabled, SD controller outputs commands and data on the falling edge of the SD clock (Up to 25MHz SD clock can be supported). When enabled, SD controller outputs commands and data on the rising edge of the SD clock (Up to 50MHz SD clock can be supported)." />
      <field name="DAT_TX_WIDTH" bit="1" size="1" desc="Read-write. Reset: 0. 0=1-bit. 1=4-bit. Data transfer width." />
      <field name="LED_CTRL" bit="0" size="1" desc="Read-write. Reset: 0. 0=Off. 1=On. LED control. Drives the LED_ON output." />
    </register>

    <!-- page 570 -->

    <register name="SDHC_CTRL2" type="mmio" bar="SDHC" offset="0x02C" size="4" desc="FCH::SD::MMIO::SDHC_CTRL2.">
      <!-- Bits 31:27 reserved. -->
      <field name="SOFT_RST_DAT" bit="26" size="1" desc="Read-write. Reset: 0." />
      <field name="SOFT_RST_CMD" bit="25" size="1" desc="Read-write. Reset: 0." />
      <field name="SOFT_RST_ALL" bit="24" size="1" desc="Read-write. Reset: 0." />
      <!-- Bits 23:20 reserved. -->
      <field name="DATA_TO_CNT" bit="16" size="4" desc="Read-write. Reset: 0h. Data Timeout Counter Value. By using this counter value, DAT line timeouts are detected." />
      <field name="SDCLK_DIV" bit="8" size="8" desc="Read-write. Reset: 00h. SDCLK frequency select. If multiple bits are set, the most significant bit will be selected." />
      <!-- Bits 7:3 reserved. -->
      <field name="SDCLK_EN" bit="2" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. SD clock enable. SDCLK frequency select can be changed when this bit is 0. When card is removed, this bit is cleared to 0 automatically." />
      <field name="SYSCLK_STABLE" bit="1" size="1" desc="Read-only. Reset: 0. 0=Unstable. 1=Stable. Internal clock stable." />
      <field name="SYSCLK_EN" bit="0" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Internal clock enable." />
    </register>

    <!-- page 572 -->

    <register name="SDHC_INT_STATUS" type="mmio" bar="SDHC" offset="0x030" size="4" desc="FCH::SD::MMIO::SDHC_INT_STATUS. Read-only.">
      <!-- Bits 31:30 reserved. -->
      <field name="CE_ATA_ERR" bit="29" size="1" desc="Read-only. Reset: 0. CE-ATA error." />
      <field name="SDMA_ERR" bit="28" size="1" desc="Read-only. Reset: 0. SDMA error." />
      <!-- Bits 27:26 reserved. -->
      <field name="ADMA_ERR" bit="25" size="1" desc="Read-only. Reset: 0. ADMA error." />
      <field name="ACMD12_ERR" bit="24" size="1" desc="Read-only. Reset: 0. Auto CMD12 error. Logical OR of Auto CMD12 Error Status Register." />
      <!-- Bit 23 reserved. -->
      <field name="DAT_END_ERR" bit="22" size="1" desc="Read-only. Reset: 0. Data End error." />
      <field name="DAT_CRC_ERR" bit="21" size="1" desc="Read-only. Reset: 0. Data CRC error." />
      <field name="DAT_TO_ERR" bit="20" size="1" desc="Read-only. Reset: 0. Data Timeout error." />
      <field name="CMD_IDX_ERR" bit="19" size="1" desc="Read-only. Reset: 0. Command Index error. Mismatch of Command Index and index of response." />
      <field name="CMD_END_ERR" bit="18" size="1" desc="Read-only. Reset: 0. Command End Bit error." />
      <field name="CMD_CRC_ERR" bit="17" size="1" desc="Read-only. Reset: 0. Command CRC Error. If (CMD_TO_ERR &amp;&amp; CMD_CRC_ERR) == 1, this indicates a Command Conflict Error." />
      <field name="CMD_TO_ERR" bit="16" size="1" desc="Read-only. Reset: 0. Command Timeout error. Response not returned within 128 SDCLK cycles." />
      <field name="ERROR" bit="15" size="1" desc="Read-only. Reset: 0. Error interrupt." />
      <!-- Bits 14:9 reserved. -->
      <field name="SDIO" bit="8" size="1" desc="Read-only. Reset: 0. SDIO Card interrupt. Writing 1 to this register does not clear this bit. For clearing this bit, the interrupt factor of SDIO cards should be cleared. The value of this bit is latched internally as long as the Card Interrupt bit (D08) in the Normal Interrupt Status Enable Register is 1." />
      <field name="CARD_REM" bit="7" size="1" desc="Read-only. Reset: 0. Card removal." />
      <field name="CARD_INS" bit="6" size="1" desc="Read-only. Reset: 0. Card insertion." />
      <field name="BUF_RD_RDY" bit="5" size="1" desc="Read-only. Reset: 0. Buffer Read Ready. In case FCH::SD::MMIO::SDHC_CMD_TRN[ACMD12_EN] == 1 and last block has been transferred, Auto CMD12 will be issued prior to this bit being set to 1. Clearing this bit should be done before Reading the buffer because the SD controller has a dual buffer and the next Buffer Read Ready interrupt may occur immediately." />
      <field name="BUF_WR_RDY" bit="4" size="1" desc="Read-only. Reset: 0. Buffer Write Ready. Clearing this bit should be done before writing to the buffer because the SD controller has a dual buffer and the next Buffer Write Ready interrupt may occur immediately." />
      <field name="DMA_EVT" bit="3" size="1" desc="Read-only. Reset: 0. DMA interrupt. It is set when the internal counter reaches the value designated by the Host DMA Buffer Boundary. It should be cleared by the Host Driver after the System Address Register is updated." />
      <field name="BLOCK_GAP_EVT" bit="2" size="1" desc="Read-only. Reset: 0. Block gap event. It indicates the timing of next block gap, which was requested by the Stop At Block Gap Request. In the case of a Write transaction, this interrupt will be generated before busy completion." />
      <field name="DAT_DONE" bit="1" size="1" desc="Read-only. Reset: 0. 0=Data not done. 1=Data done. Data transfer complete. Indicates the timing for completion of data transaction, which includes the completion at the block gap by the Stop At Block Gap Request. When some errors are detected during data transaction, this bit will not be set. In case that FCH::SD::MMIO::SDHC_CMD_TRN[ACMD12_EN] == 1, Auto CMD12 will be issued prior to this bit being  set to 1." />
      <field name="CMD_DONE" bit="0" size="1" desc="Read-only. Reset: 0. 0=Command not done. 1=Command done. Command complete. The end bit of the command response is received. In the case of commands with no response, the end of the command." />
    </register>

    <!-- page 573 -->

    <register name="SDHC_INT_MASK" type="mmio" bar="SDHC" offset="0x034" size="4" desc="FCH::SD::MMIO::SDHC_INT_MASK.">
      <!-- Bits 31:30 reserved. -->
      <field name="CE_ATA_ERR_MASK" bit="29" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. CE-ATA Error interrupt mask." />
      <field name="SDMA_ERR_MASK" bit="28" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. SDMA Error interrupt mask." />
      <!-- Bits 27:26 reserved. -->
      <field name="ADMA_ERR_MASK" bit="25" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. ADMA Error interrupt mask." />
      <field name="ACMD12_ERR_MASK" bit="24" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Auto CMD12 Error interrupt mask." />
      <field name="CUR_LIM_ERR_MASK" bit="23" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Current Limit Error interrupt mask." />
      <field name="DAT_END_ERR_MASK" bit="22" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Data End Bit Error interrupt mask." />
      <field name="DAT_CRC_ERR_MASK" bit="21" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Data CRC Error interrupt mask." />
      <field name="DAT_TO_ERR_MASK" bit="20" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Data Timeout Error interrupt mask." />
      <field name="CMD_IDX_ERR_MASK" bit="19" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Command Index Error interrupt mask." />
      <field name="CMD_END_ERR_MASK" bit="18" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Command End Bit Error interrupt mask." />
      <field name="CMD_CRC_ERR_MASK" bit="17" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Command CRC Error interrupt mask." />
      <field name="CMD_TO_ERR_MASK" bit="16" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Command Timeout Error interrupt mask." />
      <!-- Bits 15:9 reserved. -->
      <field name="SDIO_MASK" bit="8" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Card interrupt mask." />
      <field name="CARD_REM_MASK" bit="7" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Card Removal interrupt mask." />
      <field name="CARD_INS_MASK" bit="6" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Card Insertion interrupt mask." />
      <field name="BUF_RD_RDY_MASK" bit="5" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Buffer Read Ready interrupt mask." />
      <field name="BUF_WR_RDY_MASK" bit="4" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Buffer Write Ready interrupt mask." />
      <field name="DMA_EVT_MASK" bit="3" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. DMA Interrupt interrupt mask." />
      <field name="BLOCK_GAP_EVT_MASK" bit="2" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Block Gap Event interrupt mask." />
      <field name="DAT_DONE_MASK" bit="1" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Transfer Complete interrupt mask." />
      <field name="CMD_DONE_MASK" bit="0" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Command Complete interrupt mask." />
    </register>
    <register name="SDHC_SIG_MASK" type="mmio" bar="SDHC" offset="0x038" size="4" desc="FCH::SD::MMIO::SDHC_SIG_MASK.">
      <!-- Bits 31:30 reserved. -->
      <field name="CE_ATA_ERR_EN" bit="29" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. CE-ATA error." />
      <field name="SDMA_ERR_EN" bit="28" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. SDMA error." />
      <!-- Bits 27:26 reserved. -->
      <field name="ADMA_ERR_EN" bit="25" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. ADMA error." />
      <field name="ACMD12_ERR_EN" bit="24" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Auto CMD12 error." />
      <field name="CUR_LIM_ERR_EN" bit="23" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Current Limit error." />
      <field name="DAT_END_ERR_EN" bit="22" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Data End Bit error." />
      <field name="DAT_CRC_ERR_EN" bit="21" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Data CRC error." />
      <field name="DAT_TO_ERR_EN" bit="20" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Data Timeout error." />
      <field name="CMD_IDX_ERR_EN" bit="19" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Command Index error." />
      <field name="CMD_END_ERR_EN" bit="18" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Command End Bit error." />
      <field name="CMD_CRC_ERR_EN" bit="17" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Command CRC error." />
      <field name="CMD_TO_ERR_EN" bit="16" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Command Timeout error." />
      <!-- Bits 15:9 reserved. -->
      <field name="SDIO_EN" bit="8" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Card Interrupt." />
      <field name="CARD_REM_EN" bit="7" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Card Removal." />
      <field name="CARD_INS_EN" bit="6" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Card Insertion." />
      <field name="BUF_RD_RDY_EN" bit="5" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Buffer Read Ready." />
      <field name="BUF_WR_RDY_EN" bit="4" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Buffer Write Ready." />
      <field name="DMA_EVT_EN" bit="3" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. DMA Interrupt." />
      <field name="BLOCK_GAP_EVT_EN" bit="2" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Block Gap Event." />
      <field name="DAT_DONE_EN" bit="1" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Transfer Complete." />
      <field name="CMD_DONE_EN" bit="0" size="1" desc="Read-write. Reset: 0. 0=Masked. 1=Enabled. Command Complete." />
    </register>

    <!-- page 574 -->

    <register name="SDHC_ACMD12_ERR" type="mmio" bar="SDHC" offset="0x03C" size="4" desc="FCH::SD::MMIO::SDHC_ACMD12_ERR. Read-only.">
      <!-- Bits 31:8 reserved. -->
      <field name="CMD_ERR" bit="7" size="1" desc="Read-only. Reset: 0. Command not issued by Auto CMD12 error." />
      <!-- Bits 6:5 reserved. -->
      <field name="INDEX_ERR" bit="4" size="1" desc="Read-only. Reset: 0. Auto CMD12 Index error." />
      <field name="END_ERR" bit="3" size="1" desc="Read-only. Reset: 0. Auto CMD12 End Bit error." />
      <field name="CRC_ERR" bit="2" size="1" desc="Read-only. Reset: 0. Auto CMD12 CRC error." />
      <field name="TO_ERR" bit="1" size="1" desc="Read-only. Reset: 0. Auto CMD12 Timeout error." />
      <field name="EXE_ERR" bit="0" size="1" desc="Read-only. Reset: 0. Auto CMD12 Not Executed error." />
    </register>
    <register name="SDHC_CAPABILITY" type="mmio" bar="SDHC" offset="0x040" size="4" desc="FCH::SD::MMIO::SDHC_CAPABILITY. Read-only.">
      <!-- Bits 31:27 reserved. -->
      <field name="SUPPORT_1_8V" bit="26" size="1" desc="Read-only. Reset: 0. 0=Not supported. 1=Supported. Voltage support for 1.8V." />
      <field name="SUPPORT_3_0V" bit="25" size="1" desc="Read-only. Reset: 0. 0=Not supported. 1=Supported. Voltage support for 3.0V." />
      <field name="SUPPORT_3_3V" bit="24" size="1" desc="Read-only. Reset: 1. 0=Not supported. 1=Supported. Voltage support for 3.3V." />
      <field name="SUS_RES_SUPPORT" bit="23" size="1" desc="Read-only. Reset: 1. 0=Not supported. 1=Supported. Suspend and Resume support." />
      <field name="DMA_SUPPORT" bit="22" size="1" desc="Read-only. Reset: 0. 0=Not supported. 1=Supported. DMA support." />
      <field name="HISPEED_SUPPORT" bit="21" size="1" desc="Read-only. Reset: 1. 0=Not supported. 1=Supported. High Speed support." />
      <field name="ADMA_SUPPORT" bit="20" size="1" desc="Read-only. Reset: 1. 0=Not supported. 1=Supported. ADMA support." />
      <field name="SYS_SUPPORT" bit="19" size="1" desc="Read-only. Reset: 0. Fixed to 0 in this release." />
      <field name="MMC8_SUPPORT" bit="18" size="1" desc="Read-only. Reset: 1. 0=Not supported. 1=Supported. Extended Media Bus Support (MMC)." />
      <field name="MAX_BLK_LEN" bit="16" size="2" desc="Read-only. Reset: 2h. Max block length." />
      <!-- Bits 15:14 reserved. -->
      <field name="BASE_CLK_FREQ" bit="8" size="6" desc="Read-only. Reset: 18h. Base clock frequency for SD clock." />
      <field name="TO_CLK_UNIT" bit="7" size="1" desc="Read-only. Reset: 1. 0=Clock units are in KHz. 1=Clock units are in MHz. Timeout clock Unit." />
      <!-- Bit 6 reserved. -->
      <field name="TO_CLK_FREQ" bit="0" size="6" desc="Read-only. Reset: 18h. Timeout clock frequency. See also TO_CLK_UNIT to get the units." />
    </register>

    <!-- page 575 -->

    <register name="SDHC_CURR_CAPABILITY" type="mmio" bar="SDHC" offset="0x048" size="4" desc="FCH::SD::MMIO::SDHC_CURR_CAPABILITY. Read-only.">
      <!-- Bits 31:24 reserved. -->
      <field name="MAX_CURR_1_8V" bit="16" size="8" desc="Read-only. Reset: 00h. Max current for 1.8V." />
      <field name="MAX_CURR_3_0V" bit="8" size="8" desc="Read-only. Reset: 00h. Max current for 3.0V." />
      <field name="MAX_CURR_3_3V" bit="0" size="8" desc="Read-only. Reset: 64h. Max current for 3.3V." />
    </register>
    <register name="SDHC_FORCE_EVT" type="mmio" bar="SDHC" offset="0x050" size="4" desc="FCH::SD::MMIO::SDHC_FORCE_EVT.">
      <!-- Bits 31:30 reserved. -->
      <field name="CE_ATA_ERR_FRC" bit="29" size="1" desc="Write-only. Reset: 0. 0=No Interrupt. 1=Interrupt is generated. Force CE-ATA error." />
      <field name="SDMA_ERR_FRC" bit="28" size="1" desc="Write-only. Reset: 0. 0=No Interrupt. 1=Interrupt is generated. Force SDMA error." />
      <!-- Bits 27:26 reserved. -->
      <field name="ADMA_ERR_FRC" bit="25" size="1" desc="Write-only. Reset: 0. 0=No Interrupt. 1=Interrupt is generated. Force ADMA error." />
      <field name="ACMD12_ERR_FRC" bit="24" size="1" desc="Write-only. Reset: 0. 0=No Interrupt. 1=Interrupt is generated. Force Auto CMD12 error." />
      <field name="CUR_LIM_ERR_FRC" bit="23" size="1" desc="Write-only. Reset: 0. 0=No Interrupt. 1=Interrupt is generated. Force current limit error." />
      <field name="DAT_END_ERR_FRC" bit="22" size="1" desc="Write-only. Reset: 0. 0=No Interrupt. 1=Interrupt is generated. Force data end bit error." />
      <field name="DAT_CRC_ERR_FRC" bit="21" size="1" desc="Write-only. Reset: 0. 0=No Interrupt. 1=Interrupt is generated. Force data CRC error." />
      <field name="DAT_TO_ERR_FRC" bit="20" size="1" desc="Write-only. Reset: 0. 0=No Interrupt. 1=Interrupt is generated. Force data timeout error." />
      <field name="CMD_IDX_ERR_FRC" bit="19" size="1" desc="Write-only. Reset: 0. 0=No Interrupt. 1=Interrupt is generated. Force command index error." />
      <field name="CMD_END_ERR_FRC" bit="18" size="1" desc="Write-only. Reset: 0. 0=No Interrupt. 1=Interrupt is generated. Force command end bit error." />
      <field name="CMD_CRC_ERR_FRC" bit="17" size="1" desc="Write-only. Reset: 0. 0=No Interrupt. 1=Interrupt is generated. Force command CRC error." />
      <field name="CMD_TO_ERR_FRC" bit="16" size="1" desc="Write-only. Reset: 0. 0=No Interrupt. 1=Interrupt is generated. Force command timeout error." />
      <!-- Bits 15:8 reserved. -->
      <field name="ACMD12_CMD_ERR_FRC" bit="7" size="1" desc="Write-only. Reset: 0. 0=No Interrupt. 1=Interrupt is generated. Force command not issued by Auto CMD12 error." />
      <!-- Bits 6:5 reserved. -->
      <field name="ACMD12_IDX_ERR_FRC" bit="4" size="1" desc="Write-only. Reset: 0. 0=No Interrupt. 1=Interrupt is generated. Force Auto CMD12 index error." />
      <field name="ACMD12_END_ERR_FRC" bit="3" size="1" desc="Write-only. Reset: 0. 0=No Interrupt. 1=Interrupt is generated. Force Auto CMD12 end bit error." />
      <field name="ACMD12_CRC_ERR_FRC" bit="2" size="1" desc="Write-only. Reset: 0. 0=No Interrupt. 1=Interrupt is generated. Force Auto CMD12 CRC error." />
      <field name="ACMD12_TO_ERR_FRC" bit="1" size="1" desc="Write-only. Reset: 0. 0=No Interrupt. 1=Interrupt is generated. Force Auto CMD12 timeout error." />
      <field name="ACMD12_EXE_ERR_FRC" bit="0" size="1" desc="Write-only. Reset: 0. 0=No Interrupt. 1=Interrupt is generated. Force Auto CMD12 not executed error." />
    </register>

    <!-- page 576 -->

    <register name="SDHC_ADMA_ERR" type="mmio" bar="SDHC" offset="0x054" size="4" desc="FCH::SD::MMIO::SDHC_ADMA_ERR. Read-only.">
      <!-- Bits 31:3 reserved. -->
      <field name="ADDR_LEN_MISMATCH" bit="2" size="1" desc="Read-only. Reset: 0. 0=No error. 1=Error." />
      <field name="ADMA_STATE" bit="0" size="2" desc="Read-only. Reset: 0h. ADMA states when an error occured." />
    </register>

    <!-- page 577 -->

    <register name="SDHC_ADMA_SAD" type="mmio" bar="SDHC" offset="0x058" size="4" desc="FCH::SD::MMIO::SDHC_ADMA_SAD. Read-write. Reset: 0000_0000h.">
      <field name="ADMA_SYS_ADDR1" bit="16" size="16" desc="Read-write. Reset: 0000h. Upper bits of ADMA system address. Before the ADMA data transfer, the descriptor address should be set by the Host driver. This address needs to be set with 4-byte alignment, since the descriptor table is formatted for 32-bit (4 bytes) information." />
      <field name="ADMA_SYS_ADDR0" bit="0" size="16" desc="Read-write. Reset: 0000h. Lower bits of ADMA system address." />
    </register>
    <register name="SDHC_CE_ATA_CTRL" type="mmio" bar="SDHC" offset="0x080" size="4" desc="FCH::SD::MMIO::SDHC_CE_ATA_CTRL.">
      <!-- Bits 31:5 reserved. -->
      <field name="CE_ATA_SUPPORT" bit="4" size="1" desc="Read-only. Reset: 1. 0=Unsupported. 1=Supported. CE-ATA support capability. When supported, bits[3:0] can be written." />
      <field name="CE_ATA_EN" bit="3" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. CE-ATA enable. When enabled bits[2:0] can be written." />
      <field name="P_DRIVE_DIS" bit="2" size="1" desc="Read-write. Reset: 0. 0=Enable. 1=Disable. P-Drive disable." />
      <field name="CMD_COMP_DIS_EN" bit="1" size="1" desc="Read-write. Reset: 0. 0=Wait after command. 1=Issued after command. Command Completion Signal Disable enable." />
      <field name="CMD_COMP_SIG_EN" bit="0" size="1" desc="Read-write. Reset: 0. 0=Disable. 1=Enable. Command Completion Signal enable. When the Command Completion Signal is enabled, the FCH::SD::MMIO::SDHC_CMD_TRN[ACMD12_EN] bit in the Transfer Mode register becomes of no use." />
    </register>
    <register name="SDHC_DAT3_CARD_DET" type="mmio" bar="SDHC" offset="0x090" size="4" desc="FCH::SD::MMIO::SDHC_DAT3_CARD_DET.">
      <!-- Bits 31:5 reserved. -->
      <field name="DEBOUNCING_EN" bit="4" size="1" desc="Read-write. Reset: 1. 0=Disable. 1=Enable. Debouncing enable. This bit should be cleared before starting command or data transfer if debouncing state is not needed in the error cases." />
      <field name="DEBOUNCING_STATUS" bit="3" size="1" desc="Read-only. Reset: 0. 0=Not debouncing. 1=Debouncing. Debouncing State status. Indicates the card is debouncing. Should not issue any commands during debouncing." />
      <field name="CARD_DETECT_SEL" bit="2" size="1" desc="Read-only. Reset: 0. 0=Standard Card Detect mode. 1=DAT3 Card Detect mode. Card Detct Select status." />
      <field name="DAT3_DETECT_EN" bit="1" size="1" desc="Read-write. Reset: 1. 0=Disable. 1=Enable. DAT3 Card Detect control. Disable this bit before writing to the Command Register. After Command or Transfer complete, this bit can be re-enabled. During command and data transfer, enabling DAT3 Card Detection is prohibited. This bit is fixed to 1 in Standard Card Detect mode." />
      <field name="DAT3_CARD_INS" bit="0" size="1" desc="Read-only. Reset: 0. 0=No card inserted. 1=Card inserted. DAT3 Card inserted." />
    </register>
    <register name="SDHC_VER_SLOT" type="mmio" bar="SDHC" offset="0x0FC" size="4" desc="FCH::SD::MMIO::SDHC_VER_SLOT. Read-only.">
      <field name="VENDOR_VERSION" bit="24" size="8" desc="Read-only. Reset: C3h. Vendor Version." />
      <field name="SPEC_VERSION" bit="16" size="8" desc="Read-only. Reset: 02h. Specification Version." />
      <!-- Bits 15:8 reserved. -->
      <field name="SLOT_INTRPT" bit="0" size="8" desc="Read-only. Reset: 00h. Interrupt signal for each slot. The value of XSLT_INT[7:0] inputs, which indicates the logical OR of Interrupt signal and Wakeup signal, are inverted and referred by this register. In case of multiple slots, Interrupt signal and Wakeup signal should be logical ORed externally and should be inputted to each of XSLT_INT[7:0]." />
    </register>

    <!-- 9.2.13 USB Legacy Registers -->

    <!-- page 578 -->

    <register name="HceControl" type="memory" device="HCE" offset="0x040" size="4" desc="HCE Control. Used to enable and control the emulation hardware and report various status information.">
      <!-- Bits 31:9 reserved. -->
      <field name="A20State" bit="8" size="1" desc="Read-write. Reset: 0. Indicates current state of Gate A20 on keyboard controller." />
      <field name="IRQ12Active" bit="7" size="1" desc="Read,Write-1-to-clear. Reset: 0. Indicates that a positive transition on IRQ12 from the keyboard controller has occurred. Software may write a 1 to this bit to clear it (set it to 0). Software write of a 0 to this bit has no effect." />
      <field name="IRQ1Active" bit="6" size="1" desc="Read,Write-1-to-clear. Reset: 0. Indicates that a positive transition on IRQ1 from the keyboard controller has occurred. Software may write a 1 to this bit to clear it (set it to 0). Software write of a 0 to this bit has no effect." />
      <field name="GateA20Sequence" bit="5" size="1" desc="Read-write. Reset: 0. Set by the Host Controller (HC)." />
      <field name="ExternalIRQEn" bit="4" size="1" desc="Read-write. Reset: 0. 1=IRQ1 and IRQ12 from the keyboard controller causes an emulation interrupt. The function controlled by this bit is independent of the setting of the EmulationEnable bit in this register." />
      <field name="IRQEn" bit="3" size="1" desc="Read-write. Reset: 0. 1=The HC generates IRQ1 or IRQ12 as long as the FCH::USBLEGACY::HceStatus[OutputFull] == 1. If FCH::USBLEGACY::HceStatus[AuxOutputFull] == 0, then IRQ1 is generated, else if it is 1, then an IRQ12 is generated." />
      <field name="CharacterPending" bit="2" size="1" desc="Read-write. Reset: 0. 1=An emulation interrupt is generated when FCH::USBLEGACY::HceStatus[OutputFull] = 0." />
      <field name="EmulationInterrupt" bit="1" size="1" desc="Read-only. This bit is a static decode of the emulation interrupt condition." />
      <field name="EmulationEnable" bit="0" size="1" desc="Read-write. Reset: 0. 0=Disabled. 1=The HC is enabled for legacy emulation. The HC decodes accesses and generates IRQ1 and/or IRQ12 when appropriate. Additionally, the HC generates an emulation interrupt at appropriate times to invoke the emulation software." />
    </register>
    <register name="HceInput" type="memory" device="HCE" offset="0x044" size="4" desc="HCE Input. Read-write. Reset: 0000_0000h. This register may be Read or Written directly by accessing it with its memory address in the Host Controller's operational register space. When accessed directly with a memory cycle, Reads and Writes of this register have no side effects.">
      <!-- Bits 31:8 reserved. -->
      <field name="InputData" bit="0" size="8" desc="Read-write. Reset: 00h. This register holds data that is written." />
    </register>

    <!-- page 579 -->

    <register name="HceOutput" type="memory" device="HCE" offset="0x048" size="4" desc="HCE Output. Read-write. Reset: 0000_0000h. The data placed in this register by the emulation software is returned when I/O port 60h is Read and emulation is enabled (FCH::USBLEGACY::HceControl[EmulationEnable] == 1). On a Read of this location, FCH::USBLEGACY::HceStatus[OutputFull] = 0 is set.">
      <!-- Bits 31:8 reserved. -->
      <field name="OutputData" bit="0" size="8" desc="Read-write. Reset: 00h. This register hosts data that is returned when an IO Read of port 60h is performed by application software." />
    </register>
    <register name="HceStatus" type="memory" device="HCE" offset="0x04C" size="4" desc="HCE Status. Read-write. Reset: 0000_0000h. The contents of the HceStatus Register are returned on an IO Read of port 64h when emulation is enabled. Reads and Writes of port 60h and Writes to port 64h can cause changes in this register. Emulation software can directly access this register through its memory address in the Host Controller's operational register space. Accessing this register through its memory address produces no side effects.">
      <!-- Bits 31:8 reserved. -->
      <field name="Parity" bit="7" size="1" desc="Read-write. Reset: 0. Indicates parity error on keyboard/mouse data." />
      <field name="TimeOut" bit="6" size="1" desc="Read-write. Reset: 0. Used to indicate a time-out." />
      <field name="AuxOutputFull" bit="5" size="1" desc="Read-write. Reset: 0. IRQ12 is asserted whenever this bit is set to 1 and (OutputFull == 1 &amp;&amp; FCH::USBLEGACY::HceControl[IRQEn] == 1)." />
      <field name="InhibitSwitch" bit="4" size="1" desc="Read-write. Reset: 0. This bit reflects the state of the keyboard inhibit switch and is set if the keyboard is NOT inhibited." />
      <field name="CmdData" bit="3" size="1" desc="Read-write. Reset: 0. The HC sets this bit to 0 on an IO Write to port 60h and to 1 on an IO Write to port 64h." />
      <field name="Flag" bit="2" size="1" desc="Read-write. Reset: 0. Nominally used as a system flag by software to indicate a warm or cold boot." />
      <field name="InputFull" bit="1" size="1" desc="Read-write. Reset: 0. Except for the case of a Gate A20 sequence, this bit is set to 1 on an IO Write to address 60h or 64h. While this bit is set to 1 and FCH::USBLEGACY::HceControl[EmulationEnable] == 1, an emulation interrupt condition exists." />
      <field name="OutputFull" bit="0" size="1" desc="Read-write. Reset: 0. The HC sets this bit to 0 on a Read of IO port 60h. If (FCH::USBLEGACY::HceControl[IRQEn] == 1 &amp;&amp; AuxOutputFull == 0), then an IRQ1 is generated as long as this bit is set to 1. If (FCH::USBLEGACY::HceControl[IRQEn] == 1 &amp;&amp; AuxOutputFull == 1), then an IRQ12 is generated as long as this bit is set to 1. While this bit is 0 and FCH::USBLEGACY::HceControl[CharacterPending] == 1, an emulation interrupt condition exists." />
    </register>
    <register name="HceIntrEn" type="memory" device="HCE" offset="0x050" size="4" desc="HCE Interrupts Enable. Read-write. Reset: 0000_00A3h.">
      <!-- Bits 31:11 reserved. -->
      <field name="A20State_inv" bit="10" size="1" desc="Read-write. Reset: 0. 1=Use inverted version of A20State." />
      <field name="SOFSrc" bit="8" size="2" desc="Read-write. Reset: 0h. Indicates which HCI_MSofN source is used in USB Legacy." />
      <field name="SOFCounter" bit="5" size="3" desc="Read-write. Reset: 5h. The amount of SOF number that emulation interrupt has to wait before SMI is sent." />
      <field name="EmulationSmiEn" bit="4" size="1" desc="Read-write. Reset: 0. 1=Generate SMI if emulation interrupt happens." />
      <field name="BlockIRQ12" bit="3" size="1" desc="Read-write. Reset: 0. 1=Block IRQ12." />
      <field name="BlockIRQ1" bit="2" size="1" desc="Read-write. Reset: 0. 1=Block IRQ1." />
      <field name="EnIRQ12" bit="1" size="1" desc="Read-write. Reset: 1. 1=Enable IRQ12Active." />
      <field name="EnIRQ1" bit="0" size="1" desc="Read-write. Reset: 1. 1=Enable IRQ1Active." />
    </register>

  </registers>

  <!-- #################################### -->
  <!--                                      -->
  <!-- Controls                             -->
  <!--                                      -->
  <!-- #################################### -->
  <controls>
  </controls>

  <!-- #################################### -->
  <!--                                      -->
  <!-- Locks                                -->
  <!--                                      -->
  <!-- #################################### -->
  <locks>
    <lock name="SpiHostAccessRomEn" register="SPICntrl0" field="SpiHostAccessRomEn" value="0" desc="Lock RomProtect and SPIRestrictedCmd" />
    <lock name="SpiProtectLock" register="AltSPICS" field="SpiProtectLock" value="1" desc="Lock AltSPICS" />
  </locks>

</configuration>
